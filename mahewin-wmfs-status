#!/usr/bin/env perl
# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Class/Load.pm"} = <<'CLASS_LOAD';
  package Class::Load;
  {
    $Class::Load::VERSION = '0.13';
  }
  use strict;
  use warnings;
  use base 'Exporter';
  use Data::OptList 'mkopt';
  use Module::Runtime 0.011 qw(
      check_module_name
      module_notional_filename
      require_module
      use_module
  );
  use Package::Stash;
  use Try::Tiny;
  
  our $IMPLEMENTATION;
  
  BEGIN {
      $IMPLEMENTATION = $ENV{CLASS_LOAD_IMPLEMENTATION}
          if exists $ENV{CLASS_LOAD_IMPLEMENTATION};
  
      my $err;
      if ($IMPLEMENTATION) {
          try {
              require_module("Class::Load::$IMPLEMENTATION");
          }
          catch {
              require Carp;
              Carp::croak("Could not load Class::Load::$IMPLEMENTATION: $_");
          };
      }
      else {
          for my $impl ('XS', 'PP') {
              try {
                  require_module("Class::Load::$impl");
                  $IMPLEMENTATION = $impl;
              }
              catch {
                  $err .= $_;
              };
  
              last if $IMPLEMENTATION;
          }
      }
  
      if (!$IMPLEMENTATION) {
          require Carp;
          Carp::croak("Could not find a suitable Class::Load implementation: $err");
      }
  
      my $impl = "Class::Load::$IMPLEMENTATION";
      my $stash = Package::Stash->new(__PACKAGE__);
      $stash->add_symbol('&is_class_loaded' => $impl->can('is_class_loaded'));
  
      sub _implementation {
          return $IMPLEMENTATION;
      }
  }
  
  our @EXPORT_OK = qw/load_class load_optional_class try_load_class is_class_loaded load_first_existing_class/;
  our %EXPORT_TAGS = (
      all => \@EXPORT_OK,
  );
  
  our $ERROR;
  
  sub load_class {
      my $class   = shift;
      my $options = shift;
  
      my ($res, $e) = try_load_class($class, $options);
      return 1 if $res;
  
      _croak($e);
  }
  
  sub load_first_existing_class {
      my $classes = Data::OptList::mkopt(\@_)
          or return;
  
      foreach my $class (@{$classes}) {
          check_module_name($class->[0]);
      }
  
      for my $class (@{$classes}) {
          my ($name, $options) = @{$class};
  
          # We need to be careful not to pass an undef $options to this sub,
          # since the XS version will blow up if that happens.
          return $name if is_class_loaded($name, ($options ? $options : ()));
  
          my ($res, $e) = try_load_class($name, $options);
  
          return $name if $res;
  
          my $file = module_notional_filename($name);
  
          next if $e =~ /^Can't locate \Q$file\E in \@INC/;
          next
              if $options
                  && defined $options->{-version}
                  && $e =~ _version_fail_re($name, $options->{-version});
  
          _croak("Couldn't load class ($name) because: $e");
      }
  
      my @list = map {
          $_->[0]
              . ( $_->[1] && defined $_->[1]{-version}
              ? " (version >= $_->[1]{-version})"
              : q{} )
      } @{$classes};
  
      my $err
          .= q{Can't locate }
          . _or_list(@list)
          . " in \@INC (\@INC contains: @INC).";
      _croak($err);
  }
  
  sub _version_fail_re {
      my $name = shift;
      my $vers = shift;
  
      return qr/\Q$name\E version \Q$vers\E required--this is only version/;
  }
  
  sub _or_list {
      return $_[0] if @_ == 1;
  
      return join ' or ', @_ if @_ ==2;
  
      my $last = pop;
  
      my $list = join ', ', @_;
      $list .= ', or ' . $last;
  
      return $list;
  }
  
  sub load_optional_class {
      my $class   = shift;
      my $options = shift;
  
      check_module_name($class);
  
      my ($res, $e) = try_load_class($class, $options);
      return 1 if $res;
  
      return 0
          if $options
              && defined $options->{-version}
              && $e =~ _version_fail_re($class, $options->{-version});
  
      # My testing says that if its in INC, the file definitely exists
      # on disk. In all versions of Perl. The value isn't reliable,
      # but it existing is.
      my $file = module_notional_filename($class);
      return 0 unless exists $INC{$file};
  
      _croak($ERROR);
  }
  
  sub try_load_class {
      my $class   = shift;
      my $options = shift;
  
      check_module_name($class);
  
      local $@;
      undef $ERROR;
  
      if (is_class_loaded($class)) {
          # We need to check this here rather than in is_class_loaded() because
          # we want to return the error message for a failed version check, but
          # is_class_loaded just returns true/false.
          return 1 unless $options && defined $options->{-version};
          return try {
              $class->VERSION($options->{-version});
              1;
          }
          catch {
              _error($_);
          };
      }
  
      my $file = module_notional_filename($class);
      # This says "our diagnostics of the package
      # say perl's INC status about the file being loaded are
      # wrong", so we delete it from %INC, so when we call require(),
      # perl will *actually* try reloading the file.
      #
      # If the file is already in %INC, it won't retry,
      # And on 5.8, it won't fail either!
      #
      # The extra benefit of this trick, is it helps even on
      # 5.10, as instead of dying with "Compilation failed",
      # it will die with the actual error, and thats a win-win.
      delete $INC{$file};
      return try {
          local $SIG{__DIE__} = 'DEFAULT';
          if ($options && defined $options->{-version}) {
              use_module($class, $options->{-version});
          }
          else {
              require_module($class);
          }
          1;
      }
      catch {
          _error($_);
      };
  }
  
  sub _error {
      $ERROR = shift;
      return 0 unless wantarray;
      return 0, $ERROR;
  }
  
  sub _croak {
      require Carp;
      local $Carp::CarpLevel = $Carp::CarpLevel + 1;
      Carp::croak(shift);
  }
  
  1;
  
  # ABSTRACT: a working (require "Class::Name") and more
  
  
  
  =pod
  
  =head1 NAME
  
  Class::Load - a working (require "Class::Name") and more
  
  =head1 VERSION
  
  version 0.13
  
  =head1 SYNOPSIS
  
      use Class::Load ':all';
  
      try_load_class('Class::Name')
          or plan skip_all => "Class::Name required to run these tests";
  
      load_class('Class::Name');
  
      is_class_loaded('Class::Name');
  
      my $baseclass = load_optional_class('Class::Name::MightExist')
          ? 'Class::Name::MightExist'
          : 'Class::Name::Default';
  
  =head1 DESCRIPTION
  
  C<require EXPR> only accepts C<Class/Name.pm> style module names, not
  C<Class::Name>. How frustrating! For that, we provide
  C<load_class 'Class::Name'>.
  
  It's often useful to test whether a module can be loaded, instead of throwing
  an error when it's not available. For that, we provide
  C<try_load_class 'Class::Name'>.
  
  Finally, sometimes we need to know whether a particular class has been loaded.
  Asking C<%INC> is an option, but that will miss inner packages and any class
  for which the filename does not correspond to the package name. For that, we
  provide C<is_class_loaded 'Class::Name'>.
  
  =head1 FUNCTIONS
  
  =head2 load_class Class::Name, \%options
  
  C<load_class> will load C<Class::Name> or throw an error, much like C<require>.
  
  If C<Class::Name> is already loaded (checked with C<is_class_loaded>) then it
  will not try to load the class. This is useful when you have inner packages
  which C<require> does not check.
  
  The C<%options> hash currently accepts one key, C<-version>. If you specify a
  version, then this subroutine will call C<< Class::Name->VERSION(
  $options{-version} ) >> internally, which will throw an error if the class's
  version is not equal to or greater than the version you requested.
  
  =head2 try_load_class Class::Name, \%options -> (0|1, error message)
  
  Returns 1 if the class was loaded, 0 if it was not. If the class was not
  loaded, the error will be returned as a second return value in list context.
  
  Again, if C<Class::Name> is already loaded (checked with C<is_class_loaded>)
  then it will not try to load the class. This is useful when you have inner
  packages which C<require> does not check.
  
  Like C<load_class>, you can pass a C<-version> in C<%options>. If the version
  is not sufficient, then this subroutine will return false.
  
  =head2 is_class_loaded Class::Name, \%options -> 0|1
  
  This uses a number of heuristics to determine if the class C<Class::Name> is
  loaded. There heuristics were taken from L<Class::MOP>'s old pure-perl
  implementation.
  
  Like C<load_class>, you can pass a C<-version> in C<%options>. If the version
  is not sufficient, then this subroutine will return false.
  
  =head2 load_first_existing_class Class::Name, \%options, ...
  
  This attempts to load the first loadable class in the list of classes
  given. Each class name can be followed by an options hash reference.
  
  If any one of the classes loads and passes the optional version check, that
  class name will be returned. If I<none> of the classes can be loaded (or none
  pass their version check), then an error will be thrown.
  
  If, when attempting to load a class, it fails to load because of a syntax
  error, then an error will be thrown immediately.
  
  =head2 load_optional_class Class::Name, \%options -> 0|1
  
  C<load_optional_class> is a lot like C<try_load_class>, but also a lot like
  C<load_class>.
  
  If the class exists, and it works, then it will return 1. If you specify a
  version in C<%options>, then the version check must succeed or it will return
  0.
  
  If the class doesn't exist, and it appears to not exist on disk either, it
  will return 0.
  
  If the class exists on disk, but loading from disk results in an error
  ( i.e.: a syntax error ), then it will C<croak> with that error.
  
  This is useful for using if you want a fallback module system, i.e.:
  
      my $class = load_optional_class($foo) ? $foo : $default;
  
  That way, if $foo does exist, but can't be loaded due to error, you won't
  get the behaviour of it simply not existing.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<http://blog.fox.geek.nz/2010/11/searching-design-spec-for-ultimate.html>
  
  This blog post is a good overview of the current state of the existing modules
  for loading other modules in various ways.
  
  =item L<http://blog.fox.geek.nz/2010/11/handling-optional-requirements-with.html>
  
  This blog post describes how to handle optional modules with L<Class::Load>.
  
  =item L<http://d.hatena.ne.jp/tokuhirom/20110202/1296598578>
  
  This Japanese blog post describes why L<DBIx::Skinny> now uses L<Class::Load>
  over its competitors.
  
  =item L<Moose>, L<Jifty>, L<Prophet>, etc
  
  This module was designed to be used anywhere you have
  C<if (eval "require $module"; 1)>, which occurs in many large projects.
  
  =back
  
  =head1 AUTHOR
  
  Shawn M Moore <sartak at bestpractical.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Shawn M Moore.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
  
CLASS_LOAD

$fatpacked{"Class/Load/PP.pm"} = <<'CLASS_LOAD_PP';
  package Class::Load::PP;
  {
    $Class::Load::PP::VERSION = '0.13';
  }
  
  use strict;
  use warnings;
  use Module::Runtime 'is_module_name';
  use Package::Stash;
  use Scalar::Util 'blessed', 'reftype';
  use Try::Tiny;
  
  sub is_class_loaded {
      my $class   = shift;
      my $options = shift;
  
      my $loaded = _is_class_loaded($class);
  
      return $loaded if ! $loaded;
      return $loaded unless $options && $options->{-version};
  
      return try {
          $class->VERSION($options->{-version});
          1;
      }
      catch {
          0;
      };
  }
  
  sub _is_class_loaded {
      my $class = shift;
  
      return 0 unless is_module_name($class);
  
      my $stash = Package::Stash->new($class);
  
      if ($stash->has_symbol('$VERSION')) {
          my $version = ${ $stash->get_symbol('$VERSION') };
          if (defined $version) {
              return 1 if ! ref $version;
              # Sometimes $VERSION ends up as a reference to undef (weird)
              return 1 if ref $version && reftype $version eq 'SCALAR' && defined ${$version};
              # a version object
              return 1 if blessed $version;
          }
      }
  
      if ($stash->has_symbol('@ISA')) {
          return 1 if @{ $stash->get_symbol('@ISA') };
      }
  
      # check for any method
      return 1 if $stash->list_all_symbols('CODE');
  
      # fail
      return 0;
  }
  
  1;
CLASS_LOAD_PP

$fatpacked{"Config/IniFiles.pm"} = <<'CONFIG_INIFILES';
  package Config::IniFiles;
  
  use vars qw($VERSION);
  
  $VERSION = '2.70';
  
  require 5.004;
  use strict;
  use Carp;
  use Symbol 'gensym','qualify_to_ref';   # For the 'any data type' hack
  
  @Config::IniFiles::errors = ( );
  
  #   $Header: /home/shlomi/progs/perl/cpan/Config/IniFiles/config-inifiles-cvsbackup/config-inifiles/IniFiles.pm,v 2.41 2003-12-08 10:50:56 domq Exp $
  
  =head1 NAME
  
  Config::IniFiles - A module for reading .ini-style configuration files.
  
  =head1 SYNOPSIS
  
    use Config::IniFiles;
    my $cfg = Config::IniFiles->new( -file => "/path/configfile.ini" );
    print "The value is " . $cfg->val( 'Section', 'Parameter' ) . "."
      if $cfg->val( 'Section', 'Parameter' );
  
  =head1 DESCRIPTION
  
  Config::IniFiles provides a way to have readable configuration files outside
  your Perl script. Configurations can be imported (inherited, stacked,...), 
  sections can be grouped, and settings can be accessed from a tied hash.
  
  =head1 FILE FORMAT
  
  INI files consist of a number of sections, each preceded with the
  section name in square brackets, followed by parameter names and
  their values.
  
    [a section]
    Parameter=Value
  
    [section 2]
    AnotherParameter=Some value
    Setting=Something else
    Parameter=Different scope than the one in the first section
  
  The first non-blank character of the line indicating a section must 
  be a left bracket and the last non-blank character of a line indicating 
  a section must be a right bracket. The characters making up the section 
  name can be any symbols at all. However section names must be unique.
  
  Parameters are specified in each section as Name=Value.  Any spaces
  around the equals sign will be ignored, and the value extends to the
  end of the line (including any whitespace at the end of the line. 
  Parameter names are localized to the namespace of the section, but must 
  be unique within a section.
  
  Both the hash mark (#) and the semicolon (;) are comment characters.
  by default (this can be changed by configuration). Lines that begin with 
  either of these characters will be ignored. Any amount of whitespace may 
  precede the comment character.
  
  Multi-line or multi-valued parameters may also be defined ala UNIX 
  "here document" syntax:
  
    Parameter=<<EOT
    value/line 1
    value/line 2
    EOT
  
  You may use any string you want in place of "EOT". Note that whatever
  follows the "<<" and what appears at the end of the text MUST match
  exactly, including any trailing whitespace.
  
  Alternately, as a configuration option (default is off), continuation 
  lines can be allowed:
  
    [Section]
    Parameter=this parameter \
      spreads across \
      a few lines
  
  
  =head1 USAGE -- Object Interface
  
  Get a new Config::IniFiles object with the I<new> method:
  
    $cfg = Config::IniFiles->new( -file => "/path/config_file.ini" );
    $cfg = new Config::IniFiles -file => "/path/config_file.ini";
  
  Optional named parameters may be specified after the configuration
  file name. See the I<new> in the B<METHODS> section, below.
  
  Values from the config file are fetched with the val method:
  
    $value = $cfg->val('Section', 'Parameter');
  
  If you want a multi-line/value field returned as an array, just
  specify an array as the receiver:
  
    @values = $cfg->val('Section', 'Parameter');
  
  =head1 METHODS
  
  =head2 new ( [-option=>value ...] )
  
  Returns a new configuration object (or "undef" if the configuration
  file has an error, in which case check the global C<@Config::IniFiles::errors> 
  array for reasons why). One Config::IniFiles object is required per configuration
  file. The following named parameters are available:
  
  =over 10
  
  
  =item I<-file>  filename
  
  Specifies a file to load the parameters from. This 'file' may actually be 
  any of the following things:
  
    1) the pathname of a file
  
      $cfg = Config::IniFiles->new( -file => "/path/to/config_file.ini" );
  
    2) a simple filehandle
  
      $cfg = Config::IniFiles->new( -file => STDIN );
  
    3) a filehandle glob
  
      open( CONFIG, "/path/to/config_file.ini" );
      $cfg = Config::IniFiles->new( -file => *CONFIG );
  
    4) a reference to a glob
  
      open( CONFIG, "/path/to/config_file.ini" );
      $cfg = Config::IniFiles->new( -file => \*CONFIG );
  
    5) an IO::File object
  
      $io = IO::File->new( "/path/to/config_file.ini" );
      $cfg = Config::IniFiles->new( -file => $io );
  
    or
  
      open my $fh, '<', "/path/to/config_file.ini" or die $!;
      $cfg = Config::IniFiles->new( -file => $fh );
  
    6) A reference to a scalar (requires newer versions of IO::Scalar)
  
      $ini_file_contents = <<EOT
      [section name]
      Parameter=A value
      Setting=Another value
      EOT
      
      $cfg = Config::IniFiles->new( -file => \$ini_file_contents );
  
  
  If this option is not specified, (i.e. you are creating a config file from scratch) 
  you must specify a target file using L<SetFileName> in order to save the parameters.
  
  
  =item I<-default> section
  
  Specifies a section to be used for default values. For example, in the 
  following configuration file, if you look up the "permissions" parameter 
  in the "joe" section, there is none.
  
     [all]
     permissions=Nothing
          
     [jane]
     name=Jane
     permissions=Open files
  
     [joe]
     name=Joseph
  
  If you create your Config::IniFiles object with a default section of "all" like this:
  
     $cfg = Config::IniFiles->new( -file => "file.ini", -default => "all" );
     
  Then requsting a value for a "permissions" in the [joe] section will 
  check for a value from [all] before returning undef.
  
     $permissions = $cfg->val( "joe", "permissions");   // returns "Nothing"
  
  
  =item I<-fallback> section
  
  Specifies a section to be used for parameters outside a section. Default is none.
  Without -fallback specified (which is the default), reading a configuration file
  which has a parameter outside a section will fail. With this set to, say,
  "GENERAL", this configuration:
  
     wrong=wronger
  
     [joe]
     name=Joseph
  
  will be assumed as:
  
     [GENERAL]
     wrong=wronger
  
     [joe]
     name=Joseph
  
  Note that Config::IniFiles will also omit the fallback section header when
  outputing such configuration.
  
  =item I<-nocase> 0|1
  
  Set -nocase => 1 to handle the config file in a case-insensitive
  manner (case in values is preserved, however).  By default, config
  files are case-sensitive (i.e., a section named 'Test' is not the same
  as a section named 'test').  Note that there is an added overhead for
  turning off case sensitivity.
  
  
  =item I<-import> object
  
  This allows you to import or inherit existing setting from another 
  Config::IniFiles object. When importing settings from another object, 
  sections with the same name will be merged and parameters that are 
  defined in both the imported object and the I<-file> will take the 
  value of given in the I<-file>. 
  
  If a I<-default> section is also given on this call, and it does not 
  coincide with the default of the imported object, the new default 
  section will be used instead. If no I<-default> section is given, 
  then the default of the imported object will be used.
  
  
  =item I<-allowcontinue> 0|1
  
  Set -allowcontinue => 1 to enable continuation lines in the config file.
  i.e. if a line ends with a backslash C<\>, then the following line is
  appended to the parameter value, dropping the backslash and the newline
  character(s).
  
  Default behavior is to keep a trailing backslash C<\> as a parameter
  value. Note that continuation cannot be mixed with the "here" value
  syntax.
  
  
  =item I<-allowempty> 0|1
  
  If set to 1, then empty files are allowed at L</ReadConfig|ReadConfig()> 
  time. If set to 0 (the default), an empty configuration file is considered 
  an error.
  
  
  =item I<-negativedeltas> 0|1
  
  If set to 1 (the default if importing this object from another one),
  parses and honors lines of the following form in the configuration
  file:
  
    ; [somesection] is deleted
  
  or
  
    [inthissection]
    ; thisparameter is deleted
  
  If set to 0 (the default if not importing), these comments are treated
  like ordinary ones.
  
  The L</WriteConfig|WriteConfig(-delta=>1)> form will output such
  comments to indicate deleted sections or parameters. This way,
  reloading a delta file using the same imported object produces the
  same results in memory again. See L<IMPORT / DELTA FEATURES> for more
  details.
  
  =item I<-commentchar> 'char'
  
  The default comment character is C<#>. You may change this by specifying
  this option to another character. This can be any character except 
  alphanumeric characters, square brackets or the "equal" sign.
  
  
  =item I<-allowedcommentchars> 'chars'
  
  Allowed default comment characters are C<#> and C<;>. By specifying this
  option you may change the range of characters that are used to denote a
  comment line to include any set of characters
  
  Note: that the character specified by B<-commentchar> (see above) is 
  I<always> part of the allowed comment characters. 
  
  Note 2: The given string is evaluated as a regular expression character 
  class, so '\' must be escaped if you wish to use it.
  
  
  =item I<-reloadwarn> 0|1
  
  Set -reloadwarn => 1 to enable a warning message (output to STDERR)
  whenever the config file is reloaded.  The reload message is of the
  form:
  
    PID <PID> reloading config file <file> at YYYY.MM.DD HH:MM:SS
  
  Default behavior is to not warn (i.e. -reloadwarn => 0).
  
  This is generally only useful when using Config::IniFiles in a server 
  or daemon application. The application is still responsible for determining
  when the object is to be reloaded.
  
  
  =item I<-nomultiline> 0|1
  
  Set -nomultiline => 1 to output multi-valued parameter as:
  
   param=value1
   param=value2
  
  instead of the default:
  
   param=<<EOT
   value1
   value2
   EOT
  
  As the later might not be compatible with all applications.
  
  =item I<-handle_trailing_comment> 0|1
  
  Set -handle_trailing_comment => 1 to enable support of parameter trailing
  comments.
  
  For example, if we have a parameter line like this:
  
   param1=value1;comment1
  
  by default, handle_trailing_comment will be set to B<0>, and we will get
  I<value1;comment1> as the value of I<param1>. If we have 
  -handle_trailing_comment set to B<1>, then we will get I<value1> 
  as the value for I<param1>, and I<comment1> as the trailing comment of 
  I<param1>. 
  
  Set and get methods for trailing comments are provided as
  L</SetParameterTrailingComment> and L</GetParameterTrailingComment>.
  
  =back
  
  =cut
  
  sub _nocase
  {
      my $self = shift;
  
      if (@_)
      {
          $self->{nocase} = (shift(@_) ? 1 : 0);
      }
  
      return $self->{nocase};
  }
  
  sub new {
    my $class = shift;
    my %parms = @_;
  
    my $errs = 0;
    my @groups = ( );
  
    my $self = bless {
      default => '',
      fallback =>undef,
      fallback_used => 0,
      imported =>undef,
      v =>{},
      cf => undef,
      firstload => 1,
      nomultiline => 0,
      handle_trailing_comment => 0,
    }, $class;
  
    if( ref($parms{-import}) && ($parms{-import}->isa('Config::IniFiles')) ) {
      $self->{imported}=$parms{-import}; # ReadConfig will load the data
      $self->{negativedeltas}=1;
    } elsif( defined $parms{-import} ) {
      carp "Invalid -import value \"$parms{-import}\" was ignored.";
    } # end if
    delete $parms{-import};
  
    # Copy the original parameters so we 
    # can use them when we build new sections 
    %{$self->{startup_settings}} = %parms;
  
    # Parse options
    my($k, $v);
    local $_;
    $self->_nocase(0);
  
    # Handle known parameters first in this order, 
    # because each() could return parameters in any order
    if (defined ($v = delete $parms{'-file'})) {
      # Should we be pedantic and check that the file exists?
      # .. no, because now it could be a handle, IO:: object or something else
      $self->{cf} = $v;
    }
    if (defined ($v = delete $parms{'-nocase'})) {
      $self->_nocase($v);
    }  
    if (defined ($v = delete $parms{'-default'})) {
      $self->{default} = $self->_nocase ? lc($v) : $v;
    }
    if (defined ($v = delete $parms{'-fallback'})) {
      $self->{fallback} = $self->_nocase ? lc($v) : $v;
    }
    if (defined ($v = delete $parms{'-reloadwarn'})) {
      $self->{reloadwarn} = $v ? 1 : 0;
    }
    if (defined ($v = delete $parms{'-nomultiline'})) {
      $self->{nomultiline} = $v ? 1 : 0;
    }
    if (defined ($v = delete $parms{'-allowcontinue'})) {
      $self->{allowcontinue} = $v ? 1 : 0;
    }
    if (defined ($v = delete $parms{'-allowempty'})) {
       $self->{allowempty} = $v ? 1 : 0;
    }
    if (defined ($v = delete $parms{'-negativedeltas'})) {
        $self->{negativedeltas} = $v ? 1 : 0;
    }
    if (defined ($v = delete $parms{'-commentchar'})) {
      if(!defined $v || length($v) != 1) {
        carp "Comment character must be unique.";
        $errs++;
      }
      elsif($v =~ /[\[\]=\w]/) {
        # must not be square bracket, equal sign or alphanumeric
        carp "Illegal comment character.";
        $errs++;
      } 
      else {
        $self->{comment_char} = $v;
      }
    }
    if (defined ($v = delete $parms{'-allowedcommentchars'})) {
      # must not be square bracket, equal sign or alphanumeric
      if(!defined $v || $v =~ /[\[\]=\w]/) {
        carp "Illegal value for -allowedcommentchars.";
        $errs++;
      }
      else {
        $self->{allowed_comment_char} = $v;
      }
    }
  
    if (defined ($v = delete $parms{'-handle_trailing_comment'})) {
        $self->{handle_trailing_comment} = $v ? 1 : 0;
    }
  
    $self->{comment_char} = '#' unless exists $self->{comment_char};
    $self->{allowed_comment_char} = ';' unless exists $self->{allowed_comment_char};
    # make sure that comment character is always allowed
    $self->{allowed_comment_char} .= $self->{comment_char};
  
    $self->{_comments_at_end_of_file} = [];
  
    # Any other parameters are unkown
    while (($k, $v) = each %parms) {
      carp "Unknown named parameter $k=>$v";
      $errs++;
    }
  
    return undef if $errs;
    
    if ($self->ReadConfig) {
      return $self;
    } else {
      return undef;
    }
  }
  
  
  =head2 val ($section, $parameter [, $default] )
  
  Returns the value of the specified parameter (C<$parameter>) in section 
  C<$section>, returns undef (or C<$default> if specified) if no section or 
  no parameter for the given section exists.
  
  
  If you want a multi-line/value field returned as an array, just
  specify an array as the receiver:
  
    @values = $cfg->val('Section', 'Parameter');
  
  A multi-line/value field that is returned in a scalar context will be
  joined using $/ (input record separator, default is \n) if defined,
  otherwise the values will be joined using \n.
  
  =cut
  
  sub _caseify {
      my ($self, @refs) = @_;
  
      if (not $self->_nocase)
      {
          return;
      }
  
      foreach my $ref (@refs) {
          ${$ref} = lc(${$ref})
      }
  
      return;
  }
  
  sub val {
    my ($self, $sect, $parm, $def) = @_;
  
    # Always return undef on bad parameters
    return if not defined $sect;
    return if not defined $parm;
   
    $self->_caseify(\$sect, \$parm);
  
    my $val = defined($self->{v}{$sect}{$parm}) ?
      $self->{v}{$sect}{$parm} :
      $self->{v}{$self->{default}}{$parm};
    
    # If the value is undef, make it $def instead (which could just be undef)
    $val = $def unless defined $val;
    
    # Return the value in the desired context
    if (wantarray) {
      if (ref($val) eq "ARRAY") {
        return @$val;
      } elsif (defined($val)) {
        return $val;
      } else {
        return;
      }
    } elsif (ref($val) eq "ARRAY") {
      if (defined ($/)) {
          return join "$/", @$val;
      } else {
          return join "\n", @$val;
      }
    } else {
      return $val;
    }
  }
  
  
  
  =head2 exists($section, $parameter)
  
  True if and only if there exists a section C<$section>, with 
  a parameter C<$parameter> inside, not counting default values.
  
  =cut
  
  sub exists {
      my ($self, $sect, $parm) = @_;
  
      $self->_caseify(\$sect, \$parm);
  
      return (exists $self->{v}{$sect}{$parm});
  }
  
  
  
  =head2 push ($section, $parameter, $value, [ $value2, ...])
  
  Pushes new values at the end of existing value(s) of parameter
  C<$parameter> in section C<$section>.  See below for methods to write
  the new configuration back out to a file.
  
  You may not set a parameter that didn't exist in the original
  configuration file.  B<push> will return I<undef> if this is
  attempted. See B<newval> below to do this. Otherwise, it returns 1.
  
  =cut
  
  sub push {
    my ($self, $sect, $parm, @vals) = @_;
  
    return undef if not defined $sect;
    return undef if not defined $parm;
  
    $self->_caseify(\$sect, \$parm);
  
    return undef if (! defined($self->{v}{$sect}{$parm}));
  
    return 1 if (! @vals);
  
    $self->_touch_parameter($sect, $parm);
  
    $self->{EOT}{$sect}{$parm} = 'EOT' if
      (!defined $self->{EOT}{$sect}{$parm});
  
    $self->{v}{$sect}{$parm} = [$self->{v}{$sect}{$parm}] unless
       (ref($self->{v}{$sect}{$parm}) eq "ARRAY");
  
    CORE::push @{$self->{v}{$sect}{$parm}}, @vals;
    return 1;
  }
  
  =head2 setval ($section, $parameter, $value, [ $value2, ... ])
  
  Sets the value of parameter C<$parameter> in section C<$section> to 
  C<$value> (or to a set of values).  See below for methods to write 
  the new configuration back out to a file.
  
  You may not set a parameter that didn't exist in the original
  configuration file.  B<setval> will return I<undef> if this is
  attempted. See B<newval> below to do this. Otherwise, it returns 1.
  
  =cut
  
  sub setval {
    my $self = shift;
    my $sect = shift;
    my $parm = shift;
    my @val  = @_;
  
    return undef if not defined $sect;
    return undef if not defined $parm;
  
    $self->_caseify(\$sect, \$parm);
  
    if (defined($self->{v}{$sect}{$parm})) {
      $self->_touch_parameter($sect, $parm);
      if (@val > 1) {
        $self->{v}{$sect}{$parm} = \@val;
        $self->{EOT}{$sect}{$parm} = 'EOT';
      } else {
        $self->{v}{$sect}{$parm} = shift @val;
      }
      return 1;
    } else {
      return undef;
    }
  }
  
  =head2 newval($section, $parameter, $value [, $value2, ...])
  
  Assignes a new value, C<$value> (or set of values) to the 
  parameter C<$parameter> in section C<$section> in the configuration 
  file.
  
  =cut
  
  sub newval {
    my $self = shift;
    my $sect = shift;
    my $parm = shift;
    my @val  = @_;
    
    return undef if not defined $sect;
    return undef if not defined $parm;
  
    $self->_caseify(\$sect, \$parm);
  
    $self->AddSection($sect);
  
    CORE::push(@{$self->{parms}{$sect}}, $parm) 
        unless (grep {/^\Q$parm\E$/} @{$self->{parms}{$sect}} );
  
    $self->_touch_parameter($sect, $parm);
    if (@val > 1) {
      $self->{v}{$sect}{$parm} = \@val;
      $self->{EOT}{$sect}{$parm} = 'EOT' unless defined $self->{EOT}{$sect}{$parm};
    } else {
      $self->{v}{$sect}{$parm} = shift @val;
    }
    return 1
  }
  
  =head2 delval($section, $parameter)
  
  Deletes the specified parameter from the configuration file
  
  =cut
  
  sub delval {
    my $self = shift;
    my $sect = shift;
    my $parm = shift;
    
    return undef if not defined $sect;
    return undef if not defined $parm;
  
    $self->_caseify(\$sect, \$parm);
  
    @{$self->{parms}{$sect}} = grep !/^\Q$parm\E$/, @{$self->{parms}{$sect}};
    $self->_touch_parameter($sect, $parm);
    delete $self->{v}{$sect}{$parm};
    return 1
  }
  
  =head2 ReadConfig
  
  Forces the configuration file to be re-read. Returns undef if the 
  file can not be opened, no filename was defined (with the C<-file>
  option) when the object was constructed, or an error occurred while 
  reading.
  
  If an error occurs while parsing the INI file the @Config::IniFiles::errors
  array will contain messages that might help you figure out where the 
  problem is in the file.
  
  =cut
  
  # Auxillary function to make deep (aliasing-free) copies of data
  # structures.  Ignores blessed objects in tree (could be taught not
  # to, if needed)
  sub _deepcopy {
    my $ref=shift;
  
    if (! ref($ref)) { return $ref; }
  
    local $_;
  
    if (UNIVERSAL::isa($ref, "ARRAY")) {
            return [map {_deepcopy($_)} @$ref];
    }
  
    if (UNIVERSAL::isa($ref, "HASH")) {
            my $return={};
            foreach my $k (keys %$ref) {
                    $return->{$k}=_deepcopy($ref->{$k});
            }
            return $return;
    }
  
    carp "Unhandled data structure in $ref, cannot _deepcopy()";
  }
  
  # Internal method, gets the next line, taking proper care of line endings.
  sub _nextline {
      my ($self, $fh)=@_;
      local $_;
      if (!exists $self->{line_ends}) {
          # no $self->{line_ends} is a hint set by caller that we are at
          # the first line (kludge kludge).
          {
              local $/=\1;
              my $nextchar;
              do {
                  $nextchar=<$fh>;
                  return undef if (!defined $nextchar);
                  $_ .= $nextchar;
              } until (m/((\015|\012|\025|\n)$)/s);
              $self->{line_ends}=$1;
              if ($nextchar eq "\x0d") {
                  # peek at the next char
                  $nextchar = <$fh>;
                  if ($nextchar eq "\x0a") {
                      $self->{line_ends} .= "\x0a";
                  } else {
                      seek $fh, -1, 1;
                  }
              }
          }
  
          # If there's a UTF BOM (Byte-Order-Mark) in the first
          # character of the first line then remove it before processing
          # (http://www.unicode.org/unicode/faq/utf_bom.html#22)
          s/^ï»¿//;
  
          return $_;
      } else {
          local $/=$self->{line_ends};
          return scalar <$fh>;
      }
  }
  
  # Internal method, closes or resets the file handle. To be called
  # whenever ReadConfig() returns.
  sub _rollback {
      my ($self, $fh)=@_;
    # Only close if this is a filename, if it's
    # an open handle, then just roll back to the start
    if( !ref($self->{cf}) ) {
      close($fh);
    } else {
      # Attempt to rollback to beginning, no problem if this fails (e.g. STDIN)
      seek( $fh, 0, 0 );
    } # end if
  }
  
  
  sub ReadConfig {
    my $self = shift;
  
    my($lineno, $sect);
    my($group, $groupmem);
    my($parm, $val);
    my @cmts;
    my $end_comment;
  
    @Config::IniFiles::errors = ( );
  
    # Initialize (and clear out) storage hashes
    $self->{sects}  = [];
    $self->{parms}  = {};
    $self->{group}  = {};
    $self->{v}      = {};
    $self->{sCMT}   = {};
    $self->{pCMT}   = {};
    $self->{EOT}    = {};
    $self->{mysects} = []; # A pair of hashes to remember which params are loaded
    $self->{myparms} = {}; # or set using the API vs. imported - useful for
    $self->{peCMT}  = {};  # this will store trailing comments at the end of single-lined params
    # import shadowing, see below, and WriteConfig(-delta=>1)
  
    if( defined $self->{imported} ) {
        # Run up the import tree to the top, then reload coming
        # back down, maintaining the imported file names and our 
        # file name.
        # This is only needed on a re-load though
        $self->{imported}->ReadConfig() unless ($self->{firstload});
  
        foreach my $field (qw(sects parms group v sCMT pCMT EOT)) {
            $self->{$field} = _deepcopy($self->{imported}->{$field});
        }
    } # end if
    
    if (    (not exists $self->{cf})
         or (not defined $self->{cf})
         or ($self->{cf} eq '')
    )
    {
        return 1;
    }
    
    my $nocase = $self->_nocase;
    my $end_commenthandle = $self->{handle_trailing_comment};
  
    # If this is a reload and we want warnings then send one to the STDERR log
    unless( $self->{firstload} || !$self->{reloadwarn} ) {
      my ($ss, $mm, $hh, $DD, $MM, $YY) = (localtime(time))[0..5];
      printf STDERR
        "PID %d reloading config file %s at %d.%02d.%02d %02d:%02d:%02d\n",
        $$, $self->{cf}, $YY+1900, $MM+1, $DD, $hh, $mm, $ss;
    }
    
    # Turn off. Future loads are reloads
    $self->{firstload} = 0;
  
    # Get a filehandle, allowing almost any type of 'file' parameter
    my $fh = $self->_make_filehandle( $self->{cf} );
    if (!$fh) {
      carp "Failed to open $self->{cf}: $!";
      return undef;
    }
    
    # Get mod time of file so we can retain it (if not from STDIN)
    # also check if it's a real file (could have been a filehandle made from a scalar).
    if (ref($fh) ne "IO::Scalar" && -e $fh)
    {
      my @stats = stat $fh;
      $self->{file_mode} = sprintf("%04o", $stats[2]) if defined $stats[2];
    }
    
    
    # The first lines of the file must be blank, comments or start with [
    my $first = '';
    my $allCmt = $self->{allowed_comment_char};
    
    local $_;
    delete $self->{line_ends}; # Marks start of parsing for _nextline()
    while ( defined($_ = $self->_nextline($fh)) ) {
      s/(\015\012?|\012|\025|\n)$//;              # remove line ending char(s)
      $lineno++;
      if (/^\s*$/) {              # ignore blank lines
        next;
      }
      elsif (/^\s*[$allCmt]/) {           # collect comments
          if ($self->{negativedeltas} &&
              m/^$self->{comment_char} (.*) is deleted$/) {
              my $todelete=$1;
              if ($todelete =~ m/^\[(.*)\]$/) {
                  $self->DeleteSection($1);
              } else {
                  $self->delval($sect, $todelete);
              }
          } else {
              CORE::push(@cmts, $_);
          }
          next;
      }
      elsif (/^\s*\[\s*(\S|\S.*\S)\s*\]\s*$/) {       # New Section
        $sect = $1;
        $self->_caseify(\$sect);
        $self->AddSection($sect);
        $self->SetSectionComment($sect, @cmts);
        @cmts = ();
      }
      elsif (($parm, $val) = /^\s*([^=]*?[^=\s])\s*=\s*(.*)$/) {  # new parameter
          if ((!defined($sect)) and defined($self->{fallback}))
          { 
              $sect = $self->{fallback};
              $self->{fallback_used}++;
          }
          if (!defined $sect) {
              CORE::push(@Config::IniFiles::errors, sprintf('%d: %s', $lineno,
                  qq#parameter found outside a section#));
              $self->_rollback($fh);
              return undef;
          }
  
        $parm = lc($parm) if $nocase;
        my @val = ( );
        my $eotmark;
        if ($val =~ /^<<(.*)$/) {         # "here" value
         $eotmark  = $1;
      my $foundeot = 0;
      my $startline = $lineno;
      while ( defined($_=$self->_nextline($fh)) ) {
        s/(\015\012?|\012|\025|\n)$//;                # remove line ending char(s)
        $lineno++;
        if ($_ eq $eotmark) {
          $foundeot = 1;
          last;
        } else {
          # Untaint
          /(.*)/ms; 
          CORE::push(@val, $1);
        }
      }
      if (! $foundeot) {
        CORE::push(@Config::IniFiles::errors, sprintf('%d: %s', $startline,
                    qq#no end marker ("$eotmark") found#));
        $self->_rollback();
        return undef;
      }
        } else { # no here value
  
          # process continuation lines, if any
          while($self->{allowcontinue} && $val =~ s/\\$//) {
            $_ = $self->_nextline($fh);
        s/(\015\012?|\012|\025|\n)$//; # remove line ending char(s)
        $lineno++;
            $val .= $_;
          }
  
          # we should split value and comments if there is any comment
          if ($end_commenthandle &&
              $val =~ /(.*?)\s*[$allCmt]\s*([^$allCmt]*)$/) {
              $val = $1;
              $end_comment = $2;
          } else {
              $end_comment = "";
          }
  
          @val = $val;
        }
          # Now load value
          if (exists $self->{v}{$sect}{$parm} && 
              exists $self->{myparms}{$sect} && 
              grep( /^\Q$parm\E$/, @{$self->{myparms}{$sect}}) ) {
              $self->push($sect, $parm, @val);
          } else {
              # Loaded parameters shadow imported ones, instead of appending
              # to them
              $self->newval($sect, $parm, @val);
          }
          $self->SetParameterComment($sect, $parm, @cmts);
          @cmts = ( );
          $self->SetParameterEOT($sect,$parm,$eotmark) if (defined $eotmark);
          # if handle_trailing_comment is off, this line makes no sense, since all $end_comment=""
          $self->SetParameterTrailingComment($sect, $parm, $end_comment);
  
      } else {
        CORE::push(@Config::IniFiles::errors, sprintf("Line \%d in file " . $self->{cf} . " is mal-formed:\n\t\%s", $lineno, $_));
      }
    } # End main parsing loop
  
    # Special case: return undef if file is empty. (suppress this line to
    # restore the more intuitive behaviour of accepting empty files)
    if (! keys %{$self->{v}} && ! $self->{allowempty}) {
        CORE::push @Config::IniFiles::errors, "Empty file treated as error";
        $self->_rollback($fh);
        return undef;
    }
  
    if( defined (my $defaultsect=$self->{startup_settings}->{-default}) ) {
        $self->AddSection($defaultsect);
    } # end if
  
    $self->_SetEndComments(@cmts);
  
    $self->_rollback($fh);
    @Config::IniFiles::errors ? undef : 1;
  }
  
  
  =head2 Sections
  
  Returns an array containing section names in the configuration file.
  If the I<nocase> option was turned on when the config object was
  created, the section names will be returned in lowercase.
  
  =cut
  
  sub Sections {
    my $self = shift;
    return @{$self->{sects}} if ref $self->{sects} eq 'ARRAY';
    return ();
  }
  
  =head2 SectionExists ( $sect_name )
  
  Returns 1 if the specified section exists in the INI file, 0 otherwise (undefined if section_name is not defined).
  
  =cut
  
  sub SectionExists {
      my $self = shift;
      my $sect = shift;
      
      return undef if not defined $sect;
      
      $self->_caseify(\$sect);
  
      return undef() if not defined $sect;
      return 1 if (grep {/^\Q$sect\E$/} @{$self->{sects}});
      return 0;
  }
  
  =head2 AddSection ( $sect_name )
  
  Ensures that the named section exists in the INI file. If the section already
  exists, nothing is done. In this case, the "new" section will possibly contain
  data already.
  
  If you really need to have a new section with no parameters in it, check that
  the name that you're adding isn't in the list of sections already.
  
  =cut
  
  sub AddSection {
      my ($self, $sect) = @_;
      
      return undef if not defined $sect;
  
      $self->_caseify(\$sect);
  
      return if $self->SectionExists($sect);
      CORE::push @{$self->{sects}}, $sect unless
        grep /^\Q$sect\E$/, @{$self->{sects}};
      $self->_touch_section($sect);
  
      $self->SetGroupMember($sect);
      
      # Set up the parameter names and values lists
      $self->{parms}{$sect} = [] unless ref $self->{parms}{$sect} eq 'ARRAY';
      if (!defined($self->{v}{$sect})) {
          $self->{sCMT}{$sect} = [];
          $self->{pCMT}{$sect} = {};      # Comments above parameters
          $self->{parms}{$sect} = [];
          $self->{v}{$sect} = {};
      }
  }
  
  # Marks a section as modified by us (this includes deleted by us).
  sub _touch_section {
      my ($self, $sect)=@_;
  
      $self->{mysects} ||= [];
      CORE::push @{$self->{mysects}}, $sect unless
        grep /^\Q$sect\E$/, @{$self->{mysects}};
  }
  
  # Marks a parameter as modified by us (this includes deleted by us).
  sub _touch_parameter {
      my ($self, $sect, $parm)=@_;
  
      $self->_touch_section($sect);
      return if (!exists $self->{v}{$sect});
      $self->{myparms}{$sect} ||= [];
      CORE::push @{$self->{myparms}{$sect}}, $parm unless
        grep /^\Q$parm\E$/, @{$self->{myparms}{$sect}};
  }
  
  
  =head2 DeleteSection ( $sect_name )
  
  Completely removes the entire section from the configuration.
  
  =cut
  
  sub DeleteSection {
      my $self = shift;
      my $sect = shift;
      
      return undef if not defined $sect;
      
      $self->_caseify(\$sect);
  
      # This is done the fast way, change if data structure changes!!
      delete $self->{v}{$sect};
      delete $self->{sCMT}{$sect};
      delete $self->{pCMT}{$sect};
      delete $self->{EOT}{$sect};
      delete $self->{parms}{$sect};
      delete $self->{myparms}{$sect};
  
      @{$self->{sects}} = grep !/^\Q$sect\E$/, @{$self->{sects}};
      $self->_touch_section($sect);
  
      if( $sect =~ /^(\S+)\s+\S+/ ) {
          my $group = $1;
          if( defined($self->{group}{$group}) ) {
              @{$self->{group}{$group}} = grep !/^\Q$sect\E$/, @{$self->{group}{$group}};
          } # end if
      } # end if
  
      return 1;
  } # end DeleteSection
  
  =head2 Parameters ($sect_name)
  
  Returns an array containing the parameters contained in the specified
  section.
  
  =cut
  
  sub Parameters {
    my $self = shift;
    my $sect = shift;
    
    return undef if not defined $sect;
    
    $self->_caseify(\$sect);
  
    return @{$self->{parms}{$sect}} if ref $self->{parms}{$sect} eq 'ARRAY';
    return ();
  }
  
  =head2 Groups
  
  Returns an array containing the names of available groups.
    
  Groups are specified in the config file as new sections of the form
  
    [GroupName MemberName]
  
  This is useful for building up lists.  Note that parameters within a
  "member" section are referenced normally (i.e., the section name is
  still "Groupname Membername", including the space) - the concept of
  Groups is to aid people building more complex configuration files.
  
  =cut
  
  sub Groups  {
    my $self = shift;
    return keys %{$self->{group}} if ref $self->{group} eq 'HASH';
    return ();
  }
  
  =head2 SetGroupMember ( $sect )
  
  Makes sure that the specified section is a member of the appropriate group.
  
  Only intended for use in newval.
  
  =cut
  
  sub SetGroupMember {
      my $self = shift;
      my $sect = shift;
      
      return undef if not defined $sect;
      
      return(1) unless $sect =~ /^(\S+)\s+\S+/;
      
      my $group = $1;
      if (not exists($self->{group}{$group})) {
          $self->{group}{$group} = [];
      }
      if (not grep {/^\Q$sect\E$/} @{$self->{group}{$group}}) {
          CORE::push @{$self->{group}{$group}}, $sect;
      }
  }
  
  =head2 RemoveGroupMember ( $sect )
  
  Makes sure that the specified section is no longer a member of the
  appropriate group. Only intended for use in DeleteSection.
  
  =cut
  
  sub RemoveGroupMember {
      my $self = shift;
      my $sect = shift;
      
      return undef if not defined $sect;
      
      return(1) unless $sect =~ /^(\S+)\s+\S+/;
      
      my $group = $1;
      return unless exists $self->{group}{$group};
      @{$self->{group}{$group}} = grep {!/^\Q$sect\E$/} @{$self->{group}{$group}};
  }
  
  =head2 GroupMembers ($group)
  
  Returns an array containing the members of specified $group. Each element
  of the array is a section name. For example, given the sections
  
    [Group Element 1]
    ...
  
    [Group Element 2]
    ...
  
  GroupMembers would return ("Group Element 1", "Group Element 2").
  
  =cut
  
  sub GroupMembers {
    my $self  = shift;
    my $group = shift;
    
    return undef if not defined $group;
    
    $self->_caseify(\$group);
  
    return @{$self->{group}{$group}} if ref $self->{group}{$group} eq 'ARRAY';
    return ();
  }
  
  =head2 SetWriteMode ($mode)
  
  Sets the mode (permissions) to use when writing the INI file.
  
  $mode must be a string representation of the octal mode.
  
  =cut
  
  sub SetWriteMode
  {
      my $self = shift;
      my $mode = shift;
      return undef if not defined ($mode);
      return undef if not ($mode =~ m/[0-7]{3,3}/);
      $self->{file_mode} = $mode;
      return $mode;
  }
  
  =head2 GetWriteMode ($mode)
  
  Gets the current mode (permissions) to use when writing the INI file.
  
  $mode is a string representation of the octal mode.
  
  =cut
  
  sub GetWriteMode
  {
      my $self = shift;
      return undef if not exists $self->{file_mode};
      return $self->{file_mode};
  }
  
  =head2 WriteConfig ($filename [, %options])
  
  Writes out a new copy of the configuration file.  A temporary file
  (ending in '-new') is written out and then renamed to the specified
  filename.  Also see B<BUGS> below.
  
  If C<-delta> is set to a true value in %options, and this object was
  imported from another (see L</new>), only the differences between this
  object and the imported one will be recorded. Negative deltas will be
  encoded into comments, so that a subsequent invocation of I<new()>
  with the same imported object produces the same results (see the
  I<-negativedeltas> option in L</new>).
  
  C<%options> is not required.
  
  Returns true on success, C<undef> on failure.
  
  =cut
  
  sub WriteConfig {
    my ($self, $file, %parms) = @_;
    
    return undef unless defined $file;
    
    
    # If we are using a filename, then do mode checks and write to a 
    # temporary file to avoid a race condition
    if( !ref($file) ) {
      if (-e $file) {
            if (not (-w $file))
            {
                    #carp "File $file is not writable.  Refusing to write config";
                    return undef;
            }
            my $mode = (stat $file)[2];
            $self->{file_mode} = sprintf "%04o", ($mode & 0777);
            #carp "Using mode $self->{file_mode} for file $file";
      } elsif (defined($self->{file_mode}) and not (oct($self->{file_mode}) & 0222)) {
            #carp "Store mode $self->{file_mode} prohibits writing config";
      }
    
      my $new_file = $file . "-new";
      open(my $fh, '>', $new_file) || do {
        carp "Unable to write temp config file $new_file: $!";
        return undef;
      };
      $self->OutputConfigToFileHandle($fh, $parms{-delta});
      close($fh);
      if (!rename( $new_file, $file )) {
        carp "Unable to rename temp config file ($new_file) to $file: $!";
        return undef;
      }
      if (exists $self->{file_mode}) {
        chmod oct($self->{file_mode}), $file;
      }
    
    } # Otherwise, reset to the start of the file and write, unless we are using STDIN
    else {
      # Get a filehandle, allowing almost any type of 'file' parameter
      ## NB: If this were a filename, this would fail because _make_file 
      ##     opens a read-only handle, but we have already checked that case
      ##     so re-using the logic is ok [JW/WADG]
      my $fh = $self->_make_filehandle( $file );
      if (!$fh) {
        carp "Could not find a filehandle for the input stream ($file): $!";
        return undef;
      }
      
      
      # Only roll back if it's not STDIN (if it is, Carp)
      if( $fh == \*STDIN ) {
        carp "Cannot write configuration file to STDIN.";
      } else {
        seek( $fh, 0, 0 );
        $self->OutputConfigToFileHandle($fh, $parms{-delta});
        seek( $fh, 0, 0 );
      } # end if
  
    } # end if (filehandle/name)
    
    return 1;
    
  }
  
  =head2 RewriteConfig
  
  Same as WriteConfig, but specifies that the original configuration
  file should be rewritten.
  
  =cut
  
  sub RewriteConfig {
    my $self = shift;
    
    return undef if (
      (not exists $self->{cf}) or
      (not defined $self->{cf}) or
      ($self->{cf} eq '')
    );
    
    # Return whatever WriteConfig returns :)
    $self->WriteConfig($self->{cf});
  }
  
  =head2 GetFileName
  
  Returns the filename associated with this INI file.
  
  If no filename has been specified, returns undef.
  
  =cut
  
  sub GetFileName
  {
      my $self = shift;
      my $filename;
      if (exists $self->{cf}) {
          $filename = $self->{cf};
      } else {
          undef $filename;
      }
      return $filename;
  }
  
  =head2 SetFileName ($filename)
  
  If you created the Config::IniFiles object without initialising from
  a file, or if you just want to change the name of the file to use for
  ReadConfig/RewriteConfig from now on, use this method.
  
  Returns $filename if that was a valid name, undef otherwise.
  
  =cut
  
  sub SetFileName {
    my $self = shift;
    my $newfile = shift;
    
    return undef if not defined $newfile;
    
    if ($newfile ne "") {
      $self->{cf} = $newfile;
      return $self->{cf};
    }
    return undef;
  }
  
  =head2 $ini->OutputConfigToFileHandle($fh, $delta)
  
  Writes OutputConfig to the $fh filehandle. $delta should be set to 1
  1 if writing only delta. This is a newer and safer version of 
  C<OutputConfig()> and one is encouraged to use it instead.
  
  =head2 $ini->OutputConfig($delta)
  
  Writes OutputConfig to STDOUT. Use select() to redirect STDOUT to
  the output target before calling this function. Optional argument
  should be set to 1 if writing only delta. Also see OutputConfigToFileHandle
  
  =cut
  
  sub _OutputParam {
      my ($self, $sect, $parm, $val, $ors, $end_comment, $output_cb) = @_;
  
      if (! @$val) {
          # An empty variable - see:
          # https://rt.cpan.org/Public/Bug/Display.html?id=68554
          $output_cb->("$parm=");
          $output_cb->("$ors");
      }
      elsif ((@$val == 1) or $self->{nomultiline}) {
          my $cnt = 0;
          foreach (@{$val}) {
              $cnt++;
              $output_cb->("$parm=$_");
              # output trailing comment at the last parameter
              if ($end_comment && $cnt == @$val) {
                  $output_cb->(" $self->{comment_char} $end_comment") 
              }
              $output_cb->("$ors");
          }
      }
      else
      {
          my $eotmark = $self->{EOT}{$sect}{$parm} || 'EOT';
  
          # Make sure the $eotmark does not occur inside the string.
          my @letters = ('A' .. 'Z');
          my $joined_val = join(q{ }, @$val);
          while (index($joined_val, $eotmark) >= 0)
          {
              $eotmark .= $letters[rand(@letters)];
          }
  
          $output_cb->("$parm= <<$eotmark$ors");
          my $cnt = 0;
          foreach (@{$val}) {
              $cnt++;
              $output_cb->("$_");
              # output trailing comment at the last parameter
              if ($end_comment && $cnt == @$val) {
                  $output_cb->(" $self->{comment_char} $end_comment")
              }
              $output_cb->("$ors");
          }
          $output_cb->("$eotmark$ors");
      }
  
      return;
  }
  
  sub OutputConfig {
      my ($self, $delta) = @_;
  
      return $self->OutputConfigToFileHandle(select(), $delta);
  }
  
  sub OutputConfigToFileHandle {
      # We need no strict 'refs' to be able to print to $fh if it points
      # to a glob filehandle.
      no strict 'refs';
      my ($self, $fh, $delta) = @_;
  
      my($sect, $parm, @cmts);
      my $ors = $self->{line_ends} || $\ || "\n"; # $\ is normally unset, but use input by default
      my $notfirst = 0;
      local $_;
      SECT:
      foreach $sect (@{$self->{$delta ? "mysects" : "sects"}}) {
          if (!defined $self->{v}{$sect}) {
              if ($delta) {
                  print {$fh} "$self->{comment_char} [$sect] is deleted$ors";
              } else {
                  warn "Weird unknown section $sect" if $^W;
              }
              next SECT;
          }
          next unless defined $self->{v}{$sect};
          print {$fh} $ors if $notfirst;
          $notfirst = 1;
          if ((ref($self->{sCMT}{$sect}) eq 'ARRAY') &&
              (@cmts = @{$self->{sCMT}{$sect}})) {
              foreach (@cmts) {
                  print {$fh} "$_$ors";
              }
          }
  
          if (!
              ($self->{fallback_used} and $sect eq $self->{fallback})
          )
          {
              print {$fh} "[$sect]$ors";
          }
          next unless ref $self->{v}{$sect} eq 'HASH';
  
          PARM:
          foreach $parm (@{$self->{$delta ? "myparms" : "parms"}{$sect}}) {
              if (!defined $self->{v}{$sect}{$parm}) {
                  if ($delta) {
                      print {$fh} "$self->{comment_char} $parm is deleted$ors";
                  } else {
                      warn "Weird unknown parameter $parm" if $^W;
                  }
                  next PARM;
              }
              if ((ref($self->{pCMT}{$sect}{$parm}) eq 'ARRAY') &&
                  (@cmts = @{$self->{pCMT}{$sect}{$parm}})) {
                  foreach (@cmts) {
                      print {$fh} "$_$ors";
                  }
              }
  
              my $val = $self->{v}{$sect}{$parm};
              my $end_comment = $self->{peCMT}{$sect}{$parm};
  
              next if ! defined ($val); # No parameter exists !!
  
              $self->_OutputParam(
                  $sect,
                  $parm, 
                  ((ref($val) eq 'ARRAY')
                      ? $val
                      : [split /[$ors]/, $val, -1]
                  ),
                  $ors,
                  defined $end_comment ? $end_comment : "",
                  sub { print {$fh} @_; },
              );
          }
      }
      foreach my $comment ($self->_GetEndComments()) {
          print {$fh} "$comment$ors";
      }
      return 1;
  }
  
  =head2 SetSectionComment($section, @comment)
  
  Sets the comment for section $section to the lines contained in @comment.
  
  Each comment line will be prepended with the comment character (default
  is C<#>) if it doesn't already have a comment character (ie: if the
  line does not start with whitespace followed by an allowed comment
  character, default is C<#> and C<;>).
  
  To clear a section comment, use DeleteSectionComment ($section)
  
  =cut
  
  sub SetSectionComment
  {
      my $self = shift;
      my $sect = shift;
      my @comment = @_;
  
      return undef if not defined $sect;
      return undef unless @comment;
      
      $self->_caseify(\$sect);
  
      $self->_touch_section($sect);
      $self->{sCMT}{$sect} = [];
      # At this point it's possible to have a comment for a section that
      # doesn't exist. This comment will not get written to the INI file.
      
      CORE::push @{$self->{sCMT}{$sect}}, $self->_markup_comments(@comment);
      return scalar @comment;
  }
  
  
  
  # this helper makes sure that each line is preceded with the correct comment
  # character
  sub _markup_comments 
  {
    my $self = shift;
    my @comment = @_;
  
    my $allCmt = $self->{allowed_comment_char};
    my $cmtChr = $self->{comment_char};
    foreach (@comment) {
      m/^\s*[$allCmt]/ or ($_ = "$cmtChr $_");
    }
    @comment;
  }
  
  
  
  =head2 GetSectionComment ($section)
  
  Returns a list of lines, being the comment attached to section $section. In 
  scalar context, returns a string containing the lines of the comment separated
  by newlines.
  
  The lines are presented as-is, with whatever comment character was originally
  used on that line.
  
  =cut
  
  sub GetSectionComment
  {
      my $self = shift;
      my $sect = shift;
  
      return undef if not defined $sect;
      
      $self->_caseify(\$sect);
  
      if (exists $self->{sCMT}{$sect}) {
          my @ret = @{$self->{sCMT}{$sect}};
          if (wantarray()) {
              return @ret;
          }
          else {
              if (defined ($/)) {
                  return join "$/", @ret;
              } else {
                  return join "\n", @ret;
              }
          }
      } else {
          return undef;
      }
  }
  
  =head2 DeleteSectionComment ($section)
  
  Removes the comment for the specified section.
  
  =cut
  
  sub DeleteSectionComment
  {
      my $self = shift;
      my $sect = shift;
      
      return undef if not defined $sect;
      
      $self->_caseify(\$sect);
      $self->_touch_section($sect);
  
      delete $self->{sCMT}{$sect};
  }
  
  =head2 SetParameterComment ($section, $parameter, @comment)
  
  Sets the comment attached to a particular parameter.
  
  Any line of @comment that does not have a comment character will be
  prepended with one. See L</SetSectionComment($section, @comment)> above
  
  =cut
  
  sub SetParameterComment
  {
      my $self = shift;
      my $sect = shift;
      my $parm = shift;
      my @comment = @_;
  
      defined($sect) || return undef;
      defined($parm) || return undef;
      @comment || return undef;
      
      $self->_caseify(\$sect, \$parm);
  
      $self->_touch_parameter($sect, $parm);
      if (not exists $self->{pCMT}{$sect}) {
          $self->{pCMT}{$sect} = {};
      }
      
      $self->{pCMT}{$sect}{$parm} = [];
      # Note that at this point, it's possible to have a comment for a parameter,
      # without that parameter actually existing in the INI file.
      CORE::push @{$self->{pCMT}{$sect}{$parm}}, $self->_markup_comments(@comment);
      return scalar @comment;
  }
  
  sub _SetEndComments
  {
      my $self = shift;
      my @comments = @_;
  
      $self->{_comments_at_end_of_file} = \@comments;
  
      return 1;
  }
  
  sub _GetEndComments {
      my $self = shift;
  
      return @{$self->{_comments_at_end_of_file}};
  }
  
  =head2 GetParameterComment ($section, $parameter)
  
  Gets the comment attached to a parameter. In list context returns all
  comments - in scalar context returns them joined by newlines.
  
  =cut
  
  sub GetParameterComment
  {
      my $self = shift;
      my $sect = shift;
      my $parm = shift;
      
      defined($sect) || return undef;
      defined($parm) || return undef;
      
      $self->_caseify(\$sect, \$parm);
  
      exists($self->{pCMT}{$sect}) || return undef;
      exists($self->{pCMT}{$sect}{$parm}) || return undef;
      
      my @comment = @{$self->{pCMT}{$sect}{$parm}};
      return wantarray() ? @comment : join((defined $/ ? $/ : "\n"), @comment);
  }
  
  =head2 DeleteParameterComment ($section, $parmeter)
  
  Deletes the comment attached to a parameter.
  
  =cut
  
  sub DeleteParameterComment
  {
      my $self = shift;
      my $sect = shift;
      my $parm = shift;
      
      defined($sect) || return undef;
      defined($parm) || return undef;
      
      $self->_caseify(\$sect, \$parm);
  
      # If the parameter doesn't exist, our goal has already been achieved
      exists($self->{pCMT}{$sect}) || return 1;
      exists($self->{pCMT}{$sect}{$parm}) || return 1;
  
      $self->_touch_parameter($sect, $parm);
      delete $self->{pCMT}{$sect}{$parm};
      return 1;
  }
  
  =head2 GetParameterEOT ($section, $parameter)
  
  Accessor method for the EOT text (in fact, style) of the specified parameter. If any text is used as an EOT mark, this will be returned. If the parameter was not recorded using HERE style multiple lines, GetParameterEOT returns undef.
  
  =cut
  
  sub GetParameterEOT
  {
      my $self = shift;
      my $sect = shift;
      my $parm = shift;
  
      defined($sect) || return undef;
      defined($parm) || return undef;
      
      $self->_caseify(\$sect, \$parm);
  
      if (not exists $self->{EOT}{$sect}) {
          $self->{EOT}{$sect} = {};
      }
  
      if (not exists $self->{EOT}{$sect}{$parm}) {
          return undef;
      }
      return $self->{EOT}{$sect}{$parm};
  }
  
  =head2 $cfg->SetParameterEOT ($section, $parameter, $EOT)
  
  Accessor method for the EOT text for the specified parameter. Sets the HERE style marker text to the value $EOT. Once the EOT text is set, that parameter will be saved in HERE style.
  
  To un-set the EOT text, use DeleteParameterEOT ($section, $parameter).
  
  =cut
  
  sub SetParameterEOT
  {
      my $self = shift;
      my $sect = shift;
      my $parm = shift;
      my $EOT = shift;
  
      defined($sect) || return undef;
      defined($parm) || return undef;
      defined($EOT) || return undef;
      
      $self->_caseify(\$sect, \$parm);
  
      $self->_touch_parameter($sect, $parm);
      if (not exists $self->{EOT}{$sect}) {
          $self->{EOT}{$sect} = {};
      }
  
      $self->{EOT}{$sect}{$parm} = $EOT;
  }
  
  =head2 DeleteParameterEOT ($section, $parmeter)
  
  Removes the EOT marker for the given section and parameter.
  When writing a configuration file, if no EOT marker is defined 
  then "EOT" is used.
  
  =cut
  
  sub DeleteParameterEOT
  {
      my $self = shift;
      my $sect = shift;
      my $parm = shift;
      
      defined($sect) || return undef;
      defined($parm) || return undef;
      
      $self->_caseify(\$sect, \$parm);
  
      $self->_touch_parameter($sect, $parm);
      delete $self->{EOT}{$sect}{$parm};
  }
  
  =head2 SetParameterTrailingComment ($section, $parameter, $cmt)
  
  Set the end trailing comment for the given section and parameter. 
  If there is a old comment for the parameter, it will be 
  overwritten by the new one.
  
  If there is a new parameter trailing comment to be added, the
  value should be added first.
  
  =cut
  
  sub SetParameterTrailingComment
  {
      my $self = shift;
      my $sect = shift;
      my $parm = shift;
      my $cmt = shift;
  
      return undef if not defined $sect;
      return undef if not defined $parm;
      return undef if not defined $cmt;
  
      $self->_caseify(\$sect, \$parm);
  
      # confirm the parameter exist
      return undef if not exists $self->{v}{$sect}{$parm};
  
      $self->_touch_parameter($sect, $parm);
      $self->{peCMT}{$sect}{$parm} = $cmt;
      1;
  }
  
  =head2 GetParameterTrailingComment ($section, $parameter)
  
  An accessor method to read the trailing comment after the parameter. 
  The trailing comment will be returned if there is one. A null string 
  will be returned if the parameter exists but no comment for it. 
  otherwise, L<undef> will be returned.
  
  =cut
  
  sub GetParameterTrailingComment
  {
      my $self = shift;
      my $sect = shift;
      my $parm = shift;
  
      return undef if not defined $sect;
      return undef if not defined $parm;
  
      $self->_caseify(\$sect, \$parm);
  
      # confirm the parameter exist
      return undef if not exists $self->{v}{$sect}{$parm};
      return $self->{peCMT}{$sect}{$parm};
  }
  
  =head2 Delete
  
  Deletes the entire configuration file in memory.
  
  =cut
  
  sub Delete {
      my $self = shift;
  
      foreach my $section ($self->Sections()) {
          $self->DeleteSection($section);
      }
  
      return 1;
  } # end Delete
  
  
  
  =head1 USAGE -- Tied Hash
  
  =head2 tie %ini, 'Config::IniFiles', (-file=>$filename, [-option=>value ...] )
  
  Using C<tie>, you can tie a hash to a B<Config::IniFiles> object. This creates a new
  object which you can access through your hash, so you use this instead of the 
  B<new> method. This actually creates a hash of hashes to access the values in 
  the INI file. The options you provide through C<tie> are the same as given for 
  the B<new> method, above.
  
  Here's an example:
  
    use Config::IniFiles;
    
    my %ini
    tie %ini, 'Config::IniFiles', ( -file => "/path/configfile.ini" );
  
    print "We have $ini{Section}{Parameter}." if $ini{Section}{Parameter};
  
  Accessing and using the hash works just like accessing a regular hash and 
  many of the object methods are made available through the hash interface.
  
  For those methods that do not coincide with the hash paradigm, you can use 
  the Perl C<tied> function to get at the underlying object tied to the hash 
  and call methods on that object. For example, to write the hash out to a new
  ini file, you would do something like this:
  
    tied( %ini )->WriteConfig( "/newpath/newconfig.ini" ) ||
      die "Could not write settings to new file.";
  
  =head2 $val = $ini{$section}{$parameter}
  
  Returns the value of $parameter in $section. 
  
  Multiline values accessed through a hash will be returned 
  as a list in list context and a concatenated value in scalar
  context.
  
  =head2 $ini{$section}{$parameter} = $value;
  
  Sets the value of C<$parameter> in C<$section> to C<$value>. 
  
  To set a multiline or multiv-alue parameter just assign an 
  array reference to the hash entry, like this:
  
   $ini{$section}{$parameter} = [$value1, $value2, ...];
  
  If the parameter did not exist in the original file, it will 
  be created. However, Perl does not seem to extend autovivification 
  to tied hashes. That means that if you try to say
  
    $ini{new_section}{new_paramters} = $val;
  
  and the section 'new_section' does not exist, then Perl won't 
  properly create it. In order to work around this you will need 
  to create a hash reference in that section and then assign the
  parameter value. Something like this should do nicely:
  
    $ini{new_section} = {};
    $ini{new_section}{new_paramters} = $val;
  
  =head2 %hash = %{$ini{$section}}
  
  Using the tie interface, you can copy whole sections of the 
  ini file into another hash. Note that this makes a copy of 
  the entire section. The new hash in no longer tied to the 
  ini file, In particular, this means -default and -nocase 
  settings will not apply to C<%hash>.
  
  
  =head2 $ini{$section} = {}; %{$ini{$section}} = %parameters;
  
  Through the hash interface, you have the ability to replace 
  the entire section with a new set of parameters. This call
  will fail, however, if the argument passed in NOT a hash 
  reference. You must use both lines, as shown above so that 
  Perl recognizes the section as a hash reference context 
  before COPYing over the values from your C<%parameters> hash.
  
  =head2 delete $ini{$section}{$parameter}
  
  When tied to a hash, you can use the Perl C<delete> function
  to completely remove a parameter from a section.
  
  =head2 delete $ini{$section}
  
  The tied interface also allows you to delete an entire 
  section from the ini file using the Perl C<delete> function.
  
  =head2 %ini = ();
  
  If you really want to delete B<all> the items in the ini file, this 
  will do it. Of course, the changes won't be written to the actual
  file unless you call B<RewriteConfig> on the object tied to the hash.
  
  =head2 Parameter names
  
  =over 4
  
  =item my @keys = keys %{$ini{$section}}
  
  =item while (($k, $v) = each %{$ini{$section}}) {...}
  
  =item if( exists %{$ini{$section}}, $parameter ) {...}
  
  =back
  
  When tied to a hash, you use the Perl C<keys> and C<each> 
  functions to iteratively list the parameters (C<keys>) or 
  parameters and their values (C<each>) in a given section.
  
  You can also use the Perl C<exists> function to see if a 
  parameter is defined in a given section.
  
  Note that none of these will return parameter names that 
  are part of the default section (if set), although accessing
  an unknown parameter in the specified section will return a 
  value from the default section if there is one.
  
  
  =head2 Section names
  
  =over 4
  
  =item foreach( keys %ini ) {...}
  
  =item while (($k, $v) = each %ini) {...}
  
  =item if( exists %ini, $section ) {...}
  
  =back
  
  When tied to a hash, you use the Perl C<keys> and C<each> 
  functions to iteratively list the sections in the ini file.
  
  You can also use the Perl C<exists> function to see if a 
  section is defined in the file.
  
  =cut
  
  ############################################################
  #
  # TIEHASH Methods
  #
  # Description:
  # These methods allow you to tie a hash to the 
  # Config::IniFiles object. Note that, when tied, the 
  # user wants to look at thinks like $ini{sec}{parm}, but the 
  # TIEHASH only provides one level of hash interace, so the 
  # root object gets asked for a $ini{sec}, which this 
  # implements. To further tie the {parm} hash, the internal 
  # class Config::IniFiles::_section, is provided, below.
  #
  ############################################################
  # ----------------------------------------------------------
  # Date      Modification                              Author
  # ----------------------------------------------------------
  # 2000May09 Created method                                JW
  # ----------------------------------------------------------
  sub TIEHASH {
    my $class = shift;
    my %parms = @_;
  
    # Get a new object
    my $self = $class->new( %parms );
  
    return $self;
  } # end TIEHASH
  
  
  # ----------------------------------------------------------
  # Date      Modification                              Author
  # ----------------------------------------------------------
  # 2000May09 Created method                                JW
  # ----------------------------------------------------------
  sub FETCH {
    my $self = shift;
    my( $key ) = @_;
  
    $self->_caseify(\$key);
    return if (! $self->{v}{$key});
  
    my %retval;
    tie %retval, 'Config::IniFiles::_section', $self, $key;
    return \%retval;
  
  } # end FETCH
  
  # ----------------------------------------------------------
  # Date      Modification                              Author
  # ----------------------------------------------------------
  # 2000Jun14 Fixed bug where wrong ref was saved           JW
  # 2000Oct09 Fixed possible but in %parms with defaults    JW
  # 2001Apr04 Fixed -nocase problem in storing              JW
  # ----------------------------------------------------------
  sub STORE {
    my $self = shift;
    my( $key, $ref ) = @_;
  
    return undef unless ref($ref) eq 'HASH';
  
    $self->_caseify(\$key);
  
    $self->AddSection($key);
    $self->{v}{$key} = {%$ref};
    $self->{parms}{$key} = [keys %$ref];
    $self->{myparms}{$key} = [keys %$ref];
    1;
  } # end STORE
  
  
  # ----------------------------------------------------------
  # Date      Modification                              Author
  # ----------------------------------------------------------
  # 2000May09 Created method                                JW
  # 2000Dec17 Now removes comments, groups and EOTs too     JW
  # 2001Arp04 Fixed -nocase problem                         JW
  # ----------------------------------------------------------
  sub DELETE {
    my $self = shift;
    my( $key ) = @_;
  
    my $retval=$self->FETCH($key);
    $self->DeleteSection($key);
    return $retval;
  } # end DELETE
  
  
  # ----------------------------------------------------------
  # Date      Modification                              Author
  # ----------------------------------------------------------
  # 2000May09 Created method                                JW
  # ----------------------------------------------------------
  sub CLEAR {
    my $self = shift;
  
    return $self->Delete();
  } # end CLEAR
  
  # ----------------------------------------------------------
  # Date      Modification                              Author
  # ----------------------------------------------------------
  # 2000May09 Created method                                JW
  # ----------------------------------------------------------
  sub FIRSTKEY {
    my $self = shift;
  
    $self->{tied_enumerator}=0;
    return $self->NEXTKEY();
  } # end FIRSTKEY
  
  
  # ----------------------------------------------------------
  # Date      Modification                              Author
  # ----------------------------------------------------------
  # 2000May09 Created method                                JW
  # ----------------------------------------------------------
  sub NEXTKEY {
    my $self = shift;
    my( $last ) = @_;
  
    my $i=$self->{tied_enumerator}++;
    my $key=$self->{sects}[$i]; 
    return if (! defined $key);
    return wantarray ? ($key, $self->FETCH($key)) : $key;
  } # end NEXTKEY
  
  
  # ----------------------------------------------------------
  # Date      Modification                              Author
  # ----------------------------------------------------------
  # 2000May09 Created method                                JW
  # 2001Apr04 Fixed -nocase bug and false true bug          JW
  # ----------------------------------------------------------
  sub EXISTS {
    my $self = shift;
    my( $key ) = @_;
    return $self->SectionExists($key);
  } # end EXISTS
  
  
  # ----------------------------------------------------------
  # DESTROY is used by TIEHASH and the Perl garbage collector,
  # ----------------------------------------------------------
  # Date      Modification                              Author
  # ----------------------------------------------------------
  # 2000May09 Created method                                JW
  # ----------------------------------------------------------
  sub DESTROY {
    # my $self = shift;
  } # end if
  
  
  # ----------------------------------------------------------
  # Sub: _make_filehandle
  #
  # Args: $thing
  #   $thing  An input source
  #
  # Description: Takes an input source of a filehandle, 
  # filehandle glob, reference to a filehandle glob, IO::File
  # object or scalar filename and returns a file handle to 
  # read from it with.
  # ----------------------------------------------------------
  # Date      Modification                              Author
  # ----------------------------------------------------------
  # 06Dec2001 Added to support input from any source        JW
  # ----------------------------------------------------------
  sub _make_filehandle {
    my $self = shift;
  
    #
    # This code is 'borrowed' from Lincoln D. Stein's GD.pm module
    # with modification for this module. Thanks Lincoln!
    #
    
    no strict 'refs';
    my $thing = shift;
  
    if (ref($thing) eq "SCALAR") {
        if (eval { require IO::Scalar; $IO::Scalar::VERSION >= 2.109; }) {
            return IO::Scalar->new($thing);
        } else {
            warn "SCALAR reference as file descriptor requires IO::stringy ".
              "v2.109 or later" if ($^W);
            return;
        }
    }
  
    return $thing if defined(fileno $thing);
  #  return $thing if defined($thing) && ref($thing) && defined(fileno $thing);
    
    # otherwise try qualifying it into caller's package
    my $fh = qualify_to_ref($thing,caller(1));
    return $fh if defined(fileno $fh);
  #  return $fh if defined($thing) && ref($thing) && defined(fileno $fh);
    
    # otherwise treat it as a file to open
    $fh = gensym;
    open($fh,$thing) || return;
    
    return $fh;
  } # end _make_filehandle
  
  ############################################################
  #
  # INTERNAL PACKAGE: Config::IniFiles::_section
  #
  # Description:
  # This package is used to provide a single-level TIEHASH
  # interface to the sections in the IniFile. When tied, the 
  # user wants to look at thinks like $ini{sec}{parm}, but the 
  # TIEHASH only provides one level of hash interace, so the 
  # root object gets asked for a $ini{sec} and must return a 
  # has reference that accurately covers the '{parm}' part.
  #
  # This package is only used when tied and is inter-woven 
  # between the sections and their parameters when the TIEHASH
  # method is called by Perl. It's a very simple implementation
  # of a tied hash object that simply maps onto the object API.
  #
  ############################################################
  # Date        Modification                            Author
  # ----------------------------------------------------------
  # 2000.May.09 Created to excapsulate TIEHASH interface    JW
  ############################################################
  package Config::IniFiles::_section;
  
  use strict;
  use Carp;
  use vars qw( $VERSION );
  
  $Config::IniFiles::_section::VERSION = 2.16;
  
  # ----------------------------------------------------------
  # Sub: Config::IniFiles::_section::TIEHASH
  #
  # Args: $class, $config, $section
  #   $class    The class that this is being tied to.
  #   $config   The parent Config::IniFiles object
  #   $section  The section this tied object refers to
  #
  # Description: Builds the object that implements accesses to
  # the tied hash.
  # ----------------------------------------------------------
  # Date      Modification                              Author
  # ----------------------------------------------------------
  # ----------------------------------------------------------
  sub TIEHASH {
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my ($config, $section)=@_;
  
    # Make a new object
    return bless {config=>$config, section=>$section}, $class;
  } # end TIEHASH
  
  
  # ----------------------------------------------------------
  # Sub: Config::IniFiles::_section::FETCH
  #
  # Args: $key
  #   $key    The name of the key whose value to get
  #
  # Description: Returns the value associated with $key. If
  # the value is a list, returns a list reference.
  # ----------------------------------------------------------
  # Date      Modification                              Author
  # ----------------------------------------------------------
  # 2000Jun15 Fixed bugs in -default handler                JW
  # 2000Dec07 Fixed another bug in -deault handler          JW
  # 2002Jul04 Returning scalar values (Bug:447532)          AS
  # ----------------------------------------------------------
  sub FETCH {
      my ($self, $key)=@_;
      my @retval=$self->{config}->val($self->{section}, $key);
      return (@retval <= 1) ? $retval[0] : \@retval;
  } # end FETCH
  
  
  # ----------------------------------------------------------
  # Sub: Config::IniFiles::_section::STORE
  #
  # Args: $key, @val
  #   $key    The key under which to store the value
  #   @val    The value to store, either an array or a scalar
  #
  # Description: Sets the value for the specified $key
  # ----------------------------------------------------------
  # Date      Modification                              Author
  # ----------------------------------------------------------
  # 2001Apr04 Fixed -nocase bug                             JW
  # ----------------------------------------------------------
  sub STORE {
      my ($self, $key, @val)=@_;
      return $self->{config}->newval($self->{section}, $key, @val);
  } # end STORE
  
  
  # ----------------------------------------------------------
  # Sub: Config::IniFiles::_section::DELETE
  #
  # Args: $key
  #   $key    The key to remove from the hash
  #
  # Description: Removes the specified key from the hash and
  # returns its former value.
  # ----------------------------------------------------------
  # Date      Modification                              Author
  # ----------------------------------------------------------
  # 2001Apr04 Fixed -nocase bug                              JW
  # ----------------------------------------------------------
  sub DELETE {
      my ($self, $key)=@_;
      my $retval=$self->{config}->val($self->{section}, $key);
      $self->{config}->delval($self->{section}, $key);
      return $retval;
  } # end DELETE
  
  # ----------------------------------------------------------
  # Sub: Config::IniFiles::_section::CLEAR
  #
  # Args: (None)
  #
  # Description: Empties the entire hash
  # ----------------------------------------------------------
  # Date      Modification                              Author
  # ----------------------------------------------------------
  # ----------------------------------------------------------
  sub CLEAR    {
    my ($self) = @_;
    return $self->{config}->DeleteSection($self->{section});
  } # end CLEAR
  
  # ----------------------------------------------------------
  # Sub: Config::IniFiles::_section::EXISTS
  #
  # Args: $key
  #   $key    The key to look for
  #
  # Description: Returns whether the key exists
  # ----------------------------------------------------------
  # Date      Modification                              Author
  # ----------------------------------------------------------
  # 2001Apr04 Fixed -nocase bug                             JW
  # ----------------------------------------------------------
  sub EXISTS   {
    my ($self, $key)=@_;
    return $self->{config}->exists($self->{section},$key);
  } # end EXISTS
  
  # ----------------------------------------------------------
  # Sub: Config::IniFiles::_section::FIRSTKEY
  #
  # Args: (None)
  #
  # Description: Returns the first key in the hash
  # ----------------------------------------------------------
  # Date      Modification                              Author
  # ----------------------------------------------------------
  # ----------------------------------------------------------
  sub FIRSTKEY {
    my $self = shift;
  
    $self->{tied_enumerator}=0;
    return $self->NEXTKEY();
  } # end FIRSTKEY
  
  # ----------------------------------------------------------
  # Sub: Config::IniFiles::_section::NEXTKEY
  #
  # Args: $last
  #   $last   The last key accessed by the interator
  #
  # Description: Returns the next key in line
  # ----------------------------------------------------------
  # Date      Modification                              Author
  # ----------------------------------------------------------
  # ----------------------------------------------------------
  sub NEXTKEY  {
    my $self = shift;
    my( $last ) = @_;
  
    my $i=$self->{tied_enumerator}++;
    my @keys = $self->{config}->Parameters($self->{section});
    my $key=$keys[$i];
    return if (! defined $key);
    return wantarray ? ($key, $self->FETCH($key)) : $key;
  } # end NEXTKEY
  
  
  # ----------------------------------------------------------
  # Sub: Config::IniFiles::_section::DESTROY
  #
  # Args: (None)
  #
  # Description: Called on cleanup
  # ----------------------------------------------------------
  # Date      Modification                              Author
  # ----------------------------------------------------------
  # ----------------------------------------------------------
  sub DESTROY  {
    # my $self = shift
  } # end DESTROY
  
  1;
  
  =head1 IMPORT / DELTA FEATURES
  
  The I<-import> option to L</new> allows one to stack one
  I<Config::IniFiles> object on top of another (which might be itself
  stacked in turn and so on recursively, but this is beyond the
  point). The effect, as briefly explained in L</new>, is that the
  fields appearing in the composite object will be a superposition of
  those coming from the ``original'' one and the lines coming from the
  file, the latter taking precedence. For example, let's say that
  C<$master> and C<overlay> were created like this:
  
     my $master  = Config::IniFiles->new(-file => "master.ini");
     my $overlay = Config::IniFiles->new(-file => "overlay.ini",
              -import => $master);
  
  If the contents of C<master.ini> and C<overlay.ini> are respectively
  
     ; master.ini
     [section1]
     arg0=unchanged from master.ini
     arg1=val1
  
     [section2]
     arg2=val2
  
  and
  
     ; overlay.ini
     [section1]
     arg1=overriden
  
  Then C<< $overlay->val("section1", "arg1") >> is "overriden", while
  C<< $overlay->val("section1", "arg0") >> is "unchanged from
  master.ini".
  
  This feature may be used to ship a ``global defaults'' configuration
  file for a Perl application, that can be overridden piecewise by a
  much shorter, per-site configuration file. Assuming UNIX-style path
  names, this would be done like this:
  
     my $defaultconfig = Config::IniFiles->new
         (-file => "/usr/share/myapp/myapp.ini.default");
     my $config = Config::IniFiles->new
         (-file => "/etc/myapp.ini", -import => $defaultconfig);
     # Now use $config and forget about $defaultconfig in the rest of
     # the program
  
  Starting with version 2.39, I<Config::IniFiles> also provides features
  to keep the importing / per-site configuration file small, by only
  saving those options that were modified by the running program. That
  is, if one calls
  
     $overlay->setval("section1", "arg1", "anotherval");
     $overlay->newval("section3", "arg3", "val3");
     $overlay->WriteConfig(-delta=>1);
  
  C<overlay.ini> would now contain
  
     ; overlay.ini
     [section1]
     arg1=anotherval
  
     [section3]
     arg3=val3
  
  This is called a I<delta file> (see L</WriteConfig>). The untouched
  [section2] and arg0 do not appear, and the config file is therefore
  shorter; while of course, reloading the configuration into C<$master>
  and C<$overlay>, either through C<< $overlay->ReadConfig() >> or through
  the same code as above (e.g. when application restarts), would yield
  exactly the same result had the overlay object been saved in whole to
  the file system.
  
  The only problem with this delta technique is one cannot delete the
  default values in the overlay configuration file, only change
  them. This is solved by a file format extension, enabled by the
  I<-negativedeltas> option to L</new>: if, say, one would delete
  parameters like this,
  
     $overlay->DeleteSection("section2");
     $overlay->delval("section1", "arg0");
     $overlay->WriteConfig(-delta=>1);
  
  The I<overlay.ini> file would now read:
  
     ; overlay.ini
     [section1]
     ; arg0 is deleted
     arg1=anotherval
  
     ; [section2] is deleted
  
     [section3]
     arg3=val3
  
  Assuming C<$overlay> was later re-read with C<< -negativedeltas => 1 >>,
  the parser would interpret the deletion comments to yield the correct
  result, that is, [section2] and arg0 would cease to exist in the
  C<$overlay> object.
  
  =cut
  
  
  =head1 DIAGNOSTICS
  
  =head2 @Config::IniFiles::errors
  
  Contains a list of errors encountered while parsing the configuration
  file.  If the I<new> method returns B<undef>, check the value of this
  to find out what's wrong.  This value is reset each time a config file
  is read.
  
  =head1 BUGS
  
  =over 3
  
  =item *
  
  The output from [Re]WriteConfig/OutputConfig might not be as pretty as
  it can be.  Comments are tied to whatever was immediately below them.
  And case is not preserved for Section and Parameter names if the -nocase
  option was used.
  
  =item *
  
  No locking is done by [Re]WriteConfig.  When writing servers, take
  care that only the parent ever calls this, and consider making your
  own backup.
  
  =back
  
  =head1 Data Structure
  
  Note that this is only a reference for the package maintainers - one of the
  upcoming revisions to this package will include a total clean up of the
  data structure.
  
    $iniconf->{cf} = "config_file_name"
            ->{startup_settings} = \%orginal_object_parameters
            ->{firstload} = 0 OR 1
            ->{imported} = $object WHERE $object->isa("Config::IniFiles")
            ->{nocase} = 0
            ->{reloadwarn} = 0
            ->{sects} = \@sections
            ->{mysects} = \@sections
            ->{sCMT}{$sect} = \@comment_lines
            ->{group}{$group} = \@group_members
            ->{parms}{$sect} = \@section_parms
            ->{myparms}{$sect} = \@section_parms
            ->{EOT}{$sect}{$parm} = "end of text string"
            ->{pCMT}{$sect}{$parm} = \@comment_lines
            ->{v}{$sect}{$parm} = $value   OR  \@values
  
  =head1 AUTHOR and ACKNOWLEDGEMENTS
  
  The original code was written by Scott Hutton.
  Then handled for a time by Rich Bowen (thanks!),
  It is now managed by Jeremy Wadsack,
  with many contributions from various other people.
  
  In particular, special thanks go to (in roughly chronological order):
  
  Bernie Cosell, Alan Young, Alex Satrapa, Mike Blazer, Wilbert van de Pieterman,
  Steve Campbell, Robert Konigsberg, Scott Dellinger, R. Bernstein,
  Daniel Winkelmann, Pires Claudio, Adrian Phillips, 
  Marek Rouchal, Luc St Louis, Adam Fischler, Kay Röpke, Matt Wilson, 
  Raviraj Murdeshwar and Slaven Rezic, Florian Pfaff
  
  Geez, that's a lot of people. And apologies to the folks who were missed.
  
  If you want someone to bug about this, that would be:
  
      Jeremy Wadsack <dgsupport at wadsack-allen dot com>
  
  If you want more information, or want to participate, go to:
  
      http://sourceforge.net/projects/config-inifiles/
  
  Please send bug reports to config-inifiles-bugs@lists.sourceforge.net
  
  Development discussion occurs on the mailing list
  config-inifiles-dev@lists.sourceforge.net, which you can subscribe
  to by going to the project web site (link above).
  
  This program is free software; you can redistribute it and/or 
  modify it under the same terms as Perl itself.
  
  =cut
  
  1;
  
  # Please keep the following within the last four lines of the file
  #[JW for editor]:mode=perl:tabSize=8:indentSize=2:noTabs=true:indentOnEnter=true:
  
CONFIG_INIFILES

$fatpacked{"Data/OptList.pm"} = <<'DATA_OPTLIST';
  use strict;
  use warnings;
  package Data::OptList;
  BEGIN {
    $Data::OptList::VERSION = '0.107';
  }
  # ABSTRACT: parse and validate simple name/value option pairs
  
  use List::Util ();
  use Params::Util ();
  use Sub::Install 0.921 ();
  
  
  my %test_for;
  BEGIN {
    %test_for = (
      CODE   => \&Params::Util::_CODELIKE,  ## no critic
      HASH   => \&Params::Util::_HASHLIKE,  ## no critic
      ARRAY  => \&Params::Util::_ARRAYLIKE, ## no critic
      SCALAR => \&Params::Util::_SCALAR0,   ## no critic
    );
  }
  
  sub __is_a {
    my ($got, $expected) = @_;
  
    return List::Util::first { __is_a($got, $_) } @$expected if ref $expected;
  
    return defined (
      exists($test_for{$expected})
      ? $test_for{$expected}->($got)
      : Params::Util::_INSTANCE($got, $expected) ## no critic
    );
  }
  
  sub mkopt {
    my ($opt_list) = shift;
  
    my ($moniker, $require_unique, $must_be); # the old positional args
    my $name_test;
  
    if (@_ == 1 and Params::Util::_HASHLIKE($_[0])) {
      my $arg = $_[0];
      ($moniker, $require_unique, $must_be, $name_test)
        = @$arg{ qw(moniker require_unique must_be name_test) };
    } else {
      ($moniker, $require_unique, $must_be) = @_;
    }
  
    $moniker = 'unnamed' unless defined $moniker;
  
    return [] unless $opt_list;
  
    $name_test ||= sub { ! ref $_[0] };
  
    $opt_list = [
      map { $_ => (ref $opt_list->{$_} ? $opt_list->{$_} : ()) } keys %$opt_list
    ] if ref $opt_list eq 'HASH';
  
    my @return;
    my %seen;
  
    for (my $i = 0; $i < @$opt_list; $i++) { ## no critic
      my $name = $opt_list->[$i];
      my $value;
  
      if ($require_unique) {
        Carp::croak "multiple definitions provided for $name" if $seen{$name}++;
      }
  
      if    ($i == $#$opt_list)               { $value = undef;            }
      elsif (not defined $opt_list->[$i+1])   { $value = undef; $i++       }
      elsif ($name_test->($opt_list->[$i+1])) { $value = undef;            }
      else                                    { $value = $opt_list->[++$i] }
  
      if ($must_be and defined $value) {
        unless (__is_a($value, $must_be)) {
          my $ref = ref $value;
          Carp::croak "$ref-ref values are not valid in $moniker opt list";
        }
      }
  
      push @return, [ $name => $value ];
    }
  
    return \@return;
  }
  
  
  sub mkopt_hash {
    my ($opt_list, $moniker, $must_be) = @_;
    return {} unless $opt_list;
  
    $opt_list = mkopt($opt_list, $moniker, 1, $must_be);
    my %hash = map { $_->[0] => $_->[1] } @$opt_list;
    return \%hash;
  }
  
  
  BEGIN {
    *import = Sub::Install::exporter {
      exports => [qw(mkopt mkopt_hash)],
    };
  }
  
  1;
  
  __END__
  =pod
  
  =head1 NAME
  
  Data::OptList - parse and validate simple name/value option pairs
  
  =head1 VERSION
  
  version 0.107
  
  =head1 SYNOPSIS
  
    use Data::OptList;
  
    my $options = Data::OptList::mkopt([
      qw(key1 key2 key3 key4),
      key5 => { ... },
      key6 => [ ... ],
      key7 => sub { ... },
      key8 => { ... },
      key8 => [ ... ],
    ]);
  
  ...is the same thing, more or less, as:
  
    my $options = [
      [ key1 => undef,        ],
      [ key2 => undef,        ],
      [ key3 => undef,        ],
      [ key4 => undef,        ],
      [ key5 => { ... },      ],
      [ key6 => [ ... ],      ],
      [ key7 => sub { ... },  ],
      [ key8 => { ... },      ],
      [ key8 => [ ... ],      ],
    ]);
  
  =head1 DESCRIPTION
  
  Hashes are great for storing named data, but if you want more than one entry
  for a name, you have to use a list of pairs.  Even then, this is really boring
  to write:
  
    $values = [
      foo => undef,
      bar => undef,
      baz => undef,
      xyz => { ... },
    ];
  
  Just look at all those undefs!  Don't worry, we can get rid of those:
  
    $values = [
      map { $_ => undef } qw(foo bar baz),
      xyz => { ... },
    ];
  
  Aaaauuugh!  We've saved a little typing, but now it requires thought to read,
  and thinking is even worse than typing... and it's got a bug!  It looked right,
  didn't it?  Well, the C<< xyz => { ... } >> gets consumed by the map, and we
  don't get the data we wanted.
  
  With Data::OptList, you can do this instead:
  
    $values = Data::OptList::mkopt([
      qw(foo bar baz),
      xyz => { ... },
    ]);
  
  This works by assuming that any defined scalar is a name and any reference
  following a name is its value.
  
  =head1 FUNCTIONS
  
  =head2 mkopt
  
    my $opt_list = Data::OptList::mkopt($input, \%arg);
  
  Valid arguments are:
  
    moniker        - a word used in errors to describe the opt list; encouraged
    require_unique - if true, no name may appear more than once
    must_be        - types to which opt list values are limited (described below)
    name_test      - a coderef used to test whether a value can be a name
                     (described below, but you probably don't want this)
  
  This produces an array of arrays; the inner arrays are name/value pairs.
  Values will be either "undef" or a reference.
  
  Positional parameters may be used for compability with the old C<mkopt>
  interface:
  
    my $opt_list = Data::OptList::mkopt($input, $moniker, $req_uni, $must_be);
  
  Valid values for C<$input>:
  
   undef    -> []
   hashref  -> [ [ key1 => value1 ] ... ] # non-ref values become undef
   arrayref -> every name followed by a non-name becomes a pair: [ name => ref ]
               every name followed by undef becomes a pair: [ name => undef ]
               otherwise, it becomes [ name => undef ] like so:
               [ "a", "b", [ 1, 2 ] ] -> [ [ a => undef ], [ b => [ 1, 2 ] ] ]
  
  By default, a I<name> is any defined non-reference.  The C<name_test> parameter
  can be a code ref that tests whether the argument passed it is a name or not.
  This should be used rarely.  Interactions between C<require_unique> and
  C<name_test> are not yet particularly elegant, as C<require_unique> just tests
  string equality.  B<This may change.>
  
  The C<must_be> parameter is either a scalar or array of scalars; it defines
  what kind(s) of refs may be values.  If an invalid value is found, an exception
  is thrown.  If no value is passed for this argument, any reference is valid.
  If C<must_be> specifies that values must be CODE, HASH, ARRAY, or SCALAR, then
  Params::Util is used to check whether the given value can provide that
  interface.  Otherwise, it checks that the given value is an object of the kind.
  
  In other words:
  
    [ qw(SCALAR HASH Object::Known) ]
  
  Means:
  
    _SCALAR0($value) or _HASH($value) or _INSTANCE($value, 'Object::Known')
  
  =head2 mkopt_hash
  
    my $opt_hash = Data::OptList::mkopt_hash($input, $moniker, $must_be);
  
  Given valid C<L</mkopt>> input, this routine returns a reference to a hash.  It
  will throw an exception if any name has more than one value.
  
  =head1 EXPORTS
  
  Both C<mkopt> and C<mkopt_hash> may be exported on request.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
DATA_OPTLIST

$fatpacked{"Devel/GlobalDestruction.pm"} = <<'DEVEL_GLOBALDESTRUCTION';
  #!/usr/bin/perl
  
  package Devel::GlobalDestruction;
  
  use strict;
  use warnings;
  
  use XSLoader;
  
  our $VERSION = '0.04';
  
  use Sub::Exporter -setup => {
  	exports => [ qw(in_global_destruction) ],
  	groups  => { default => [ -all ] },
  };
  
  if (defined ${^GLOBAL_PHASE}) {
      eval 'sub in_global_destruction () { ${^GLOBAL_PHASE} eq q[DESTRUCT] }';
  }
  else {
      XSLoader::load(__PACKAGE__, $VERSION);
  }
  
  __PACKAGE__
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Devel::GlobalDestruction - Expose the flag which marks global
  destruction.
  
  =head1 SYNOPSIS
  
  	package Foo;
  	use Devel::GlobalDestruction;
  
  	use namespace::clean; # to avoid having an "in_global_destruction" method
  
  	sub DESTROY {
  		return if in_global_destruction;
  
  		do_something_a_little_tricky();
  	}
  
  =head1 DESCRIPTION
  
  Perl's global destruction is a little tricky to deal with WRT finalizers
  because it's not ordered and objects can sometimes disappear.
  
  Writing defensive destructors is hard and annoying, and usually if global
  destruction is happenning you only need the destructors that free up non
  process local resources to actually execute.
  
  For these constructors you can avoid the mess by simply bailing out if global
  destruction is in effect.
  
  =head1 EXPORTS
  
  This module uses L<Sub::Exporter> so the exports may be renamed, aliased, etc.
  
  =over 4
  
  =item in_global_destruction
  
  Returns true if the interpreter is in global destruction. In perl 5.14+, this
  returns C<${^GLOBAL_PHASE} eq 'DESTRUCT'>, and on earlier perls, it returns the
  current value of C<PL_dirty>.
  
  =back
  
  =head1 VERSION CONTROL
  
  This module is maintained using Darcs. You can get the latest version from
  L<http://nothingmuch.woobling.org/code>, and use C<darcs send> to commit
  changes.
  
  =head1 AUTHORS
  
  Yuval Kogman E<lt>nothingmuch@woobling.orgE<gt>
  
  Florian Ragwitz E<lt>rafl@debian.orgE<gt>
  
  Jesse Luehrs E<lt>doy@tozt.netE<gt>
  
  =head1 COPYRIGHT
  
  	Copyright (c) 2008 Yuval Kogman. All rights reserved
  	This program is free software; you can redistribute
  	it and/or modify it under the same terms as Perl itself.
  
  =cut
  
  
DEVEL_GLOBALDESTRUCTION

$fatpacked{"Eval/Closure.pm"} = <<'EVAL_CLOSURE';
  package Eval::Closure;
  BEGIN {
    $Eval::Closure::VERSION = '0.06';
  }
  use strict;
  use warnings;
  use Sub::Exporter -setup => {
      exports => [qw(eval_closure)],
      groups  => { default => [qw(eval_closure)] },
  };
  # ABSTRACT: safely and cleanly create closures via string eval
  
  use Carp;
  use overload ();
  use Scalar::Util qw(reftype);
  use Try::Tiny;
  
  
  
  sub eval_closure {
      my (%args) = @_;
  
      $args{source} = _canonicalize_source($args{source});
      _validate_env($args{environment} ||= {});
  
      $args{source} = _line_directive(@args{qw(line description)})
                    . $args{source}
          if defined $args{description} && !($^P & 0x10);
  
      my ($code, $e) = _clean_eval_closure(@args{qw(source environment)});
  
      if (!$code) {
          if ($args{terse_error}) {
              die "$e\n";
          }
          else {
              croak("Failed to compile source: $e\n\nsource:\n$args{source}")
          }
      }
  
      return $code;
  }
  
  sub _canonicalize_source {
      my ($source) = @_;
  
      if (defined($source)) {
          if (ref($source)) {
              if (reftype($source) eq 'ARRAY'
               || overload::Method($source, '@{}')) {
                  return join "\n", @$source;
              }
              elsif (overload::Method($source, '""')) {
                  return "$source";
              }
              else {
                  croak("The 'source' parameter to eval_closure must be a "
                      . "string or array reference");
              }
          }
          else {
              return $source;
          }
      }
      else {
          croak("The 'source' parameter to eval_closure is required");
      }
  }
  
  sub _validate_env {
      my ($env) = @_;
  
      croak("The 'environment' parameter must be a hashref")
          unless reftype($env) eq 'HASH';
  
      for my $var (keys %$env) {
          croak("Environment key '$var' should start with \@, \%, or \$")
              unless $var =~ /^([\@\%\$])/;
          croak("Environment values must be references, not $env->{$var}")
              unless ref($env->{$var});
      }
  }
  
  sub _line_directive {
      my ($line, $description) = @_;
  
      $line = 1 unless defined($line);
  
      return qq{#line $line "$description"\n};
  }
  
  sub _clean_eval_closure {
       my ($source, $captures) = @_;
  
      my @capture_keys = sort keys %$captures;
  
      if ($ENV{EVAL_CLOSURE_PRINT_SOURCE}) {
          _dump_source(_make_compiler_source($source, @capture_keys));
      }
  
      my ($compiler, $e) = _make_compiler($source, @capture_keys);
      my $code;
      if (defined $compiler) {
          $code = $compiler->(@$captures{@capture_keys});
      }
  
      if (defined($code) && (!ref($code) || ref($code) ne 'CODE')) {
          $e = "The 'source' parameter must return a subroutine reference, "
             . "not $code";
          undef $code;
      }
  
      return ($code, $e);
  }
  
  {
      my %compiler_cache;
  
      sub _make_compiler {
          my $source = _make_compiler_source(@_);
  
          unless (exists $compiler_cache{$source}) {
              local $@;
              local $SIG{__DIE__};
              my $compiler = eval $source;
              my $e = $@;
              $compiler_cache{$source} = [ $compiler, $e ];
          }
  
          return @{ $compiler_cache{$source} };
      }
  }
  
  sub _make_compiler_source {
      my ($source, @capture_keys) = @_;
      my $i = 0;
      return join "\n", (
          'sub {',
          (map {
              'my ' . $_ . ' = ' . substr($_, 0, 1) . '{$_[' . $i++ . ']};'
           } @capture_keys),
          $source,
          '}',
      );
  }
  
  sub _dump_source {
      my ($source) = @_;
  
      my $output;
      if (try { require Perl::Tidy }) {
          Perl::Tidy::perltidy(
              source      => \$source,
              destination => \$output,
              argv        => [],
          );
      }
      else {
          $output = $source;
      }
  
      warn "$output\n";
  }
  
  
  1;
  
  __END__
  =pod
  
  =head1 NAME
  
  Eval::Closure - safely and cleanly create closures via string eval
  
  =head1 VERSION
  
  version 0.06
  
  =head1 SYNOPSIS
  
    use Eval::Closure;
  
    my $code = eval_closure(
        source      => 'sub { $foo++ }',
        environment => {
            '$foo' => \1,
        },
    );
  
    warn $code->(); # 1
    warn $code->(); # 2
  
    my $code2 = eval_closure(
        source => 'sub { $code->() }',
    ); # dies, $code isn't in scope
  
  =head1 DESCRIPTION
  
  String eval is often used for dynamic code generation. For instance, C<Moose>
  uses it heavily, to generate inlined versions of accessors and constructors,
  which speeds code up at runtime by a significant amount. String eval is not
  without its issues however - it's difficult to control the scope it's used in
  (which determines which variables are in scope inside the eval), and it can be
  quite slow, especially if doing a large number of evals.
  
  This module attempts to solve both of those problems. It provides an
  C<eval_closure> function, which evals a string in a clean environment, other
  than a fixed list of specified variables. It also caches the result of the
  eval, so that doing repeated evals of the same source, even with a different
  environment, will be much faster (but note that the description is part of the
  string to be evaled, so it must also be the same (or non-existent) if caching
  is to work properly).
  
  =head1 FUNCTIONS
  
  =head2 eval_closure(%args)
  
  This function provides the main functionality of this module. It is exported by
  default. It takes a hash of parameters, with these keys being valid:
  
  =over 4
  
  =item source
  
  The string to be evaled. It should end by returning a code reference. It can
  access any variable declared in the C<environment> parameter (and only those
  variables). It can be either a string, or an arrayref of lines (which will be
  joined with newlines to produce the string).
  
  =item environment
  
  The environment to provide to the eval. This should be a hashref, mapping
  variable names (including sigils) to references of the appropriate type. For
  instance, a valid value for environment would be C<< { '@foo' => [] } >> (which
  would allow the generated function to use an array named C<@foo>). Generally,
  this is used to allow the generated function to access externally defined
  variables (so you would pass in a reference to a variable that already exists).
  
  =item description
  
  This lets you provide a bit more information in backtraces. Normally, when a
  function that was generated through string eval is called, that stack frame
  will show up as "(eval n)", where 'n' is a sequential identifier for every
  string eval that has happened so far in the program. Passing a C<description>
  parameter lets you override that to something more useful (for instance,
  L<Moose> overrides the description for accessors to something like "accessor
  foo at MyClass.pm, line 123").
  
  =item line
  
  This lets you override the particular line number that appears in backtraces,
  much like the C<description> option. The default is 1.
  
  =item terse_error
  
  Normally, this function appends the source code that failed to compile, and
  prepends some explanatory text. Setting this option to true suppresses that
  behavior so you get only the compilation error that Perl actually reported.
  
  =back
  
  =head1 BUGS
  
  No known bugs.
  
  Please report any bugs through RT: email
  C<bug-eval-closure at rt.cpan.org>, or browse to
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Eval-Closure>.
  
  =head1 SUPPORT
  
  You can find this documentation for this module with the perldoc command.
  
      perldoc Eval::Closure
  
  You can also look for information at:
  
  =over 4
  
  =item * AnnoCPAN: Annotated CPAN documentation
  
  L<http://annocpan.org/dist/Eval-Closure>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/d/Eval-Closure>
  
  =item * RT: CPAN's request tracker
  
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Eval-Closure>
  
  =item * Search CPAN
  
  L<http://search.cpan.org/dist/Eval-Closure>
  
  =back
  
  =head1 AUTHOR
  
  Jesse Luehrs <doy at tozt dot net>
  
  Based on code from L<Class::MOP::Method::Accessor>, by Stevan Little and the
  Moose Cabal.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<Class::MOP::Method::Accessor>
  
  This module is a factoring out of code that used to live here
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Jesse Luehrs.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
EVAL_CLOSURE

$fatpacked{"MRO/Compat.pm"} = <<'MRO_COMPAT';
  package MRO::Compat;
  use strict;
  use warnings;
  require 5.006_000;
  
  # Keep this < 1.00, so people can tell the fake
  #  mro.pm from the real one
  our $VERSION = '0.11';
  
  BEGIN {
      # Alias our private functions over to
      # the mro:: namespace and load
      # Class::C3 if Perl < 5.9.5
      if($] < 5.009_005) {
          $mro::VERSION # to fool Module::Install when generating META.yml
              = $VERSION;
          $INC{'mro.pm'} = __FILE__;
          *mro::import            = \&__import;
          *mro::get_linear_isa    = \&__get_linear_isa;
          *mro::set_mro           = \&__set_mro;
          *mro::get_mro           = \&__get_mro;
          *mro::get_isarev        = \&__get_isarev;
          *mro::is_universal      = \&__is_universal;
          *mro::method_changed_in = \&__method_changed_in;
          *mro::invalidate_all_method_caches
                                  = \&__invalidate_all_method_caches;
          require Class::C3;
          if($Class::C3::XS::VERSION && $Class::C3::XS::VERSION > 0.03) {
              *mro::get_pkg_gen   = \&__get_pkg_gen_c3xs;
          }
          else {
              *mro::get_pkg_gen   = \&__get_pkg_gen_pp;
          }
      }
  
      # Load mro.pm and provide no-op Class::C3::.*initialize() funcs for 5.9.5+
      else {
          require mro;
          no warnings 'redefine';
          *Class::C3::initialize = sub { 1 };
          *Class::C3::reinitialize = sub { 1 };
          *Class::C3::uninitialize = sub { 1 };
      }
  }
  
  =head1 NAME
  
  MRO::Compat - mro::* interface compatibility for Perls < 5.9.5
  
  =head1 SYNOPSIS
  
     package FooClass; use base qw/X Y Z/;
     package X;        use base qw/ZZZ/;
     package Y;        use base qw/ZZZ/;
     package Z;        use base qw/ZZZ/;
  
     package main;
     use MRO::Compat;
     my $linear = mro::get_linear_isa('FooClass');
     print join(q{, }, @$linear);
  
     # Prints: "FooClass, X, ZZZ, Y, Z"
  
  =head1 DESCRIPTION
  
  The "mro" namespace provides several utilities for dealing
  with method resolution order and method caching in general
  in Perl 5.9.5 and higher.
  
  This module provides those interfaces for
  earlier versions of Perl (back to 5.6.0 anyways).
  
  It is a harmless no-op to use this module on 5.9.5+.  That
  is to say, code which properly uses L<MRO::Compat> will work
  unmodified on both older Perls and 5.9.5+.
  
  If you're writing a piece of software that would like to use
  the parts of 5.9.5+'s mro:: interfaces that are supported
  here, and you want compatibility with older Perls, this
  is the module for you.
  
  Some parts of this code will work better and/or faster with
  L<Class::C3::XS> installed (which is an optional prereq
  of L<Class::C3>, which is in turn a prereq of this
  package), but it's not a requirement.
  
  This module never exports any functions.  All calls must
  be fully qualified with the C<mro::> prefix.
  
  The interface documentation here serves only as a quick
  reference of what the function basically does, and what
  differences between L<MRO::Compat> and 5.9.5+ one should
  look out for.  The main docs in 5.9.5's L<mro> are the real
  interface docs, and contain a lot of other useful information.
  
  =head1 Functions
  
  =head2 mro::get_linear_isa($classname[, $type])
  
  Returns an arrayref which is the linearized "ISA" of the given class.
  Uses whichever MRO is currently in effect for that class by default,
  or the given MRO (either C<c3> or C<dfs> if specified as C<$type>).
  
  The linearized ISA of a class is a single ordered list of all of the
  classes that would be visited in the process of resolving a method
  on the given class, starting with itself.  It does not include any
  duplicate entries.
  
  Note that C<UNIVERSAL> (and any members of C<UNIVERSAL>'s MRO) are not
  part of the MRO of a class, even though all classes implicitly inherit
  methods from C<UNIVERSAL> and its parents.
  
  =cut
  
  sub __get_linear_isa_dfs {
      no strict 'refs';
  
      my $classname = shift;
  
      my @lin = ($classname);
      my %stored;
      foreach my $parent (@{"$classname\::ISA"}) {
          my $plin = __get_linear_isa_dfs($parent);
          foreach (@$plin) {
              next if exists $stored{$_};
              push(@lin, $_);
              $stored{$_} = 1;
          }
      }
      return \@lin;
  }
  
  sub __get_linear_isa {
      my ($classname, $type) = @_;
      die "mro::get_mro requires a classname" if !defined $classname;
  
      $type ||= __get_mro($classname);
      if($type eq 'dfs') {
          return __get_linear_isa_dfs($classname);
      }
      elsif($type eq 'c3') {
          return [Class::C3::calculateMRO($classname)];
      }
      die "type argument must be 'dfs' or 'c3'";
  }
  
  =head2 mro::import
  
  This allows the C<use mro 'dfs'> and
  C<use mro 'c3'> syntaxes, providing you
  L<use MRO::Compat> first.  Please see the
  L</USING C3> section for additional details.
  
  =cut
  
  sub __import {
      if($_[1]) {
          goto &Class::C3::import if $_[1] eq 'c3';
          __set_mro(scalar(caller), $_[1]);
      }
  }
  
  =head2 mro::set_mro($classname, $type)
  
  Sets the mro of C<$classname> to one of the types
  C<dfs> or C<c3>.  Please see the L</USING C3>
  section for additional details.
  
  =cut
  
  sub __set_mro {
      my ($classname, $type) = @_;
  
      if(!defined $classname || !$type) {
          die q{Usage: mro::set_mro($classname, $type)};
      }
  
      if($type eq 'c3') {
          eval "package $classname; use Class::C3";
          die $@ if $@;
      }
      elsif($type eq 'dfs') {
          # In the dfs case, check whether we need to undo C3
          if(defined $Class::C3::MRO{$classname}) {
              Class::C3::_remove_method_dispatch_table($classname);
          }
          delete $Class::C3::MRO{$classname};
      }
      else {
          die qq{Invalid mro type "$type"};
      }
  
      return;
  }
  
  =head2 mro::get_mro($classname)
  
  Returns the MRO of the given class (either C<c3> or C<dfs>).
  
  It considers any Class::C3-using class to have C3 MRO
  even before L<Class::C3::initialize()> is called.
  
  =cut
  
  sub __get_mro {
      my $classname = shift;
      die "mro::get_mro requires a classname" if !defined $classname;
      return 'c3' if exists $Class::C3::MRO{$classname};
      return 'dfs';
  }
  
  =head2 mro::get_isarev($classname)
  
  Returns an arrayref of classes who are subclasses of the
  given classname.  In other words, classes in whose @ISA
  hierarchy we appear, no matter how indirectly.
  
  This is much slower on pre-5.9.5 Perls with MRO::Compat
  than it is on 5.9.5+, as it has to search the entire
  package namespace.
  
  =cut
  
  sub __get_all_pkgs_with_isas {
      no strict 'refs';
      no warnings 'recursion';
  
      my @retval;
  
      my $search = shift;
      my $pfx;
      my $isa;
      if(defined $search) {
          $isa = \@{"$search\::ISA"};
          $pfx = "$search\::";
      }
      else {
          $search = 'main';
          $isa = \@main::ISA;
          $pfx = '';
      }
  
      push(@retval, $search) if scalar(@$isa);
  
      foreach my $cand (keys %{"$search\::"}) {
          if($cand =~ s/::$//) {
              next if $cand eq $search; # skip self-reference (main?)
              push(@retval, @{__get_all_pkgs_with_isas($pfx . $cand)});
          }
      }
  
      return \@retval;
  }
  
  sub __get_isarev_recurse {
      no strict 'refs';
  
      my ($class, $all_isas, $level) = @_;
  
      die "Recursive inheritance detected" if $level > 100;
  
      my %retval;
  
      foreach my $cand (@$all_isas) {
          my $found_me;
          foreach (@{"$cand\::ISA"}) {
              if($_ eq $class) {
                  $found_me = 1;
                  last;
              }
          }
          if($found_me) {
              $retval{$cand} = 1;
              map { $retval{$_} = 1 }
                  @{__get_isarev_recurse($cand, $all_isas, $level+1)};
          }
      }
      return [keys %retval];
  }
  
  sub __get_isarev {
      my $classname = shift;
      die "mro::get_isarev requires a classname" if !defined $classname;
  
      __get_isarev_recurse($classname, __get_all_pkgs_with_isas(), 0);
  }
  
  =head2 mro::is_universal($classname)
  
  Returns a boolean status indicating whether or not
  the given classname is either C<UNIVERSAL> itself,
  or one of C<UNIVERSAL>'s parents by C<@ISA> inheritance.
  
  Any class for which this function returns true is
  "universal" in the sense that all classes potentially
  inherit methods from it.
  
  =cut
  
  sub __is_universal {
      my $classname = shift;
      die "mro::is_universal requires a classname" if !defined $classname;
  
      my $lin = __get_linear_isa('UNIVERSAL');
      foreach (@$lin) {
          return 1 if $classname eq $_;
      }
  
      return 0;
  }
  
  =head2 mro::invalidate_all_method_caches
  
  Increments C<PL_sub_generation>, which invalidates method
  caching in all packages.
  
  Please note that this is rarely necessary, unless you are
  dealing with a situation which is known to confuse Perl's
  method caching.
  
  =cut
  
  sub __invalidate_all_method_caches {
      # Super secret mystery code :)
      @f845a9c1ac41be33::ISA = @f845a9c1ac41be33::ISA;
      return;
  }
  
  =head2 mro::method_changed_in($classname)
  
  Invalidates the method cache of any classes dependent on the
  given class.  In L<MRO::Compat> on pre-5.9.5 Perls, this is
  an alias for C<mro::invalidate_all_method_caches> above, as
  pre-5.9.5 Perls have no other way to do this.  It will still
  enforce the requirement that you pass it a classname, for
  compatibility.
  
  Please note that this is rarely necessary, unless you are
  dealing with a situation which is known to confuse Perl's
  method caching.
  
  =cut
  
  sub __method_changed_in {
      my $classname = shift;
      die "mro::method_changed_in requires a classname" if !defined $classname;
  
      __invalidate_all_method_caches();
  }
  
  =head2 mro::get_pkg_gen($classname)
  
  Returns an integer which is incremented every time a local
  method of or the C<@ISA> of the given package changes on
  Perl 5.9.5+.  On earlier Perls with this L<MRO::Compat> module,
  it will probably increment a lot more often than necessary.
  
  =cut
  
  {
      my $__pkg_gen = 2;
      sub __get_pkg_gen_pp {
          my $classname = shift;
          die "mro::get_pkg_gen requires a classname" if !defined $classname;
          return $__pkg_gen++;
      }
  }
  
  sub __get_pkg_gen_c3xs {
      my $classname = shift;
      die "mro::get_pkg_gen requires a classname" if !defined $classname;
  
      return Class::C3::XS::_plsubgen();
  }
  
  =head1 USING C3
  
  While this module makes the 5.9.5+ syntaxes
  C<use mro 'c3'> and C<mro::set_mro("Foo", 'c3')> available
  on older Perls, it does so merely by passing off the work
  to L<Class::C3>.
  
  It does not remove the need for you to call
  C<Class::C3::initialize()>, C<Class::C3::reinitialize()>, and/or
  C<Class::C3::uninitialize()> at the appropriate times
  as documented in the L<Class::C3> docs.  These three functions
  are always provided by L<MRO::Compat>, either via L<Class::C3>
  itself on older Perls, or directly as no-ops on 5.9.5+.
  
  =head1 SEE ALSO
  
  L<Class::C3>
  
  L<mro>
  
  =head1 AUTHOR
  
  Brandon L. Black, E<lt>blblack@gmail.comE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2007-2008 Brandon L. Black E<lt>blblack@gmail.comE<gt>
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
  
  1;
MRO_COMPAT

$fatpacked{"MahewinWmfsStatus.pm"} = <<'MAHEWINWMFSSTATUS';
  package MahewinWmfsStatus;
  
  use Moose;
  
  use Sys::Statistics::Linux;
  use Sys::Statistics::Linux::DiskUsage;
  use Config::IniFiles;
  
  has _file_path => (
      is      => 'ro',
      isa     => 'Str',
      lazy    => 1,
      builder => '_build_file_path'
  );
  
  has _user_infos => (
      is      => 'ro',
      isa     => 'ArrayRef',
      lazy    => 1,
      builder => '_build_user_infos'
  );
  
  has _config => (
      is      => 'ro',
      isa     => 'Config::IniFiles',
      lazy    => 1,
      builder => '_build_config'
  );
  
  has _lxs => (
      is      => 'ro',
      isa     => 'Sys::Statistics::Linux',
      lazy    => 1,
      builder => '_build_lxs',
  );
  
  sub _build_file_path {
      if ( exists $ENV{HOME} && defined $ENV{HOME} ) {
          return $ENV{HOME};
      }
  
      if ( $ENV{LOGDIR} ) {
          return $ENV{LOGDIR};
      }
  
      return '';
  }
  
  sub _build_user_infos {
      my @infos;
  
      open (PASSWD, "< /etc/passwd");
      while (<PASSWD>) {
          @infos = split /:/;
          last if $infos[0] eq $ENV{LOGNAME};
      }
      close(PASSWD);
  
      return \@infos;
  }
  
  sub _build_config {
      my ( $self ) = @_;
  
      my $home = $self->_file_path;
  
      my $cfg  = Config::IniFiles->new(
          -file => "$home/.config/wmfs/mahewin-wmfs-statusrc"
      );
  
      $cfg;
  }
  
  sub _build_lxs {
      return Sys::Statistics::Linux->new(
          memstats  => 1,
      );
  }
  
  sub free {
      my ( $self ) = @_;
  
      my $stat     = $self->_lxs->get;
      my $memfree  = $stat->memstats->{memfree};
      my $memused  = $stat->memstats->{memused};
      my $memtotal = $stat->memstats->{memtotal};
  
      my $format = $self->_config->val('memory', 'format') || 'string';
  
      my $free = $self->_stringify( 'memory', 'Mem: ' . int($memfree / 1024) . '/' . int($memused / 1024) );
  
      if ( $format eq 'percent' ) {
          my $free_usage = sprintf("%0.2f", int($memused / 1024) / int($memtotal / 1024 ) * 100);
          $free = $self->_stringify( 'memory', 'Mem: ' . $free_usage . '%' );
      }
  
      return $free;
  }
  
  sub disk_space {
      my ( $self ) = @_;
  
      my $disk_usage = Sys::Statistics::Linux::DiskUsage->new(
          cmd => {
              # This is the default
              df   => 'df -hP 2>/dev/null',
          }
      );
  
      my $stat = $disk_usage->get;
  
      my $format    = $self->_config->val('disk', 'format') || 'string';
      my $disk_path = $self->_config->val('disk', 'disk_path') || '/dev/sda1';
  
      my $disk      = $self->_stringify( 'disk', 'Disk: ' . $stat->{$disk_path}->{usage} . '/' . $stat->{$disk_path}->{free} );
  
      if ( $format eq 'percent' ) {
          my @usage = split(/G/, $stat->{$disk_path}->{usage});
          my @total = split(/G/, $stat->{$disk_path}->{total});
          $usage[0] =~ s/,/./;
          $total[0] =~ s/,/./;
  
          my $disk_usage = sprintf("%0.2f", $usage[0] / $total[0] * 100);
          $disk = $self->_stringify( 'disk', 'Disk: ' . $disk_usage . '%' );
      }
  
      return $disk;
  }
  
  sub time_date {
      my ( $self ) = @_;
  
      my $format = $self->_config->val('date', 'format') || '%Y/%m/%d %H:%M:%S';
  
      $self->_lxs->settime($format);
  
      return $self->_stringify( 'date', 'Date: ' . $self->_lxs->gettime );
  }
  
  sub name {
      my ( $self ) = @_;
  
      my $infos = $self->_user_infos;
      my @name  = split(/,/, $infos->[4]);
  
      return $self->_stringify( 'name', $name[0] );
  }
  
  sub status {
      my ( $self ) = @_;
  
      my $cfg = $self->_config;
      my @call;
  
      my @sections = $self->_config->Sections();
      my $dispatch = {
          memory => $self->free(),
          disk   => $self->disk_space(),
          date   => $self->time_date(),
          name   => $self->name()
      };
  
      foreach my $section (@sections) {
          next if $section eq 'misc';
  
          $call[$cfg->val($section, 'position')] = $dispatch->{$section}
              if $cfg->val($section, 'display');
      }
  
      `wmfs -c status "default @call"`;
  }
  
  sub _stringify {
      my ( $self, $type, $string ) = @_;
  
      my $cfg = $self->_config;
  
      my $color  = $cfg->val( $type, 'color')
          ? $cfg->val( $type, 'color')
          : $cfg->val('misc', 'color');
  
      my $final = "^s[right;$color;$string]";
  
      return $final;
  }
  
  sub run {
      my ( $self ) = @_;
  
      my $timing = $self->_config->val('misc', 'timing') || 1;
  
      while ( 1 ) {
          sleep( $timing );
          $self->status();
      }
  }
  
  1;
MAHEWINWMFSSTATUS

$fatpacked{"Module/Runtime.pm"} = <<'MODULE_RUNTIME';
  =head1 NAME
  
  Module::Runtime - runtime module handling
  
  =head1 SYNOPSIS
  
  	use Module::Runtime qw(
  		$module_name_rx is_module_name check_module_name
  		module_notional_filename require_module
  	);
  
  	if($module_name =~ /\A$module_name_rx\z/o) { ...
  	if(is_module_name($module_name)) { ...
  	check_module_name($module_name);
  
  	$notional_filename = module_notional_filename($module_name);
  	require_module($module_name);
  
  	use Module::Runtime qw(use_module use_package_optimistically);
  
  	$bi = use_module("Math::BigInt", 1.31)->new("1_234");
  	$widget = use_package_optimistically("Local::Widget")->new;
  
  	use Module::Runtime qw(
  		$top_module_spec_rx $sub_module_spec_rx
  		is_module_spec check_module_spec
  		compose_module_name
  	);
  
  	if($spec =~ /\A$top_module_spec_rx\z/o) { ...
  	if($spec =~ /\A$sub_module_spec_rx\z/o) { ...
  	if(is_module_spec("Standard::Prefix", $spec)) { ...
  	check_module_spec("Standard::Prefix", $spec);
  
  	$module_name =
  		compose_module_name("Standard::Prefix", $spec);
  
  =head1 DESCRIPTION
  
  The functions exported by this module deal with runtime handling of Perl
  modules, which are normally handled at compile time.
  
  =cut
  
  package Module::Runtime;
  
  { use 5.006; }
  use warnings;
  use strict;
  
  use Params::Classify 0.000 qw(is_string);
  
  our $VERSION = "0.011";
  
  use parent "Exporter";
  our @EXPORT_OK = qw(
  	$module_name_rx is_module_name is_valid_module_name check_module_name
  	module_notional_filename require_module
  	use_module use_package_optimistically
  	$top_module_spec_rx $sub_module_spec_rx
  	is_module_spec is_valid_module_spec check_module_spec
  	compose_module_name
  );
  
  =head1 REGULAR EXPRESSIONS
  
  These regular expressions do not include any anchors, so to check
  whether an entire string matches a syntax item you must supply the
  anchors yourself.
  
  =over
  
  =item $module_name_rx
  
  Matches a valid Perl module name in bareword syntax.
  The rule for this, precisely, is: the string must
  consist of one or more segments separated by C<::>; each segment must
  consist of one or more identifier characters (alphanumerics plus "_");
  the first character of the string must not be a digit.  Thus "C<IO::File>",
  "C<warnings>", and "C<foo::123::x_0>" are all valid module names, whereas
  "C<IO::>" and "C<1foo::bar>" are not.
  Only ASCII characters are permitted; Perl's handling of non-ASCII
  characters in source code is inconsistent.
  C<'> separators are not permitted.
  
  =cut
  
  our $module_name_rx = qr/[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*/;
  
  =item $top_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where no prefix is being used.
  
  =cut
  
  my $qual_module_spec_rx =
  	qr#(?:/|::)[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  my $unqual_top_module_spec_rx =
  	qr#[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $top_module_spec_rx = qr/$qual_module_spec_rx|$unqual_top_module_spec_rx/o;
  
  =item $sub_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where a prefix is being used.
  
  =cut
  
  my $unqual_sub_module_spec_rx = qr#[0-9A-Z_a-z]+(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $sub_module_spec_rx = qr/$qual_module_spec_rx|$unqual_sub_module_spec_rx/o;
  
  =back
  
  =head1 FUNCTIONS
  
  =head2 Basic module handling
  
  =over
  
  =item is_module_name(ARG)
  
  Returns a truth value indicating whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  
  =cut
  
  sub is_module_name($) { is_string($_[0]) && $_[0] =~ /\A$module_name_rx\z/o }
  
  =item is_valid_module_name(ARG)
  
  Deprecated alias for L</is_module_name>.
  
  =cut
  
  *is_valid_module_name = \&is_module_name;
  
  =item check_module_name(ARG)
  
  Check whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_name($) {
  	unless(&is_module_name) {
  		die +(is_string($_[0]) ? "`$_[0]'" : "argument").
  			" is not a module name\n";
  	}
  }
  
  =item module_notional_filename(NAME)
  
  Generates a notional relative filename for a module, which is used in
  some Perl core interfaces.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The notional filename for the named module is generated and returned.
  This filename is always in Unix style, with C</> directory separators
  and a C<.pm> suffix.  This kind of filename can be used as an argument to
  C<require>, and is the key that appears in C<%INC> to identify a module,
  regardless of actual local filename syntax.
  
  =cut
  
  sub module_notional_filename($) {
  	&check_module_name;
  	my($name) = @_;
  	$name =~ s!::!/!g;
  	return $name.".pm";
  }
  
  =item require_module(NAME)
  
  This is essentially the bareword form of C<require>, in runtime form.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The module specified by I<NAME> is loaded, if it hasn't been already,
  in the manner of the bareword form of C<require>.  That means that a
  search through C<@INC> is performed, and a byte-compiled form of the
  module will be used if available.
  
  The return value is as for C<require>.  That is, it is the value returned
  by the module itself if the module is loaded anew, or C<1> if the module
  was already loaded.
  
  =cut
  
  sub require_module($) {
  	# Explicit scalar() here works around a Perl core bug, present
  	# in Perl 5.8 and 5.10, which allowed a require() in return
  	# position to pass a non-scalar context through to file scope
  	# of the required file.  This breaks some modules.  require()
  	# in any other position, where its op flags determine context
  	# statically, doesn't have this problem, because the op flags
  	# are forced to scalar.
  	return scalar(require(&module_notional_filename));
  }
  
  =back
  
  =head2 Structured module use
  
  =over
  
  =item use_module(NAME[, VERSION])
  
  This is essentially C<use> in runtime form, but without the importing
  feature (which is fundamentally a compile-time thing).  The I<NAME> is
  handled just like in C<require_module> above: it must be a module name,
  and the named module is loaded as if by the bareword form of C<require>.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded module is
  called with the specified I<VERSION> as an argument.  This normally serves to
  ensure that the version loaded is at least the version required.  This is
  the same functionality provided by the I<VERSION> parameter of C<use>.
  
  On success, the name of the module is returned.  This is unlike
  L</require_module>, and is done so that the entire call to L</use_module>
  can be used as a class name to call a constructor, as in the example in
  the synopsis.
  
  =cut
  
  sub use_module($;$) {
  	my($name, $version) = @_;
  	require_module($name);
  	if(defined $version) {
  		$name->VERSION($version);
  	}
  	return $name;
  }
  
  =item use_package_optimistically(NAME[, VERSION])
  
  This is an analogue of L</use_module> for the situation where there is
  uncertainty as to whether a package/class is defined in its own module
  or by some other means.  It attempts to arrange for the named package to
  be available, either by loading a module or by doing nothing and hoping.
  
  An attempt is made to load the named module (as if by the bareword form
  of C<require>).  If the module cannot be found then it is assumed that
  the package was actually already loaded but wasn't detected correctly,
  and no error is signalled.  That's the optimistic bit.
  
  This is mostly the same operation that is performed by the L<base> pragma
  to ensure that the specified base classes are available.  The behaviour
  of L<base> was simplified in version 2.18, and this function changed
  to match.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded package is
  called with the specified I<VERSION> as an argument.  This normally serves
  to ensure that the version loaded is at least the version required.
  On success, the name of the package is returned.  These aspects of the
  function work just like L</use_module>.
  
  =cut
  
  sub use_package_optimistically($;$) {
  	my($name, $version) = @_;
  	check_module_name($name);
  	eval { local $SIG{__DIE__}; require(module_notional_filename($name)); };
  	die $@ if $@ ne "" && $@ !~ /\A
  		Can't\ locate\ .+\ at
  		\ \Q@{[__FILE__]}\E\ line\ \Q@{[__LINE__-1]}\E
  	/xs;
  	$name->VERSION($version) if defined $version;
  	return $name;
  }
  
  =back
  
  =head2 Module name composition
  
  =over
  
  =item is_module_spec(PREFIX, SPEC)
  
  Returns a truth value indicating
  whether I<SPEC> is valid input for L</compose_module_name>.
  See below for what that entails.  Whether a I<PREFIX> is supplied affects
  the validity of I<SPEC>, but the exact value of the prefix is unimportant,
  so this function treats I<PREFIX> as a truth value.
  
  =cut
  
  sub is_module_spec($$) {
  	my($prefix, $spec) = @_;
  	return is_string($spec) &&
  		$spec =~ ($prefix ? qr/\A$sub_module_spec_rx\z/o :
  				    qr/\A$top_module_spec_rx\z/o);
  }
  
  =item is_valid_module_spec(PREFIX, SPEC)
  
  Deprecated alias for L</is_module_spec>.
  
  =cut
  
  *is_valid_module_spec = \&is_module_spec;
  
  =item check_module_spec(PREFIX, SPEC)
  
  Check whether I<SPEC> is valid input for L</compose_module_name>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_spec($$) {
  	unless(&is_module_spec) {
  		die +(is_string($_[1]) ? "`$_[1]'" : "argument").
  			" is not a module specification\n";
  	}
  }
  
  =item compose_module_name(PREFIX, SPEC)
  
  This function is intended to make it more convenient for a user to specify
  a Perl module name at runtime.  Users have greater need for abbreviations
  and context-sensitivity than programmers, and Perl module names get a
  little unwieldy.  I<SPEC> is what the user specifies, and this function
  translates it into a module name in standard form, which it returns.
  
  I<SPEC> has syntax approximately that of a standard module name: it
  should consist of one or more name segments, each of which consists
  of one or more identifier characters.  However, C</> is permitted as a
  separator, in addition to the standard C<::>.  The two separators are
  entirely interchangeable.
  
  Additionally, if I<PREFIX> is not C<undef> then it must be a module
  name in standard form, and it is prefixed to the user-specified name.
  The user can inhibit the prefix addition by starting I<SPEC> with a
  separator (either C</> or C<::>).
  
  =cut
  
  sub compose_module_name($$) {
  	my($prefix, $spec) = @_;
  	check_module_name($prefix) if defined $prefix;
  	&check_module_spec;
  	if($spec =~ s#\A(?:/|::)##) {
  		# OK
  	} else {
  		$spec = $prefix."::".$spec if defined $prefix;
  	}
  	$spec =~ s#/#::#g;
  	return $spec;
  }
  
  =back
  
  =head1 SEE ALSO
  
  L<base>,
  L<perlfunc/require>,
  L<perlfunc/use>
  
  =head1 AUTHOR
  
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2004, 2006, 2007, 2009, 2010, 2011
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
  1;
MODULE_RUNTIME

$fatpacked{"Package/DeprecationManager.pm"} = <<'PACKAGE_DEPRECATIONMANAGER';
  package Package::DeprecationManager;
  BEGIN {
    $Package::DeprecationManager::VERSION = '0.11';
  }
  
  use strict;
  use warnings;
  
  use Carp qw( croak );
  use List::MoreUtils qw( any );
  use Params::Util qw( _HASH0 );
  use Sub::Install;
  
  sub import {
      shift;
      my %args = @_;
  
      croak
          'You must provide a hash reference -deprecations parameter when importing Package::DeprecationManager'
          unless $args{-deprecations} && _HASH0( $args{-deprecations} );
  
      my %registry;
  
      my $import = _build_import( \%registry );
      my $warn = _build_warn( \%registry, $args{-deprecations}, $args{-ignore} );
  
      my $caller = caller();
  
      Sub::Install::install_sub(
          {
              code => $import,
              into => $caller,
              as   => 'import',
          }
      );
  
      Sub::Install::install_sub(
          {
              code => $warn,
              into => $caller,
              as   => 'deprecated',
          }
      );
  
      return;
  }
  
  sub _build_import {
      my $registry = shift;
  
      return sub {
          my $class = shift;
          my %args  = @_;
  
          $args{-api_version} ||= delete $args{-compatible};
  
          $registry->{ caller() } = $args{-api_version}
              if $args{-api_version};
  
          return;
      };
  }
  
  sub _build_warn {
      my $registry      = shift;
      my $deprecated_at = shift;
      my $ignore        = shift;
  
      my %ignore = map { $_ => 1 } grep { !ref } @{ $ignore || [] };
      my @ignore_res = grep {ref} @{ $ignore || [] };
  
      my %warned;
  
      return sub {
          my %args = @_ < 2 ? ( message => shift ) : @_;
  
          my ( $package, undef, undef, $sub ) = caller(1);
  
          my $skipped = 1;
  
          if ( @ignore_res || keys %ignore ) {
              while ( defined $package
                  && ( $ignore{$package} || any { $package =~ $_ } @ignore_res )
                  ) {
                  $package = caller( $skipped++ );
              }
          }
  
          $package = 'unknown package' unless defined $package;
  
          unless ( defined $args{feature} ) {
              $args{feature} = $sub;
          }
  
          my $compat_version = $registry->{$package};
  
          my $deprecated_at = $deprecated_at->{ $args{feature} };
  
          return
              if defined $compat_version
                  && defined $deprecated_at
                  && $compat_version lt $deprecated_at;
  
          my $msg;
          if ( defined $args{message} ) {
              $msg = $args{message};
          }
          else {
              $msg = "$args{feature} has been deprecated";
              $msg .= " since version $deprecated_at"
                  if defined $deprecated_at;
          }
  
          return if $warned{$package}{ $args{feature} }{$msg};
  
          $warned{$package}{ $args{feature} }{$msg} = 1;
  
          # We skip at least two levels. One for this anon sub, and one for the
          # sub calling it.
          local $Carp::CarpLevel = $Carp::CarpLevel + $skipped;
  
          Carp::cluck($msg);
      };
  }
  
  1;
  
  # ABSTRACT: Manage deprecation warnings for your distribution
  
  
  
  =pod
  
  =head1 NAME
  
  Package::DeprecationManager - Manage deprecation warnings for your distribution
  
  =head1 VERSION
  
  version 0.11
  
  =head1 SYNOPSIS
  
    package My::Class;
  
    use Package::DeprecationManager -deprecations => {
        'My::Class::foo' => '0.02',
        'My::Class::bar' => '0.05',
        'feature-X'      => '0.07',
    };
  
    sub foo {
        deprecated( 'Do not call foo!' );
  
        ...
    }
  
    sub bar {
        deprecated();
  
        ...
    }
  
    sub baz {
        my %args = @_;
  
        if ( $args{foo} ) {
            deprecated(
                message => ...,
                feature => 'feature-X',
            );
        }
    }
  
    package Other::Class;
  
    use My::Class -api_version => '0.04';
  
    My::Class->new()->foo(); # warns
    My::Class->new()->bar(); # does not warn
    My::Class->new()->far(); # does not warn again
  
  =head1 DESCRIPTION
  
  This module allows you to manage a set of deprecations for one or more modules.
  
  When you import C<Package::DeprecationManager>, you must provide a set of
  C<-deprecations> as a hash ref. The keys are "feature" names, and the values
  are the version when that feature was deprecated.
  
  In many cases, you can simply use the fully qualified name of a subroutine or
  method as the feature name. This works for cases where the whole subroutine is
  deprecated. However, the feature names can be any string. This is useful if
  you don't want to deprecate an entire subroutine, just a certain usage.
  
  You can also provide an optional array reference in the C<-ignore>
  parameter.
  
  The values to be ignored can be package names or regular expressions (made
  with C<qr//>).  Use this to ignore packages in your distribution that can
  appear on the call stack when a deprecated feature is used.
  
  As part of the import process, C<Package::DeprecationManager> will export two
  subroutines into its caller. It provides an C<import()> sub for the caller and a
  C<deprecated()> sub.
  
  The C<import()> sub allows callers of I<your> class to specify an C<-api_version>
  parameter. If this is supplied, then deprecation warnings are only issued for
  deprecations for api versions earlier than the one specified.
  
  You must call the C<deprecated()> sub in each deprecated subroutine. When
  called, it will issue a warning using C<Carp::cluck()>.
  
  The C<deprecated()> sub can be called in several ways. If you do not pass any
  arguments, it will generate an appropriate warning message. If you pass a
  single argument, this is used as the warning message.
  
  Finally, you can call it with named arguments. Currently, the only allowed
  names are C<message> and C<feature>. The C<feature> argument should correspond
  to the feature name passed in the C<-deprecations> hash.
  
  If you don't explicitly specify a feature, the C<deprecated()> sub uses
  C<caller()> to identify its caller, using its fully qualified subroutine name.
  
  A given deprecation warning is only issued once for a given package. This
  module tracks this based on both the feature name I<and> the error message
  itself. This means that if you provide severaldifferent error messages for the
  same feature, all of those errors will appear.
  
  =head1 BUGS
  
  Please report any bugs or feature requests to
  C<bug-package-deprecationmanager@rt.cpan.org>, or through the web interface at
  L<http://rt.cpan.org>.  I will be notified, and then you'll automatically be
  notified of progress on your bug as I make changes.
  
  =head1 DONATIONS
  
  If you'd like to thank me for the work I've done on this module, please
  consider making a "donation" to me via PayPal. I spend a lot of free time
  creating free software, and would appreciate any support you'd care to offer.
  
  Please note that B<I am not suggesting that you must do this> in order
  for me to continue working on this particular software. I will
  continue to do so, inasmuch as I have in the past, for as long as it
  interests me.
  
  Similarly, a donation made in this way will probably not make me work on this
  software much more, unless I get so many donations that I can consider working
  on free software full time, which seems unlikely at best.
  
  To donate, log into PayPal and send money to autarch@urth.org or use the
  button on this page: L<http://www.urth.org/~autarch/fs-donation.html>
  
  =head1 CREDITS
  
  The idea for this functionality and some of its implementation was originally
  created as L<Class::MOP::Deprecated> by Goro Fuji.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2011 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  =cut
  
  
  __END__
  
PACKAGE_DEPRECATIONMANAGER

$fatpacked{"Package/Stash.pm"} = <<'PACKAGE_STASH';
  package Package::Stash;
  {
    $Package::Stash::VERSION = '0.33';
  }
  use strict;
  use warnings;
  # ABSTRACT: routines for manipulating stashes
  
  our $IMPLEMENTATION;
  
  BEGIN {
      $IMPLEMENTATION = $ENV{PACKAGE_STASH_IMPLEMENTATION}
          if exists $ENV{PACKAGE_STASH_IMPLEMENTATION};
  
      my $err;
      if ($IMPLEMENTATION) {
          if (!eval "require Package::Stash::$IMPLEMENTATION; 1") {
              require Carp;
              Carp::croak("Could not load Package::Stash::$IMPLEMENTATION: $@");
          }
      }
      else {
          for my $impl ('XS', 'PP') {
              if (eval "require Package::Stash::$impl; 1;") {
                  $IMPLEMENTATION = $impl;
                  last;
              }
              else {
                  $err .= $@;
              }
          }
      }
  
      if (!$IMPLEMENTATION) {
          require Carp;
          Carp::croak("Could not find a suitable Package::Stash implementation: $err");
      }
  
      my $impl = "Package::Stash::$IMPLEMENTATION";
      my $from = $impl->new($impl);
      my $to = $impl->new(__PACKAGE__);
      my $methods = $from->get_all_symbols('CODE');
      for my $meth (keys %$methods) {
          $to->add_symbol("&$meth" => $methods->{$meth});
      }
  }
  
  use Package::DeprecationManager -deprecations => {
      'Package::Stash::add_package_symbol'        => 0.14,
      'Package::Stash::remove_package_glob'       => 0.14,
      'Package::Stash::has_package_symbol'        => 0.14,
      'Package::Stash::get_package_symbol'        => 0.14,
      'Package::Stash::get_or_add_package_symbol' => 0.14,
      'Package::Stash::remove_package_symbol'     => 0.14,
      'Package::Stash::list_all_package_symbols'  => 0.14,
  };
  
  sub add_package_symbol {
      #deprecated('add_package_symbol is deprecated, please use add_symbol');
      shift->add_symbol(@_);
  }
  
  sub remove_package_glob {
      #deprecated('remove_package_glob is deprecated, please use remove_glob');
      shift->remove_glob(@_);
  }
  
  sub has_package_symbol {
      #deprecated('has_package_symbol is deprecated, please use has_symbol');
      shift->has_symbol(@_);
  }
  
  sub get_package_symbol {
      #deprecated('get_package_symbol is deprecated, please use get_symbol');
      shift->get_symbol(@_);
  }
  
  sub get_or_add_package_symbol {
      #deprecated('get_or_add_package_symbol is deprecated, please use get_or_add_symbol');
      shift->get_or_add_symbol(@_);
  }
  
  sub remove_package_symbol {
      #deprecated('remove_package_symbol is deprecated, please use remove_symbol');
      shift->remove_symbol(@_);
  }
  
  sub list_all_package_symbols {
      #deprecated('list_all_package_symbols is deprecated, please use list_all_symbols');
      shift->list_all_symbols(@_);
  }
  
  
  1;
  
  __END__
  =pod
  
  =head1 NAME
  
  Package::Stash - routines for manipulating stashes
  
  =head1 VERSION
  
  version 0.33
  
  =head1 SYNOPSIS
  
    my $stash = Package::Stash->new('Foo');
    $stash->add_symbol('%foo', {bar => 1});
    # $Foo::foo{bar} == 1
    $stash->has_symbol('$foo') # false
    my $namespace = $stash->namespace;
    *{ $namespace->{foo} }{HASH} # {bar => 1}
  
  =head1 DESCRIPTION
  
  Manipulating stashes (Perl's symbol tables) is occasionally necessary, but
  incredibly messy, and easy to get wrong. This module hides all of that behind a
  simple API.
  
  NOTE: Most methods in this class require a variable specification that includes
  a sigil. If this sigil is absent, it is assumed to represent the IO slot.
  
  Due to limitations in the typeglob API available to perl code, and to typeglob
  manipulation in perl being quite slow, this module provides two
  implementations - one in pure perl, and one using XS. The XS implementation is
  to be preferred for most usages; the pure perl one is provided for cases where
  XS modules are not a possibility. The current implementation in use can be set
  by setting C<$ENV{PACKAGE_STASH_IMPLEMENTATION}> or
  C<$Package::Stash::IMPLEMENTATION> before loading Package::Stash (with the
  environment variable taking precedence), otherwise, it will use the XS
  implementation if possible, falling back to the pure perl one.
  
  =head1 METHODS
  
  =head2 new $package_name
  
  Creates a new C<Package::Stash> object, for the package given as the only
  argument.
  
  =head2 name
  
  Returns the name of the package that this object represents.
  
  =head2 namespace
  
  Returns the raw stash itself.
  
  =head2 add_symbol $variable $value %opts
  
  Adds a new package symbol, for the symbol given as C<$variable>, and optionally
  gives it an initial value of C<$value>. C<$variable> should be the name of
  variable including the sigil, so
  
    Package::Stash->new('Foo')->add_symbol('%foo')
  
  will create C<%Foo::foo>.
  
  Valid options (all optional) are C<filename>, C<first_line_num>, and
  C<last_line_num>.
  
  C<$opts{filename}>, C<$opts{first_line_num}>, and C<$opts{last_line_num}> can
  be used to indicate where the symbol should be regarded as having been defined.
  Currently these values are only used if the symbol is a subroutine ('C<&>'
  sigil) and only if C<$^P & 0x10> is true, in which case the special C<%DB::sub>
  hash is updated to record the values of C<filename>, C<first_line_num>, and
  C<last_line_num> for the subroutine. If these are not passed, their values are
  inferred (as much as possible) from C<caller> information.
  
  This is especially useful for debuggers and profilers, which use C<%DB::sub> to
  determine where the source code for a subroutine can be found.  See
  L<http://perldoc.perl.org/perldebguts.html#Debugger-Internals> for more
  information about C<%DB::sub>.
  
  =head2 remove_glob $name
  
  Removes all package variables with the given name, regardless of sigil.
  
  =head2 has_symbol $variable
  
  Returns whether or not the given package variable (including sigil) exists.
  
  =head2 get_symbol $variable
  
  Returns the value of the given package variable (including sigil).
  
  =head2 get_or_add_symbol $variable
  
  Like C<get_symbol>, except that it will return an empty hashref or
  arrayref if the variable doesn't exist.
  
  =head2 remove_symbol $variable
  
  Removes the package variable described by C<$variable> (which includes the
  sigil); other variables with the same name but different sigils will be
  untouched.
  
  =head2 list_all_symbols $type_filter
  
  Returns a list of package variable names in the package, without sigils. If a
  C<type_filter> is passed, it is used to select package variables of a given
  type, where valid types are the slots of a typeglob ('SCALAR', 'CODE', 'HASH',
  etc). Note that if the package contained any C<BEGIN> blocks, perl will leave
  an empty typeglob in the C<BEGIN> slot, so this will show up if no filter is
  used (and similarly for C<INIT>, C<END>, etc).
  
  =head2 get_all_symbols $type_filter
  
  Returns a hashref, keyed by the variable names in the package. If
  C<$type_filter> is passed, the hash will contain every variable of that type in
  the package as values, otherwise, it will contain the typeglobs corresponding
  to the variable names (basically, a clone of the stash).
  
  =head1 BUGS / CAVEATS
  
  =over 4
  
  =item * Prior to perl 5.10, scalar slots are only considered to exist if they are defined
  
  This is due to a shortcoming within perl itself. See
  L<perlref/Making References> point 7 for more information.
  
  =item * GLOB and FORMAT variables are not (yet) accessible through this module.
  
  =item * Also, see the BUGS section for the specific backends (L<Package::Stash::XS> and L<Package::Stash::PP>)
  
  =back
  
  Please report any bugs through RT: email
  C<bug-package-stash at rt.cpan.org>, or browse to
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Package-Stash>.
  
  =head1 SUPPORT
  
  You can find this documentation for this module with the perldoc command.
  
      perldoc Package::Stash
  
  You can also look for information at:
  
  =over 4
  
  =item * AnnoCPAN: Annotated CPAN documentation
  
  L<http://annocpan.org/dist/Package-Stash>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/d/Package-Stash>
  
  =item * RT: CPAN's request tracker
  
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Package-Stash>
  
  =item * Search CPAN
  
  L<http://search.cpan.org/dist/Package-Stash>
  
  =back
  
  =head1 AUTHOR
  
  Jesse Luehrs <doy at tozt dot net>
  
  Based on code from L<Class::MOP::Package>, by Stevan Little and the Moose
  Cabal.
  
  =for Pod::Coverage add_package_symbol
  remove_package_glob
  has_package_symbol
  get_package_symbol
  get_or_add_package_symbol
  remove_package_symbol
  list_all_package_symbols
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<Class::MOP::Package>
  
  This module is a factoring out of code that used to live here
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Jesse Luehrs.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
PACKAGE_STASH

$fatpacked{"Package/Stash/Conflicts.pm"} = <<'PACKAGE_STASH_CONFLICTS';
  package # hide from PAUSE
      Package::Stash::Conflicts;
  
  use strict;
  use warnings;
  
  use Dist::CheckConflicts
      -dist      => 'Package::Stash',
      -conflicts => {
          'Class::MOP' => '1.08',
          'MooseX::Method::Signatures' => '0.36',
          'MooseX::Role::WithOverloading' => '0.08',
          'namespace::clean' => '0.18',
      },
      -also => [ qw(
          Dist::CheckConflicts
          Package::DeprecationManager
          Scalar::Util
      ) ],
  
  ;
  
  1;
PACKAGE_STASH_CONFLICTS

$fatpacked{"Package/Stash/PP.pm"} = <<'PACKAGE_STASH_PP';
  package Package::Stash::PP;
  {
    $Package::Stash::PP::VERSION = '0.33';
  }
  use strict;
  use warnings;
  # ABSTRACT: pure perl implementation of the Package::Stash API
  
  use B;
  use Carp qw(confess);
  use Scalar::Util qw(blessed reftype weaken);
  use Symbol;
  # before 5.12, assigning to the ISA glob would make it lose its magical ->isa
  # powers
  use constant BROKEN_ISA_ASSIGNMENT => ($] < 5.012);
  # before 5.10, stashes don't ever seem to drop to a refcount of zero, so
  # weakening them isn't helpful
  use constant BROKEN_WEAK_STASH     => ($] < 5.010);
  # before 5.10, the scalar slot was always treated as existing if the
  # glob existed
  use constant BROKEN_SCALAR_INITIALIZATION => ($] < 5.010);
  
  
  sub new {
      my $class = shift;
      my ($package) = @_;
  
      if (!defined($package) || (ref($package) && ref($package) ne 'HASH')) {
          confess "Package::Stash->new must be passed the name of the "
                . "package to access";
      }
      elsif (ref($package) eq 'HASH') {
          confess "The pure perl implementation of Package::Stash doesn't "
                . "currently support anonymous stashes. You should install "
                . "Package::Stash::XS";
      }
      elsif ($package !~ /\A[0-9A-Z_a-z]+(?:::[0-9A-Z_a-z]+)*\z/) {
          confess "$package is not a module name";
      }
  
      return bless {
          'package' => $package,
      }, $class;
  }
  
  sub name {
      confess "Can't call name as a class method"
          unless blessed($_[0]);
      return $_[0]->{package};
  }
  
  sub namespace {
      confess "Can't call namespace as a class method"
          unless blessed($_[0]);
  
      if (BROKEN_WEAK_STASH) {
          no strict 'refs';
          return \%{$_[0]->name . '::'};
      }
      else {
          return $_[0]->{namespace} if defined $_[0]->{namespace};
  
          {
              no strict 'refs';
              $_[0]->{namespace} = \%{$_[0]->name . '::'};
          }
  
          weaken($_[0]->{namespace});
  
          return $_[0]->{namespace};
      }
  }
  
  {
      my %SIGIL_MAP = (
          '$' => 'SCALAR',
          '@' => 'ARRAY',
          '%' => 'HASH',
          '&' => 'CODE',
          ''  => 'IO',
      );
  
      sub _deconstruct_variable_name {
          my ($self, $variable) = @_;
  
          my @ret;
          if (ref($variable) eq 'HASH') {
              @ret = @{$variable}{qw[name sigil type]};
          }
          else {
              (defined $variable && length $variable)
                  || confess "You must pass a variable name";
  
              my $sigil = substr($variable, 0, 1, '');
  
              if (exists $SIGIL_MAP{$sigil}) {
                  @ret = ($variable, $sigil, $SIGIL_MAP{$sigil});
              }
              else {
                  @ret = ("${sigil}${variable}", '', $SIGIL_MAP{''});
              }
          }
  
          # XXX in pure perl, this will access things in inner packages,
          # in xs, this will segfault - probably look more into this at
          # some point
          ($ret[0] !~ /::/)
              || confess "Variable names may not contain ::";
  
          return @ret;
      }
  }
  
  sub _valid_for_type {
      my $self = shift;
      my ($value, $type) = @_;
      if ($type eq 'HASH' || $type eq 'ARRAY'
       || $type eq 'IO'   || $type eq 'CODE') {
          return reftype($value) eq $type;
      }
      else {
          my $ref = reftype($value);
          return !defined($ref) || $ref eq 'SCALAR' || $ref eq 'REF' || $ref eq 'LVALUE' || $ref eq 'REGEXP' || $ref eq 'VSTRING';
      }
  }
  
  sub add_symbol {
      my ($self, $variable, $initial_value, %opts) = @_;
  
      my ($name, $sigil, $type) = $self->_deconstruct_variable_name($variable);
  
      my $pkg = $self->name;
  
      if (@_ > 2) {
          $self->_valid_for_type($initial_value, $type)
              || confess "$initial_value is not of type $type";
  
          # cheap fail-fast check for PERLDBf_SUBLINE and '&'
          if ($^P and $^P & 0x10 && $sigil eq '&') {
              my $filename = $opts{filename};
              my $first_line_num = $opts{first_line_num};
  
              (undef, $filename, $first_line_num) = caller
                  if not defined $filename;
  
              my $last_line_num = $opts{last_line_num} || ($first_line_num ||= 0);
  
              # http://perldoc.perl.org/perldebguts.html#Debugger-Internals
              $DB::sub{$pkg . '::' . $name} = "$filename:$first_line_num-$last_line_num";
          }
      }
  
      no strict 'refs';
      no warnings 'redefine', 'misc', 'prototype';
      *{$pkg . '::' . $name} = ref $initial_value ? $initial_value : \$initial_value;
  }
  
  sub remove_glob {
      my ($self, $name) = @_;
      delete $self->namespace->{$name};
  }
  
  sub has_symbol {
      my ($self, $variable) = @_;
  
      my ($name, $sigil, $type) = $self->_deconstruct_variable_name($variable);
  
      my $namespace = $self->namespace;
  
      return unless exists $namespace->{$name};
  
      my $entry_ref = \$namespace->{$name};
      if (reftype($entry_ref) eq 'GLOB') {
          if ($type eq 'SCALAR') {
              if (BROKEN_SCALAR_INITIALIZATION) {
                  return defined ${ *{$entry_ref}{$type} };
              }
              else {
                  return B::svref_2object($entry_ref)->SV->isa('B::SV');
              }
          }
          else {
              return defined *{$entry_ref}{$type};
          }
      }
      else {
          # a symbol table entry can be -1 (stub), string (stub with prototype),
          # or reference (constant)
          return $type eq 'CODE';
      }
  }
  
  sub get_symbol {
      my ($self, $variable, %opts) = @_;
  
      my ($name, $sigil, $type) = $self->_deconstruct_variable_name($variable);
  
      my $namespace = $self->namespace;
  
      if (!exists $namespace->{$name}) {
          if ($opts{vivify}) {
              if ($type eq 'ARRAY') {
                  if (BROKEN_ISA_ASSIGNMENT) {
                      $self->add_symbol(
                          $variable,
                          $name eq 'ISA' ? () : ([])
                      );
                  }
                  else {
                      $self->add_symbol($variable, []);
                  }
              }
              elsif ($type eq 'HASH') {
                  $self->add_symbol($variable, {});
              }
              elsif ($type eq 'SCALAR') {
                  $self->add_symbol($variable);
              }
              elsif ($type eq 'IO') {
                  $self->add_symbol($variable, Symbol::geniosym);
              }
              elsif ($type eq 'CODE') {
                  confess "Don't know how to vivify CODE variables";
              }
              else {
                  confess "Unknown type $type in vivication";
              }
          }
          else {
              return undef;
          }
      }
  
      my $entry_ref = \$namespace->{$name};
  
      if (ref($entry_ref) eq 'GLOB') {
          return *{$entry_ref}{$type};
      }
      else {
          if ($type eq 'CODE') {
              no strict 'refs';
              return \&{ $self->name . '::' . $name };
          }
          else {
              return undef;
          }
      }
  }
  
  sub get_or_add_symbol {
      my $self = shift;
      $self->get_symbol(@_, vivify => 1);
  }
  
  sub remove_symbol {
      my ($self, $variable) = @_;
  
      my ($name, $sigil, $type) = $self->_deconstruct_variable_name($variable);
  
      # FIXME:
      # no doubt this is grossly inefficient and
      # could be done much easier and faster in XS
  
      my ($scalar_desc, $array_desc, $hash_desc, $code_desc, $io_desc) = (
          { sigil => '$', type => 'SCALAR', name => $name },
          { sigil => '@', type => 'ARRAY',  name => $name },
          { sigil => '%', type => 'HASH',   name => $name },
          { sigil => '&', type => 'CODE',   name => $name },
          { sigil => '',  type => 'IO',     name => $name },
      );
  
      my ($scalar, $array, $hash, $code, $io);
      if ($type eq 'SCALAR') {
          $array  = $self->get_symbol($array_desc)  if $self->has_symbol($array_desc);
          $hash   = $self->get_symbol($hash_desc)   if $self->has_symbol($hash_desc);
          $code   = $self->get_symbol($code_desc)   if $self->has_symbol($code_desc);
          $io     = $self->get_symbol($io_desc)     if $self->has_symbol($io_desc);
      }
      elsif ($type eq 'ARRAY') {
          $scalar = $self->get_symbol($scalar_desc) if $self->has_symbol($scalar_desc) || BROKEN_SCALAR_INITIALIZATION;
          $hash   = $self->get_symbol($hash_desc)   if $self->has_symbol($hash_desc);
          $code   = $self->get_symbol($code_desc)   if $self->has_symbol($code_desc);
          $io     = $self->get_symbol($io_desc)     if $self->has_symbol($io_desc);
      }
      elsif ($type eq 'HASH') {
          $scalar = $self->get_symbol($scalar_desc) if $self->has_symbol($scalar_desc) || BROKEN_SCALAR_INITIALIZATION;
          $array  = $self->get_symbol($array_desc)  if $self->has_symbol($array_desc);
          $code   = $self->get_symbol($code_desc)   if $self->has_symbol($code_desc);
          $io     = $self->get_symbol($io_desc)     if $self->has_symbol($io_desc);
      }
      elsif ($type eq 'CODE') {
          $scalar = $self->get_symbol($scalar_desc) if $self->has_symbol($scalar_desc) || BROKEN_SCALAR_INITIALIZATION;
          $array  = $self->get_symbol($array_desc)  if $self->has_symbol($array_desc);
          $hash   = $self->get_symbol($hash_desc)   if $self->has_symbol($hash_desc);
          $io     = $self->get_symbol($io_desc)     if $self->has_symbol($io_desc);
      }
      elsif ($type eq 'IO') {
          $scalar = $self->get_symbol($scalar_desc) if $self->has_symbol($scalar_desc) || BROKEN_SCALAR_INITIALIZATION;
          $array  = $self->get_symbol($array_desc)  if $self->has_symbol($array_desc);
          $hash   = $self->get_symbol($hash_desc)   if $self->has_symbol($hash_desc);
          $code   = $self->get_symbol($code_desc)   if $self->has_symbol($code_desc);
      }
      else {
          confess "This should never ever ever happen";
      }
  
      $self->remove_glob($name);
  
      $self->add_symbol($scalar_desc => $scalar) if defined $scalar;
      $self->add_symbol($array_desc  => $array)  if defined $array;
      $self->add_symbol($hash_desc   => $hash)   if defined $hash;
      $self->add_symbol($code_desc   => $code)   if defined $code;
      $self->add_symbol($io_desc     => $io)     if defined $io;
  }
  
  sub list_all_symbols {
      my ($self, $type_filter) = @_;
  
      my $namespace = $self->namespace;
      return keys %{$namespace} unless defined $type_filter;
  
      # NOTE:
      # or we can filter based on
      # type (SCALAR|ARRAY|HASH|CODE)
      if ($type_filter eq 'CODE') {
          return grep {
              # any non-typeglob in the symbol table is a constant or stub
              ref(\$namespace->{$_}) ne 'GLOB'
                  # regular subs are stored in the CODE slot of the typeglob
                  || defined(*{$namespace->{$_}}{CODE})
          } keys %{$namespace};
      }
      elsif ($type_filter eq 'SCALAR') {
          return grep {
              BROKEN_SCALAR_INITIALIZATION
                  ? (ref(\$namespace->{$_}) eq 'GLOB'
                        && defined(${*{$namespace->{$_}}{'SCALAR'}}))
                  : (do {
                        my $entry = \$namespace->{$_};
                        ref($entry) eq 'GLOB'
                            && B::svref_2object($entry)->SV->isa('B::SV')
                    })
          } keys %{$namespace};
      }
      else {
          return grep {
              ref(\$namespace->{$_}) eq 'GLOB'
                  && defined(*{$namespace->{$_}}{$type_filter})
          } keys %{$namespace};
      }
  }
  
  sub get_all_symbols {
      my ($self, $type_filter) = @_;
  
      my $namespace = $self->namespace;
      return { %{$namespace} } unless defined $type_filter;
  
      return {
          map { $_ => $self->get_symbol({name => $_, type => $type_filter}) }
              $self->list_all_symbols($type_filter)
      }
  }
  
  
  1;
  
  __END__
  =pod
  
  =head1 NAME
  
  Package::Stash::PP - pure perl implementation of the Package::Stash API
  
  =head1 VERSION
  
  version 0.33
  
  =head1 SYNOPSIS
  
    use Package::Stash;
  
  =head1 DESCRIPTION
  
  This is a backend for L<Package::Stash> implemented in pure perl, for those without a compiler or who would like to use this inline in scripts.
  
  =head1 BUGS
  
  =over 4
  
  =item * remove_symbol also replaces the associated typeglob
  
  This can cause unexpected behavior when doing manipulation at compile time -
  removing subroutines will still allow them to be called from within the package
  as subroutines (although they will not be available as methods). This can be
  considered a feature in some cases (this is how L<namespace::clean> works, for
  instance), but should not be relied upon - use C<remove_glob> directly if you
  want this behavior.
  
  =item * Some minor memory leaks
  
  The pure perl implementation has a couple minor memory leaks (see the TODO
  tests in t/20-leaks.t) that I'm having a hard time tracking down - these may be
  core perl bugs, it's hard to tell.
  
  =back
  
  Please report any bugs through RT: email
  C<bug-package-stash at rt.cpan.org>, or browse to
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Package-Stash>.
  
  =head1 SUPPORT
  
  You can find this documentation for this module with the perldoc command.
  
      perldoc Package::Stash
  
  You can also look for information at:
  
  =over 4
  
  =item * AnnoCPAN: Annotated CPAN documentation
  
  L<http://annocpan.org/dist/Package-Stash>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/d/Package-Stash>
  
  =item * RT: CPAN's request tracker
  
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Package-Stash>
  
  =item * Search CPAN
  
  L<http://search.cpan.org/dist/Package-Stash>
  
  =back
  
  =head1 AUTHOR
  
  Jesse Luehrs <doy at tozt dot net>
  
  Mostly copied from code from L<Class::MOP::Package>, by Stevan Little and the
  Moose Cabal.
  
  =for Pod::Coverage BROKEN_ISA_ASSIGNMENT
  add_symbol
  get_all_symbols
  get_or_add_symbol
  get_symbol
  has_symbol
  list_all_symbols
  name
  namespace
  new
  remove_glob
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<Class::MOP::Package>
  
  This module is a factoring out of code that used to live here
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Jesse Luehrs.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
PACKAGE_STASH_PP

$fatpacked{"Sub/Exporter.pm"} = <<'SUB_EXPORTER';
  use 5.006;
  use strict;
  use warnings;
  package Sub::Exporter;
  
  use Carp ();
  use Data::OptList ();
  use Params::Util ();
  use Sub::Install 0.92 ();
  
  =head1 NAME
  
  Sub::Exporter - a sophisticated exporter for custom-built routines
  
  =head1 VERSION
  
  version 0.982
  
  =cut
  
  our $VERSION = '0.982';
  
  =head1 SYNOPSIS
  
  Sub::Exporter must be used in two places.  First, in an exporting module:
  
    # in the exporting module:
    package Text::Tweaker;
    use Sub::Exporter -setup => {
      exports => [
        qw(squish titlecase), # always works the same way
        reformat => \&build_reformatter, # generator to build exported function
        trim     => \&build_trimmer,
        indent   => \&build_indenter,
      ],
      collectors => [ 'defaults' ],
    };
  
  Then, in an importing module:
  
    # in the importing module:
    use Text::Tweaker
      'squish',
      indent   => { margin => 5 },
      reformat => { width => 79, justify => 'full', -as => 'prettify_text' },
      defaults => { eol => 'CRLF' };
  
  With this setup, the importing module ends up with three routines: C<squish>,
  C<indent>, and C<prettify_text>.  The latter two have been built to the
  specifications of the importer -- they are not just copies of the code in the
  exporting package.
  
  =head1 DESCRIPTION
  
  B<ACHTUNG!>  If you're not familiar with Exporter or exporting, read
  L<Sub::Exporter::Tutorial> first!
  
  =head2 Why Generators?
  
  The biggest benefit of Sub::Exporter over existing exporters (including the
  ubiquitous Exporter.pm) is its ability to build new coderefs for export, rather
  than to simply export code identical to that found in the exporting package.
  
  If your module's consumers get a routine that works like this:
  
    use Data::Analyze qw(analyze);
    my $value = analyze($data, $tolerance, $passes);
  
  and they constantly pass only one or two different set of values for the
  non-C<$data> arguments, your code can benefit from Sub::Exporter.  By writing a
  simple generator, you can let them do this, instead:
  
    use Data::Analyze
      analyze => { tolerance => 0.10, passes => 10, -as => analyze10 },
      analyze => { tolerance => 0.15, passes => 50, -as => analyze50 };
  
    my $value = analyze10($data);
  
  The generator for that would look something like this:
  
    sub build_analyzer {
      my ($class, $name, $arg) = @_;
  
      return sub {
        my $data      = shift;
        my $tolerance = shift || $arg->{tolerance}; 
        my $passes    = shift || $arg->{passes}; 
  
        analyze($data, $tolerance, $passes);
      }
    }
  
  Your module's user now has to do less work to benefit from it -- and remember,
  you're often your own user!  Investing in customized subroutines is an
  investment in future laziness.
  
  This also avoids a common form of ugliness seen in many modules: package-level
  configuration.  That is, you might have seen something like the above
  implemented like so:
  
    use Data::Analyze qw(analyze);
    $Data::Analyze::default_tolerance = 0.10;
    $Data::Analyze::default_passes    = 10;
  
  This might save time, until you have multiple modules using Data::Analyze.
  Because there is only one global configuration, they step on each other's toes
  and your code begins to have mysterious errors.
  
  Generators can also allow you to export class methods to be called as
  subroutines:
  
    package Data::Methodical;
    use Sub::Exporter -setup => { exports => { some_method => \&_curry_class } };
  
    sub _curry_class {
      my ($class, $name) = @_;
      sub { $class->$name(@_); };
    }
  
  Because of the way that exporters and Sub::Exporter work, any package that
  inherits from Data::Methodical can inherit its exporter and override its
  C<some_method>.  If a user imports C<some_method> from that package, he'll
  receive a subroutine that calls the method on the subclass, rather than on
  Data::Methodical itself.
  
  =head2 Other Customizations
  
  Building custom routines with generators isn't the only way that Sub::Exporters
  allows the importing code to refine its use of the exported routines.  They may
  also be renamed to avoid naming collisions.
  
  Consider the following code:
  
    # this program determines to which circle of Hell you will be condemned
    use Morality qw(sin virtue); # for calculating viciousness
    use Math::Trig qw(:all);     # for dealing with circles
  
  The programmer has inadvertantly imported two C<sin> routines.  The solution,
  in Exporter.pm-based modules, would be to import only one and then call the
  other by its fully-qualified name.  Alternately, the importer could write a
  routine that did so, or could mess about with typeglobs.
  
  How much easier to write:
  
    # this program determines to which circle of Hell you will be condemned
    use Morality qw(virtue), sin => { -as => 'offense' };
    use Math::Trig -all => { -prefix => 'trig_' };
  
  and to have at one's disposal C<offense> and C<trig_sin> -- not to mention
  C<trig_cos> and C<trig_tan>.
  
  =head1 EXPORTER CONFIGURATION
  
  You can configure an exporter for your package by using Sub::Exporter like so:
  
    package Tools;
    use Sub::Exporter
      -setup => { exports => [ qw(function1 function2 function3) ] };
  
  This is the simplest way to use the exporter, and is basically equivalent to
  this:
  
    package Tools;
    use base qw(Exporter);
    our @EXPORT_OK = qw(function1 function2 function2);
  
  Any basic use of Sub::Exporter will look like this:
  
    package Tools;
    use Sub::Exporter -setup => \%config;
  
  The following keys are valid in C<%config>:
  
    exports - a list of routines to provide for exporting; each routine may be
              followed by generator
    groups  - a list of groups to provide for exporting; each must be followed by
              either (a) a list of exports, possibly with arguments for each
              export, or (b) a generator
  
    collectors - a list of names into which values are collected for use in
                 routine generation; each name may be followed by a validator
  
  In addition to the basic options above, a few more advanced options may be
  passed:
  
    into_level - how far up the caller stack to look for a target (default 0)
    into       - an explicit target (package) into which to export routines
  
  In other words: Sub::Exporter installs a C<import> routine which, when called,
  exports routines to the calling namespace.  The C<into> and C<into_level>
  options change where those exported routines are installed.
  
    generator  - a callback used to produce the code that will be installed
                 default: Sub::Exporter::default_generator
  
    installer  - a callback used to install the code produced by the generator
                 default: Sub::Exporter::default_installer
  
  For information on how these callbacks are used, see the documentation for
  C<L</default_generator>> and C<L</default_installer>>.
  
  =head2 Export Configuration
  
  The C<exports> list may be provided as an array reference or a hash reference.
  The list is processed in such a way that the following are equivalent:
  
    { exports => [ qw(foo bar baz), quux => \&quux_generator ] }
  
    { exports =>
      { foo => undef, bar => undef, baz => undef, quux => \&quux_generator } }
  
  Generators are code that return coderefs.  They are called with four
  parameters:
  
    $class - the class whose exporter has been called (the exporting class)
    $name  - the name of the export for which the routine is being build
   \%arg   - the arguments passed for this export
   \%col   - the collections for this import
  
  Given the configuration in the L</SYNOPSIS>, the following C<use> statement:
  
    use Text::Tweaker
      reformat => { -as => 'make_narrow', width => 33 },
      defaults => { eol => 'CR' };
  
  would result in the following call to C<&build_reformatter>:
  
    my $code = build_reformatter(
      'Text::Tweaker',
      'reformat',
      { width => 33 }, # note that -as is not passed in
      { defaults => { eol => 'CR' } },
    );
  
  The returned coderef (C<$code>) would then be installed as C<make_narrow> in the
  calling package.
  
  Instead of providing a coderef in the configuration, a reference to a method
  name may be provided.  This method will then be called on the invocant of the
  C<import> method.  (In this case, we do not pass the C<$class> parameter, as it
  would be redundant.)
  
  =head2 Group Configuration
  
  The C<groups> list can be passed in the same forms as C<exports>.  Groups must
  have values to be meaningful, which may either list exports that make up the
  group (optionally with arguments) or may provide a way to build the group.
  
  The simpler case is the first: a group definition is a list of exports.  Here's
  the example that could go in exporter in the L</SYNOPSIS>.
  
    groups  => {
      default    => [ qw(reformat) ],
      shorteners => [ qw(squish trim) ],
      email_safe => [
        'indent',
        reformat => { -as => 'email_format', width => 72 }
      ],
    },
  
  Groups are imported by specifying their name prefixed be either a dash or a
  colon.  This line of code would import the C<shorteners> group:
  
    use Text::Tweaker qw(-shorteners);
  
  Arguments passed to a group when importing are merged into the groups options
  and passed to any relevant generators.  Groups can contain other groups, but
  looping group structures are ignored.
  
  The other possible value for a group definition, a coderef, allows one
  generator to build several exportable routines simultaneously.  This is useful
  when many routines must share enclosed lexical variables.  The coderef must
  return a hash reference.  The keys will be used as export names and the values
  are the subs that will be exported.
  
  This example shows a simple use of the group generator.
  
    package Data::Crypto;
    use Sub::Exporter -setup => { groups => { cipher => \&build_cipher_group } };
  
    sub build_cipher_group {
      my ($class, $group, $arg) = @_;
      my ($encode, $decode) = build_codec($arg->{secret});
      return { cipher => $encode, decipher => $decode };
    }
  
  The C<cipher> and C<decipher> routines are built in a group because they are
  built together by code which encloses their secret in their environment.
  
  =head3 Default Groups
  
  If a module that uses Sub::Exporter is C<use>d with no arguments, it will try
  to export the group named C<default>.  If that group has not been specifically
  configured, it will be empty, and nothing will happen.
  
  Another group is also created if not defined: C<all>.  The C<all> group
  contains all the exports from the exports list.
  
  =head2 Collector Configuration
  
  The C<collectors> entry in the exporter configuration gives names which, when
  found in the import call, have their values collected and passed to every
  generator.
  
  For example, the C<build_analyzer> generator that we saw above could be
  rewritten as:
  
   sub build_analyzer {
     my ($class, $name, $arg, $col) = @_;
  
     return sub {
       my $data      = shift;
       my $tolerance = shift || $arg->{tolerance} || $col->{defaults}{tolerance}; 
       my $passes    = shift || $arg->{passes}    || $col->{defaults}{passes}; 
  
       analyze($data, $tolerance, $passes);
     }
   }
  
  That would allow the import to specify global defaults for his imports:
  
    use Data::Analyze
      'analyze',
      analyze  => { tolerance => 0.10, -as => analyze10 },
      analyze  => { tolerance => 0.15, passes => 50, -as => analyze50 },
      defaults => { passes => 10 };
  
    my $A = analyze10($data);     # equivalent to analyze($data, 0.10, 10);
    my $C = analyze50($data);     # equivalent to analyze($data, 0.15, 10);
    my $B = analyze($data, 0.20); # equivalent to analyze($data, 0.20, 10);
  
  If values are provided in the C<collectors> list during exporter setup, they
  must be code references, and are used to validate the importer's values.  The
  validator is called when the collection is found, and if it returns false, an
  exception is thrown.  We could ensure that no one tries to set a global data
  default easily:
  
    collectors => { defaults => sub { return (exists $_[0]->{data}) ? 0 : 1 } }
  
  Collector coderefs can also be used as hooks to perform arbitrary actions
  before anything is exported.
  
  When the coderef is called, it is passed the value of the collection and a
  hashref containing the following entries:
  
    name        - the name of the collector
    config      - the exporter configuration (hashref)
    import_args - the arguments passed to the exporter, sans collections (aref)
    class       - the package on which the importer was called
    into        - the package into which exports will be exported
  
  Collectors with all-caps names (that is, made up of underscore or capital A
  through Z) are reserved for special use.  The only currently implemented
  special collector is C<INIT>, whose hook (if present in the exporter
  configuration) is always run before any other hook.
  
  =head1 CALLING THE EXPORTER
  
  Arguments to the exporter (that is, the arguments after the module name in a
  C<use> statement) are parsed as follows:
  
  First, the collectors gather any collections found in the arguments.  Any
  reference type may be given as the value for a collector.  For each collection
  given in the arguments, its validator (if any) is called.  
  
  Next, groups are expanded.  If the group is implemented by a group generator,
  the generator is called.  There are two special arguments which, if given to a
  group, have special meaning:
  
    -prefix - a string to prepend to any export imported from this group
    -suffix - a string to append to any export imported from this group
  
  Finally, individual export generators are called and all subs, generated or
  otherwise, are installed in the calling package.  There is only one special
  argument for export generators:
  
    -as     - where to install the exported sub
  
  Normally, C<-as> will contain an alternate name for the routine.  It may,
  however, contain a reference to a scalar.  If that is the case, a reference the
  generated routine will be placed in the scalar referenced by C<-as>.  It will
  not be installed into the calling package.
  
  =head2 Special Exporter Arguments
  
  The generated exporter accept some special options, which may be passed as the
  first argument, in a hashref.
  
  These options are:
  
    into_level
    into
    generator
    installer
  
  These override the same-named configuration options described in L</EXPORTER
  CONFIGURATION>.
  
  =cut
  
  # Given a potential import name, this returns the group name -- if it's got a
  # group prefix.
  sub _group_name {
    my ($name) = @_;
  
    return if (index q{-:}, (substr $name, 0, 1)) == -1;
    return substr $name, 1;
  }
  
  # \@groups is a canonicalized opt list of exports and groups this returns
  # another canonicalized opt list with groups replaced with relevant exports.
  # \%seen is groups we've already expanded and can ignore.
  # \%merge is merged options from the group we're descending through.
  sub _expand_groups {
    my ($class, $config, $groups, $collection, $seen, $merge) = @_;
    $seen  ||= {};
    $merge ||= {};
    my @groups = @$groups;
  
    for my $i (reverse 0 .. $#groups) {
      if (my $group_name = _group_name($groups[$i][0])) {
        my $seen = { %$seen }; # faux-dynamic scoping
  
        splice @groups, $i, 1,
          _expand_group($class, $config, $groups[$i], $collection, $seen, $merge);
      } else {
        # there's nothing to munge in this export's args
        next unless my %merge = %$merge;
  
        # we have things to merge in; do so
        my $prefix = (delete $merge{-prefix}) || '';
        my $suffix = (delete $merge{-suffix}) || '';
  
        if (
          Params::Util::_CODELIKE($groups[$i][1]) ## no critic Private
          or
          Params::Util::_SCALAR0($groups[$i][1]) ## no critic Private
        ) {
          # this entry was build by a group generator
          $groups[$i][0] = $prefix . $groups[$i][0] . $suffix;
        } else {
          my $as
            = ref $groups[$i][1]{-as} ? $groups[$i][1]{-as}
            :     $groups[$i][1]{-as} ? $prefix . $groups[$i][1]{-as} . $suffix
            :                           $prefix . $groups[$i][0]      . $suffix;
  
          $groups[$i][1] = { %{ $groups[$i][1] }, %merge, -as => $as };
        }
      }
    }
  
    return \@groups;
  }
  
  # \@group is a name/value pair from an opt list.
  sub _expand_group {
    my ($class, $config, $group, $collection, $seen, $merge) = @_;
    $merge ||= {};
  
    my ($group_name, $group_arg) = @$group;
    $group_name = _group_name($group_name);
  
    Carp::croak qq(group "$group_name" is not exported by the $class module)
      unless exists $config->{groups}{$group_name};
  
    return if $seen->{$group_name}++;
  
    if (ref $group_arg) {
      my $prefix = (delete $merge->{-prefix}||'') . ($group_arg->{-prefix}||'');
      my $suffix = ($group_arg->{-suffix}||'') . (delete $merge->{-suffix}||'');
      $merge = {
        %$merge,
        %$group_arg,
        ($prefix ? (-prefix => $prefix) : ()),
        ($suffix ? (-suffix => $suffix) : ()),
      };
    }
  
    my $exports = $config->{groups}{$group_name};
  
    if (
      Params::Util::_CODELIKE($exports) ## no critic Private
      or
      Params::Util::_SCALAR0($exports) ## no critic Private
    ) {
      # I'm not very happy with this code for hiding -prefix and -suffix, but
      # it's needed, and I'm not sure, offhand, how to make it better.
      # -- rjbs, 2006-12-05
      my $group_arg = $merge ? { %$merge } : {};
      delete $group_arg->{-prefix};
      delete $group_arg->{-suffix};
  
      my $group = Params::Util::_CODELIKE($exports) ## no critic Private
                ? $exports->($class, $group_name, $group_arg, $collection)
                : $class->$$exports($group_name, $group_arg, $collection);
  
      Carp::croak qq(group generator "$group_name" did not return a hashref)
        if ref $group ne 'HASH';
  
      my $stuff = [ map { [ $_ => $group->{$_} ] } keys %$group ];
      return @{
        _expand_groups($class, $config, $stuff, $collection, $seen, $merge)
      };
    } else {
      $exports
        = Data::OptList::mkopt($exports, "$group_name exports");
  
      return @{
        _expand_groups($class, $config, $exports, $collection, $seen, $merge)
      };
    }
  }
  
  sub _mk_collection_builder {
    my ($col, $etc) = @_;
    my ($config, $import_args, $class, $into) = @$etc;
  
    my %seen;
    sub {
      my ($collection) = @_;
      my ($name, $value) = @$collection;
  
      Carp::croak "collection $name provided multiple times in import"
        if $seen{ $name }++;
  
      if (ref(my $hook = $config->{collectors}{$name})) {
        my $arg = {
          name        => $name,
          config      => $config,
          import_args => $import_args,
          class       => $class,
          into        => $into,
        };
  
        my $error_msg = "collection $name failed validation";
        if (Params::Util::_SCALAR0($hook)) { ## no critic Private
          Carp::croak $error_msg unless $class->$$hook($value, $arg);
        } else {
          Carp::croak $error_msg unless $hook->($value, $arg);
        }
      }
  
      $col->{ $name } = $value;
    }
  }
  
  # Given a config and pre-canonicalized importer args, remove collections from
  # the args and return them.
  sub _collect_collections {
    my ($config, $import_args, $class, $into) = @_;
  
    my @collections
      = map  { splice @$import_args, $_, 1 }
        grep { exists $config->{collectors}{ $import_args->[$_][0] } }
        reverse 0 .. $#$import_args;
  
    unshift @collections, [ INIT => {} ] if $config->{collectors}{INIT};
  
    my $col = {};
    my $builder = _mk_collection_builder($col, \@_);
    for my $collection (@collections) {
      $builder->($collection)
    }
  
    return $col;
  }
  
  =head1 SUBROUTINES
  
  =head2 setup_exporter
  
  This routine builds and installs an C<import> routine.  It is called with one
  argument, a hashref containing the exporter configuration.  Using this, it
  builds an exporter and installs it into the calling package with the name
  "import."  In addition to the normal exporter configuration, a few named
  arguments may be passed in the hashref:
  
    into       - into what package should the exporter be installed
    into_level - into what level up the stack should the exporter be installed
    as         - what name should the installed exporter be given
  
  By default the exporter is installed with the name C<import> into the immediate
  caller of C<setup_exporter>.  In other words, if your package calls
  C<setup_exporter> without providing any of the three above arguments, it will
  have an C<import> routine installed.
  
  Providing both C<into> and C<into_level> will cause an exception to be thrown.
  
  The exporter is built by C<L</build_exporter>>.
  
  =cut
  
  sub setup_exporter {
    my ($config)  = @_;
  
    Carp::croak 'into and into_level may not both be supplied to exporter'
      if exists $config->{into} and exists $config->{into_level};
  
    my $as   = delete $config->{as}   || 'import';
    my $into
      = exists $config->{into}       ? delete $config->{into}
      : exists $config->{into_level} ? caller(delete $config->{into_level})
      :                                caller(0);
  
    my $import = build_exporter($config);
  
    Sub::Install::reinstall_sub({
      code => $import,
      into => $into,
      as   => $as,
    });
  }
  
  =head2 build_exporter
  
  Given a standard exporter configuration, this routine builds and returns an
  exporter -- that is, a subroutine that can be installed as a class method to
  perform exporting on request.
  
  Usually, this method is called by C<L</setup_exporter>>, which then installs
  the exporter as a package's import routine.
  
  =cut
  
  sub _key_intersection {
    my ($x, $y) = @_;
    my %seen = map { $_ => 1 } keys %$x;
    my @names = grep { $seen{$_} } keys %$y;
  }
  
  # Given the config passed to setup_exporter, which contains sugary opt list
  # data, rewrite the opt lists into hashes, catch a few kinds of invalid
  # configurations, and set up defaults.  Since the config is a reference, it's
  # rewritten in place.
  my %valid_config_key;
  BEGIN {
    %valid_config_key =
      map { $_ => 1 }
      qw(as collectors installer generator exports groups into into_level),
      qw(exporter), # deprecated
  }
  
  sub _assert_collector_names_ok {
    my ($collectors) = @_;
  
    for my $reserved_name (grep { /\A[_A-Z]+\z/ } keys %$collectors) {
      Carp::croak "unknown reserved collector name: $reserved_name"
        if $reserved_name ne 'INIT';
    }
  }
  
  sub _rewrite_build_config {
    my ($config) = @_;
  
    if (my @keys = grep { not exists $valid_config_key{$_} } keys %$config) {
      Carp::croak "unknown options (@keys) passed to Sub::Exporter";
    }
  
    Carp::croak q(into and into_level may not both be supplied to exporter)
      if exists $config->{into} and exists $config->{into_level};
  
    # XXX: Remove after deprecation period.
    if ($config->{exporter}) {
      Carp::cluck "'exporter' argument to build_exporter is deprecated. Use 'installer' instead; the semantics are identical.";
      $config->{installer} = delete $config->{exporter};
    }
  
    Carp::croak q(into and into_level may not both be supplied to exporter)
      if exists $config->{into} and exists $config->{into_level};
  
    for (qw(exports collectors)) {
      $config->{$_} = Data::OptList::mkopt_hash(
        $config->{$_},
        $_,
        [ 'CODE', 'SCALAR' ],
      );
    }
  
    _assert_collector_names_ok($config->{collectors});
  
    if (my @names = _key_intersection(@$config{qw(exports collectors)})) {
      Carp::croak "names (@names) used in both collections and exports";
    }
  
    $config->{groups} = Data::OptList::mkopt_hash(
        $config->{groups},
        'groups',
        [
          'HASH',   # standard opt list
          'ARRAY',  # standard opt list
          'CODE',   # group generator
          'SCALAR', # name of group generation method
        ]
      );
  
    # by default, export nothing
    $config->{groups}{default} ||= [];
  
    # by default, build an all-inclusive 'all' group
    $config->{groups}{all} ||= [ keys %{ $config->{exports} } ];
  
    $config->{generator} ||= \&default_generator;
    $config->{installer} ||= \&default_installer;
  }
  
  sub build_exporter {
    my ($config) = @_;
  
    _rewrite_build_config($config);
  
    my $import = sub {
      my ($class) = shift;
  
      # XXX: clean this up -- rjbs, 2006-03-16
      my $special = (ref $_[0]) ? shift(@_) : {};
      Carp::croak q(into and into_level may not both be supplied to exporter)
        if exists $special->{into} and exists $special->{into_level};
  
      if ($special->{exporter}) {
        Carp::cluck "'exporter' special import argument is deprecated. Use 'installer' instead; the semantics are identical.";
        $special->{installer} = delete $special->{exporter};
      }
  
      my $into
        = defined $special->{into}       ? delete $special->{into}
        : defined $special->{into_level} ? caller(delete $special->{into_level})
        : defined $config->{into}        ? $config->{into}
        : defined $config->{into_level}  ? caller($config->{into_level})
        :                                  caller(0);
  
      my $generator = delete $special->{generator} || $config->{generator};
      my $installer = delete $special->{installer} || $config->{installer};
  
      # this builds a AOA, where the inner arrays are [ name => value_ref ]
      my $import_args = Data::OptList::mkopt([ @_ ]);
  
      # is this right?  defaults first or collectors first? -- rjbs, 2006-06-24
      $import_args = [ [ -default => undef ] ] unless @$import_args;
  
      my $collection = _collect_collections($config, $import_args, $class, $into);
  
      my $to_import = _expand_groups($class, $config, $import_args, $collection);
  
      # now, finally $import_arg is really the "to do" list
      _do_import(
        {
          class     => $class,
          col       => $collection,
          config    => $config,
          into      => $into,
          generator => $generator,
          installer => $installer,
        },
        $to_import,
      );
    };
  
    return $import;
  }
  
  sub _do_import {
    my ($arg, $to_import) = @_;
  
    my @todo;
  
    for my $pair (@$to_import) {
      my ($name, $import_arg) = @$pair;
  
      my ($generator, $as);
  
      if ($import_arg and Params::Util::_CODELIKE($import_arg)) { ## no critic
        # This is the case when a group generator has inserted name/code pairs.
        $generator = sub { $import_arg };
        $as = $name;
      } else {
        $import_arg = { $import_arg ? %$import_arg : () };
  
        Carp::croak qq("$name" is not exported by the $arg->{class} module)
          unless exists $arg->{config}{exports}{$name};
  
        $generator = $arg->{config}{exports}{$name};
  
        $as = exists $import_arg->{-as} ? (delete $import_arg->{-as}) : $name;
      }
  
      my $code = $arg->{generator}->(
        { 
          class     => $arg->{class},
          name      => $name,
          arg       => $import_arg,
          col       => $arg->{col},
          generator => $generator,
        }
      );
  
      push @todo, $as, $code;
    }
  
    $arg->{installer}->(
      {
        class => $arg->{class},
        into  => $arg->{into},
        col   => $arg->{col},
      },
      \@todo,
    );
  }
  
  ## Cute idea, possibly for future use: also supply an "unimport" for:
  ## no Module::Whatever qw(arg arg arg);
  # sub _unexport {
  #   my (undef, undef, undef, undef, undef, $as, $into) = @_;
  # 
  #   if (ref $as eq 'SCALAR') {
  #     undef $$as;
  #   } elsif (ref $as) {
  #     Carp::croak "invalid reference type for $as: " . ref $as;
  #   } else {
  #     no strict 'refs';
  #     delete &{$into . '::' . $as};
  #   }
  # }
  
  =head2 default_generator
  
  This is Sub::Exporter's default generator.  It takes bits of configuration that
  have been gathered during the import and turns them into a coderef that can be
  installed.
  
    my $code = default_generator(\%arg);
  
  Passed arguments are:
  
    class - the class on which the import method was called
    name  - the name of the export being generated
    arg   - the arguments to the generator
    col   - the collections
  
    generator - the generator to be used to build the export (code or scalar ref)
  
  =cut
  
  sub default_generator {
    my ($arg) = @_;
    my ($class, $name, $generator) = @$arg{qw(class name generator)};
  
    if (not defined $generator) {
      my $code = $class->can($name)
        or Carp::croak "can't locate exported subroutine $name via $class";
      return $code;
    }
  
    # I considered making this "$class->$generator(" but it seems that
    # overloading precedence would turn an overloaded-as-code generator object
    # into a string before code. -- rjbs, 2006-06-11
    return $generator->($class, $name, $arg->{arg}, $arg->{col})
      if Params::Util::_CODELIKE($generator); ## no critic Private
  
    # This "must" be a scalar reference, to a generator method name.
    # -- rjbs, 2006-12-05
    return $class->$$generator($name, $arg->{arg}, $arg->{col});
  }
  
  =head2 default_installer
  
  This is Sub::Exporter's default installer.  It does what Sub::Exporter
  promises: it installs code into the target package.
  
    default_installer(\%arg, \@to_export);
  
  Passed arguments are:
  
    into - the package into which exports should be delivered
  
  C<@to_export> is a list of name/value pairs.  The default exporter assigns code
  (the values) to named slots (the names) in the given package.  If the name is a
  scalar reference, the scalar reference is made to point to the code reference
  instead.
  
  =cut
  
  sub default_installer {
    my ($arg, $to_export) = @_;
  
    for (my $i = 0; $i < @$to_export; $i += 2) {
      my ($as, $code) = @$to_export[ $i, $i+1 ];
  
      # Allow as isa ARRAY to push onto an array?
      # Allow into isa HASH to install name=>code into hash?
  
      if (ref $as eq 'SCALAR') {
        $$as = $code;
      } elsif (ref $as) {
        Carp::croak "invalid reference type for $as: " . ref $as;
      } else {
        Sub::Install::reinstall_sub({
          code => $code,
          into => $arg->{into},
          as   => $as
        });
      }
    }
  }
  
  sub default_exporter {
    Carp::cluck "default_exporter is deprecated; call default_installer instead; the semantics are identical";
    goto &default_installer;
  }
  
  =head1 EXPORTS
  
  Sub::Exporter also offers its own exports: the C<setup_exporter> and
  C<build_exporter> routines described above.  It also provides a special "setup"
  collector, which will set up an exporter using the parameters passed to it.
  
  Note that the "setup" collector (seen in examples like the L</SYNOPSIS> above)
  uses C<build_exporter>, not C<setup_exporter>.  This means that the special
  arguments like "into" and "as" for C<setup_exporter> are not accepted here.
  Instead, you may write something like:
  
    use Sub::Exporter
      { into => 'Target::Package' },
      -setup => {
        -as     => 'do_import',
        exports => [ ... ],
      }
    ;
  
  Finding a good reason for wanting to do this is left as as exercise for the
  reader.
  
  =cut
  
  setup_exporter({
    exports => [
      qw(setup_exporter build_exporter),
      _import => sub { build_exporter($_[2]) },
    ],
    groups  => {
      all   => [ qw(setup_exporter build_export) ],
    },
    collectors => { -setup => \&_setup },
  });
  
  sub _setup {
    my ($value, $arg) = @_;
  
    if (ref $value eq 'HASH') {
      push @{ $arg->{import_args} }, [ _import => { -as => 'import', %$value } ];
      return 1;
    } elsif (ref $value eq 'ARRAY') {
      push @{ $arg->{import_args} },
        [ _import => { -as => 'import', exports => $value } ];
      return 1;
    }
    return;
  }
  
  =head1 COMPARISONS
  
  There are a whole mess of exporters on the CPAN.  The features included in
  Sub::Exporter set it apart from any existing Exporter.  Here's a summary of
  some other exporters and how they compare.
  
  =over
  
  =item * L<Exporter> and co.
  
  This is the standard Perl exporter.  Its interface is a little clunky, but it's
  fast and ubiquitous.  It can do some things that Sub::Exporter can't:  it can
  export things other than routines, it can import "everything in this group
  except this symbol," and some other more esoteric things.  These features seem
  to go nearly entirely unused.
  
  It always exports things exactly as they appear in the exporting module; it
  can't rename or customize routines.  Its groups ("tags") can't be nested.
  
  L<Exporter::Lite> is a whole lot like Exporter, but it does significantly less:
  it supports exporting symbols, but not groups, pattern matching, or negation.
  
  The fact that Sub::Exporter can't export symbols other than subroutines is
  a good idea, not a missing feature.
  
  For simple uses, setting up Sub::Exporter is about as easy as Exporter.  For
  complex uses, Sub::Exporter makes hard things possible, which would not be
  possible with Exporter. 
  
  When using a module that uses Sub::Exporter, users familiar with Exporter will
  probably see no difference in the basics.  These two lines do about the same
  thing in whether the exporting module uses Exporter or Sub::Exporter.
  
    use Some::Module qw(foo bar baz);
    use Some::Module qw(foo :bar baz);
  
  The definition for exporting in Exporter.pm might look like this:
  
    package Some::Module;
    use base qw(Exporter);
    our @EXPORT_OK   = qw(foo bar baz quux);
    our %EXPORT_TAGS = (bar => [ qw(bar baz) ]);
  
  Using Sub::Exporter, it would look like this:
  
    package Some::Module;
    use Sub::Exporter -setup => {
      exports => [ qw(foo bar baz quux) ],
      groups  => { bar => [ qw(bar baz) ]}
    };
  
  Sub::Exporter respects inheritance, so that a package may export inherited
  routines, and will export the most inherited version.  Exporting methods
  without currying away the invocant is a bad idea, but Sub::Exporter allows you
  to do just that -- and anyway, there are other uses for this feature, like
  packages of exported subroutines which use inheritance specifically to allow
  more specialized, but similar, packages.
  
  L<Exporter::Easy> provides a wrapper around the standard Exporter.  It makes it
  simpler to build groups, but doesn't provide any more functionality.  Because
  it is a front-end to Exporter, it will store your exporter's configuration in
  global package variables.
  
  =item * Attribute-Based Exporters
  
  Some exporters use attributes to mark variables to export.  L<Exporter::Simple>
  supports exporting any kind of symbol, and supports groups.  Using a module
  like Exporter or Sub::Exporter, it's easy to look at one place and see what is
  exported, but it's impossible to look at a variable definition and see whether
  it is exported by that alone.  Exporter::Simple makes this trade in reverse:
  each variable's declaration includes its export definition, but there is no one
  place to look to find a manifest of exports.
  
  More importantly, Exporter::Simple does not add any new features to those of
  Exporter.  In fact, like Exporter::Easy, it is just a front-end to Exporter, so
  it ends up storing its configuration in global package variables.  (This means
  that there is one place to look for your exporter's manifest, actually.  You
  can inspect the C<@EXPORT> package variables, and other related package
  variables, at runtime.)
  
  L<Perl6::Export> isn't actually attribute based, but looks similar.  Its syntax
  is borrowed from Perl 6, and implemented by a source filter.  It is a prototype
  of an interface that is still being designed.  It should probably be avoided
  for production work.  On the other hand, L<Perl6::Export::Attrs> implements
  Perl 6-like exporting, but translates it into Perl 5 by providing attributes.
  
  =item * Other Exporters
  
  L<Exporter::Renaming> wraps the standard Exporter to allow it to export symbols
  with changed names.
  
  L<Class::Exporter> performs a special kind of routine generation, giving each
  importing package an instance of your class, and then exporting the instance's
  methods as normal routines.  (Sub::Exporter, of course, can easily emulate this
  behavior, as shown above.)
  
  L<Exporter::Tidy> implements a form of renaming (using its C<_map> argument)
  and of prefixing, and implements groups.  It also avoids using package
  variables for its configuration.
  
  =back
  
  =head1 TODO
  
  =cut
  
  =over
  
  =item * write a set of longer, more demonstrative examples
  
  =item * solidify the "custom exporter" interface (see C<&default_exporter>)
  
  =item * add an "always" group
  
  =back
  
  =head1 AUTHOR
  
  Ricardo SIGNES, C<< <rjbs@cpan.org> >>
  
  =head1 THANKS
  
  Hans Dieter Pearcey provided helpful advice while I was writing Sub::Exporter.
  Ian Langworth and Shawn Sorichetti asked some good questions and hepled me
  improve my documentation quite a bit.  Yuval Kogman helped me find a bunch of
  little problems.
  
  Thanks, guys! 
  
  =head1 BUGS
  
  Please report any bugs or feature requests through the web interface at
  L<http://rt.cpan.org>. I will be notified, and then you'll automatically be
  notified of progress on your bug as I make changes.
  
  =head1 COPYRIGHT
  
  Copyright 2006-2007, Ricardo SIGNES.  This program is free software;  you can
  redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
  
  "jn8:32"; # <-- magic true value
SUB_EXPORTER

$fatpacked{"Sub/Exporter/Util.pm"} = <<'SUB_EXPORTER_UTIL';
  use strict;
  use warnings;
  
  package Sub::Exporter::Util;
  
  use Data::OptList ();
  use Params::Util ();
  
  =head1 NAME
  
  Sub::Exporter::Util - utilities to make Sub::Exporter easier
  
  =head1 VERSION
  
  version 0.982
  
  =cut
  
  our $VERSION = '0.982';
  
  =head1 DESCRIPTION
  
  This module provides a number of utility functions for performing common or
  useful operations when setting up a Sub::Exporter configuration.  All of the
  utilites may be exported, but none are by default.
  
  =head1 THE UTILITIES
  
  =head2 curry_method
  
    exports => {
      some_method => curry_method,
    }
  
  This utility returns a generator which will produce an invocant-curried version
  of a method.  In other words, it will export a method call with the exporting
  class built in as the invocant.
  
  A module importing the code some the above example might do this:
  
    use Some::Module qw(some_method);
  
    my $x = some_method;
  
  This would be equivalent to:
  
    use Some::Module;
  
    my $x = Some::Module->some_method;
  
  If Some::Module is subclassed and the subclass's import method is called to
  import C<some_method>, the subclass will be curried in as the invocant.
  
  If an argument is provided for C<curry_method> it is used as the name of the
  curried method to export.  This means you could export a Widget constructor
  like this:
  
    exports => { widget => curry_method('new') }
  
  This utility may also be called as C<curry_class>, for backwards compatibility.
  
  =cut
  
  sub curry_method {
    my $override_name = shift;
    sub {
      my ($class, $name) = @_;
      $name = $override_name if defined $override_name;
      sub { $class->$name(@_); };
    }
  }
  
  BEGIN { *curry_class = \&curry_method; }
  
  =head2 curry_chain
  
  C<curry_chain> behaves like C<L</curry_method>>, but is meant for generating
  exports that will call several methods in succession.
  
    exports => {
      reticulate => curry_chain([
        new => gather_data => analyze => [ detail => 100 ] => results
      ]),
    }
  
  If imported from Spliner, calling the C<reticulate> routine will be equivalent
  to:
  
    Splinter->new->gather_data->analyze(detail => 100)->results;
  
  If any method returns something on which methods may not be called, the routine
  croaks.
  
  The arguments to C<curry_chain> form an optlist.  The names are methods to be
  called and the arguments, if given, are arrayrefs to be dereferenced and passed
  as arguments to those methods.  C<curry_chain> returns a generator like those
  expected by Sub::Exporter.
  
  B<Achtung!> at present, there is no way to pass arguments from the generated
  routine to the method calls.  This will probably be solved in future revisions
  by allowing the opt list's values to be subroutines that will be called with
  the generated routine's stack.
  
  =cut
  
  sub curry_chain {
    # In the future, we can make \%arg an optional prepend, like the "special"
    # args to the default Sub::Exporter-generated import routine.
    my (@opt_list) = @_;
  
    my $pairs = Data::OptList::mkopt(\@opt_list, 'args', 'ARRAY');
  
    sub {
      my ($class) = @_;
  
      sub {
        my $next = $class;
  
        for my $i (0 .. $#$pairs) {
          my $pair = $pairs->[ $i ];
          
          unless (Params::Util::_INVOCANT($next)) { ## no critic Private
            my $str = defined $next ? "'$next'" : 'undef';
            Carp::croak("can't call $pair->[0] on non-invocant $str")
          }
  
          my ($method, $args) = @$pair;
  
          if ($i == $#$pairs) {
            return $next->$method($args ? @$args : ());
          } else {
            $next = $next->$method($args ? @$args : ());
          }
        }
      };
    }
  }
  
  # =head2 name_map
  # 
  # This utility returns an list to be used in specify export generators.  For
  # example, the following:
  # 
  #   exports => {
  #     name_map(
  #       '_?_gen'  => [ qw(fee fie) ],
  #       '_make_?' => [ qw(foo bar) ],
  #     ),
  #   }
  # 
  # is equivalent to:
  # 
  #   exports => {
  #     name_map(
  #       fee => \'_fee_gen',
  #       fie => \'_fie_gen',
  #       foo => \'_make_foo',
  #       bar => \'_make_bar',
  #     ),
  #   }
  # 
  # This can save a lot of typing, when providing many exports with similarly-named
  # generators.
  # 
  # =cut
  # 
  # sub name_map {
  #   my (%groups) = @_;
  # 
  #   my %map;
  # 
  #   while (my ($template, $names) = each %groups) {
  #     for my $name (@$names) {
  #       (my $export = $template) =~ s/\?/$name/
  #         or Carp::croak 'no ? found in name_map template';
  # 
  #       $map{ $name } = \$export;
  #     }
  #   }
  # 
  #   return %map;
  # }
  
  =head2 merge_col
  
    exports => {
      merge_col(defaults => {
        twiddle => \'_twiddle_gen',
        tweak   => \&_tweak_gen,
      }),
    }
  
  This utility wraps the given generator in one that will merge the named
  collection into its args before calling it.  This means that you can support a
  "default" collector in multipe exports without writing the code each time.
  
  You can specify as many pairs of collection names and generators as you like.
  
  =cut
  
  sub merge_col {
    my (%groups) = @_;
  
    my %merged;
  
    while (my ($default_name, $group) = each %groups) {
      while (my ($export_name, $gen) = each %$group) {
        $merged{$export_name} = sub {
          my ($class, $name, $arg, $col) = @_;
  
          my $merged_arg = exists $col->{$default_name}
                         ? { %{ $col->{$default_name} }, %$arg }
                         : $arg;
  
          if (Params::Util::_CODELIKE($gen)) { ## no critic Private
            $gen->($class, $name, $merged_arg, $col);
          } else {
            $class->$$gen($name, $merged_arg, $col);
          }
        }
      }
    }
  
    return %merged;
  }
  
  =head2 mixin_installer
  
    use Sub::Exporter -setup => {
      installer => Sub::Exporter::Util::mixin_installer,
      exports   => [ qw(foo bar baz) ],
    };
  
  This utility returns an installer that will install into a superclass and
  adjust the ISA importing class to include the newly generated superclass.
  
  If the target of importing is an object, the hierarchy is reversed: the new
  class will be ISA the object's class, and the object will be reblessed.
  
  B<Prerequisites>: This utility requires that Package::Generator be installed.
  
  =cut
  
  sub __mixin_class_for {
    my ($class, $mix_into) = @_;
    require Package::Generator;
    my $mixin_class = Package::Generator->new_package({
      base => "$class\:\:__mixin__",
    });
  
    ## no critic (ProhibitNoStrict)
    no strict 'refs';
    if (ref $mix_into) {
      unshift @{"$mixin_class" . "::ISA"}, ref $mix_into;
    } else {
      unshift @{"$mix_into" . "::ISA"}, $mixin_class;
    }
    return $mixin_class;
  }
  
  sub mixin_installer {
    sub {
      my ($arg, $to_export) = @_;
  
      my $mixin_class = __mixin_class_for($arg->{class}, $arg->{into});
      bless $arg->{into} => $mixin_class if ref $arg->{into};
  
      Sub::Exporter::default_installer(
        { %$arg, into => $mixin_class },
        $to_export,
      );
    };
  }
  
  sub mixin_exporter {
    Carp::cluck "mixin_exporter is deprecated; use mixin_installer instead; it behaves identically";
    return mixin_installer;
  }
  
  =head2 like
  
  It's a collector that adds imports for anything like given regex.
  
  If you provide this configuration:
  
    exports    => [ qw(igrep imap islurp exhausted) ],
    collectors => { -like => Sub::Exporter::Util::like },
  
  A user may import from your module like this:
  
    use Your::Iterator -like => qr/^i/; # imports igre, imap, islurp
  
  or
  
    use Your::Iterator -like => [ qr/^i/ => { -prefix => 'your_' } ];
  
  The group-like prefix and suffix arguments are respected; other arguments are
  passed on to the generators for matching exports.
  
  =cut
  
  sub like {
    sub {
      my ($value, $arg) = @_;
      Carp::croak "no regex supplied to regex group generator" unless $value;
  
      # Oh, qr//, how you bother me!  See the p5p thread from around now about
      # fixing this problem... too bad it won't help me. -- rjbs, 2006-04-25
      my @values = eval { $value->isa('Regexp') } ? ($value, undef)
                 :                                  @$value;
  
      while (my ($re, $opt) = splice @values, 0, 2) {
        Carp::croak "given pattern for regex group generater is not a Regexp"
          unless eval { $re->isa('Regexp') };
        my @exports  = keys %{ $arg->{config}->{exports} };
        my @matching = grep { $_ =~ $re } @exports;
  
        my %merge = $opt ? %$opt : ();
        my $prefix = (delete $merge{-prefix}) || '';
        my $suffix = (delete $merge{-suffix}) || '';
  
        for my $name (@matching) {
          my $as = $prefix . $name . $suffix;
          push @{ $arg->{import_args} }, [ $name => { %merge, -as => $as } ];
        }
      }
  
      1;
    }
  }
  
  use Sub::Exporter -setup => {
    exports => [ qw(
      like
      name_map
      merge_col
      curry_method curry_class
      curry_chain
      mixin_installer mixin_exporter
    ) ]
  };
  
  =head1 AUTHOR
  
  Ricardo SIGNES, C<< <rjbs@cpan.org> >>
  
  =head1 BUGS
  
  Please report any bugs or feature requests through the web interface at
  L<http://rt.cpan.org>. I will be notified, and then you'll automatically be
  notified of progress on your bug as I make changes.
  
  =head1 COPYRIGHT
  
  Copyright 2006-2007, Ricardo SIGNES.  This program is free software;  you can
  redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
  
  1;
SUB_EXPORTER_UTIL

$fatpacked{"Sub/Install.pm"} = <<'SUB_INSTALL';
  package Sub::Install;
  
  use warnings;
  use strict;
  
  use Carp;
  use Scalar::Util ();
  
  =head1 NAME
  
  Sub::Install - install subroutines into packages easily
  
  =head1 VERSION
  
  version 0.925
  
  =cut
  
  our $VERSION = '0.925';
  
  =head1 SYNOPSIS
  
    use Sub::Install;
  
    Sub::Install::install_sub({
      code => sub { ... },
      into => $package,
      as   => $subname
    });
  
  =head1 DESCRIPTION
  
  This module makes it easy to install subroutines into packages without the
  unslightly mess of C<no strict> or typeglobs lying about where just anyone can
  see them.
  
  =head1 FUNCTIONS
  
  =head2 install_sub
  
    Sub::Install::install_sub({
     code => \&subroutine,
     into => "Finance::Shady",
     as   => 'launder',
    });
  
  This routine installs a given code reference into a package as a normal
  subroutine.  The above is equivalent to:
  
    no strict 'refs';
    *{"Finance::Shady" . '::' . "launder"} = \&subroutine;
  
  If C<into> is not given, the sub is installed into the calling package.
  
  If C<code> is not a code reference, it is looked for as an existing sub in the
  package named in the C<from> parameter.  If C<from> is not given, it will look
  in the calling package.
  
  If C<as> is not given, and if C<code> is a name, C<as> will default to C<code>.
  If C<as> is not given, but if C<code> is a code ref, Sub::Install will try to
  find the name of the given code ref and use that as C<as>.
  
  That means that this code:
  
    Sub::Install::install_sub({
      code => 'twitch',
      from => 'Person::InPain',
      into => 'Person::Teenager',
      as   => 'dance',
    });
  
  is the same as:
  
    package Person::Teenager;
  
    Sub::Install::install_sub({
      code => Person::InPain->can('twitch'),
      as   => 'dance',
    });
  
  =head2 reinstall_sub
  
  This routine behaves exactly like C<L</install_sub>>, but does not emit a
  warning if warnings are on and the destination is already defined.
  
  =cut
  
  sub _name_of_code {
    my ($code) = @_;
    require B;
    my $name = B::svref_2object($code)->GV->NAME;
    return $name unless $name =~ /\A__ANON__/;
    return;
  }
  
  # See also Params::Util, to which this code was donated.
  sub _CODELIKE {
    (Scalar::Util::reftype($_[0])||'') eq 'CODE'
    || Scalar::Util::blessed($_[0])
    && (overload::Method($_[0],'&{}') ? $_[0] : undef);
  }
  
  # do the heavy lifting
  sub _build_public_installer {
    my ($installer) = @_;
  
    sub {
      my ($arg) = @_;
      my ($calling_pkg) = caller(0);
  
      # I'd rather use ||= but I'm whoring for Devel::Cover.
      for (qw(into from)) { $arg->{$_} = $calling_pkg unless $arg->{$_} }
  
      # This is the only absolutely required argument, in many cases.
      Carp::croak "named argument 'code' is not optional" unless $arg->{code};
  
      if (_CODELIKE($arg->{code})) {
        $arg->{as} ||= _name_of_code($arg->{code});
      } else {
        Carp::croak
          "couldn't find subroutine named $arg->{code} in package $arg->{from}"
          unless my $code = $arg->{from}->can($arg->{code});
  
        $arg->{as}   = $arg->{code} unless $arg->{as};
        $arg->{code} = $code;
      }
  
      Carp::croak "couldn't determine name under which to install subroutine"
        unless $arg->{as};
  
      $installer->(@$arg{qw(into as code) });
    }
  }
  
  # do the ugly work
  
  my $_misc_warn_re;
  my $_redef_warn_re;
  BEGIN {
    $_misc_warn_re = qr/
      Prototype\ mismatch:\ sub\ .+?  |
      Constant subroutine \S+ redefined
    /x;
    $_redef_warn_re = qr/Subroutine\ \S+\ redefined/x;
  }
  
  my $eow_re;
  BEGIN { $eow_re = qr/ at .+? line \d+\.\Z/ };
  
  sub _do_with_warn {
    my ($arg) = @_;
    my $code = delete $arg->{code};
    my $wants_code = sub {
      my $code = shift;
      sub {
        my $warn = $SIG{__WARN__} ? $SIG{__WARN__} : sub { warn @_ }; ## no critic
        local $SIG{__WARN__} = sub {
          my ($error) = @_;
          for (@{ $arg->{suppress} }) {
              return if $error =~ $_;
          }
          for (@{ $arg->{croak} }) {
            if (my ($base_error) = $error =~ /\A($_) $eow_re/x) {
              Carp::croak $base_error;
            }
          }
          for (@{ $arg->{carp} }) {
            if (my ($base_error) = $error =~ /\A($_) $eow_re/x) {
              return $warn->(Carp::shortmess $base_error);
            }
          }
          ($arg->{default} || $warn)->($error);
        };
        $code->(@_);
      };
    };
    return $wants_code->($code) if $code;
    return $wants_code;
  }
  
  sub _installer {
    sub {
      my ($pkg, $name, $code) = @_;
      no strict 'refs'; ## no critic ProhibitNoStrict
      *{"$pkg\::$name"} = $code;
      return $code;
    }
  }
  
  BEGIN {
    *_ignore_warnings = _do_with_warn({
      carp => [ $_misc_warn_re, $_redef_warn_re ]
    });
  
    *install_sub = _build_public_installer(_ignore_warnings(_installer));
  
    *_carp_warnings =  _do_with_warn({
      carp     => [ $_misc_warn_re ],
      suppress => [ $_redef_warn_re ],
    });
  
    *reinstall_sub = _build_public_installer(_carp_warnings(_installer));
  
    *_install_fatal = _do_with_warn({
      code     => _installer,
      croak    => [ $_redef_warn_re ],
    });
  }
  
  =head2 install_installers
  
  This routine is provided to allow Sub::Install compatibility with
  Sub::Installer.  It installs C<install_sub> and C<reinstall_sub> methods into
  the package named by its argument.
  
   Sub::Install::install_installers('Code::Builder'); # just for us, please
   Code::Builder->install_sub({ name => $code_ref });
  
   Sub::Install::install_installers('UNIVERSAL'); # feeling lucky, punk?
   Anything::At::All->install_sub({ name => $code_ref });
  
  The installed installers are similar, but not identical, to those provided by
  Sub::Installer.  They accept a single hash as an argument.  The key/value pairs
  are used as the C<as> and C<code> parameters to the C<install_sub> routine
  detailed above.  The package name on which the method is called is used as the
  C<into> parameter.
  
  Unlike Sub::Installer's C<install_sub> will not eval strings into code, but
  will look for named code in the calling package.
  
  =cut
  
  sub install_installers {
    my ($into) = @_;
  
    for my $method (qw(install_sub reinstall_sub)) {
      my $code = sub {
        my ($package, $subs) = @_;
        my ($caller) = caller(0);
        my $return;
        for (my ($name, $sub) = %$subs) {
          $return = Sub::Install->can($method)->({
            code => $sub,
            from => $caller,
            into => $package,
            as   => $name
          });
        }
        return $return;
      };
      install_sub({ code => $code, into => $into, as => $method });
    }
  }
  
  =head1 EXPORTS
  
  Sub::Install exports C<install_sub> and C<reinstall_sub> only if they are
  requested.
  
  =head2 exporter
  
  Sub::Install has a never-exported subroutine called C<exporter>, which is used
  to implement its C<import> routine.  It takes a hashref of named arguments,
  only one of which is currently recognize: C<exports>.  This must be an arrayref
  of subroutines to offer for export.
  
  This routine is mainly for Sub::Install's own consumption.  Instead, consider
  L<Sub::Exporter>.
  
  =cut
  
  sub exporter {
    my ($arg) = @_;
    
    my %is_exported = map { $_ => undef } @{ $arg->{exports} };
  
    sub {
      my $class = shift;
      my $target = caller;
      for (@_) {
        Carp::croak "'$_' is not exported by $class" if !exists $is_exported{$_};
        install_sub({ code => $_, from => $class, into => $target });
      }
    }
  }
  
  BEGIN { *import = exporter({ exports => [ qw(install_sub reinstall_sub) ] }); }
  
  =head1 SEE ALSO
  
  =over
  
  =item L<Sub::Installer>
  
  This module is (obviously) a reaction to Damian Conway's Sub::Installer, which
  does the same thing, but does it by getting its greasy fingers all over
  UNIVERSAL.  I was really happy about the idea of making the installation of
  coderefs less ugly, but I couldn't bring myself to replace the ugliness of
  typeglobs and loosened strictures with the ugliness of UNIVERSAL methods.
  
  =item L<Sub::Exporter>
  
  This is a complete Exporter.pm replacement, built atop Sub::Install.
  
  =back
  
  =head1 AUTHOR
  
  Ricardo Signes, C<< <rjbs@cpan.org> >>
  
  Several of the tests are adapted from tests that shipped with Damian Conway's
  Sub-Installer distribution.
  
  =head1 BUGS
  
  Please report any bugs or feature requests through the web interface at
  L<http://rt.cpan.org>.  I will be notified, and then you'll automatically be
  notified of progress on your bug as I make changes.
  
  =head1 COPYRIGHT
  
  Copyright 2005-2006 Ricardo Signes, All Rights Reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
  1;
SUB_INSTALL

$fatpacked{"Sys/Statistics/Linux.pm"} = <<'SYS_STATISTICS_LINUX';
  =head1 NAME
  
  Sys::Statistics::Linux - Front-end module to collect system statistics
  
  =head1 SYNOPSIS
  
      use Sys::Statistics::Linux;
  
      my $lxs = Sys::Statistics::Linux->new(
          sysinfo   => 1,
          cpustats  => 1,
          procstats => 1,
          memstats  => 1,
          pgswstats => 1,
          netstats  => 1,
          sockstats => 1,
          diskstats => 1,
          diskusage => 1,
          loadavg   => 1,
          filestats => 1,
          processes => 1,
      );
  
      sleep 1;
      my $stat = $lxs->get;
  
  =head1 DESCRIPTION
  
  Sys::Statistics::Linux is a front-end module and gather different linux system information
  like processor workload, memory usage, network and disk statistics and a lot more. Refer the
  documentation of the distribution modules to get more information about all possible statistics.
  
  =head1 MOTIVATION
  
  My motivation is very simple... every linux administrator knows the well-known tool sar of sysstat.
  It helps me a lot of time to search for system bottlenecks and to solve problems, but it's hard to
  parse the output if you want to store the statistics into a database. So I thought to develope
  Sys::Statistics::Linux. It's not a replacement but it should make it simpler to you to write your
  own system monitor.
  
  If Sys::Statistics::Linux doesn't provide statistics that are strongly needed then let me know it.
  
  =head1 TECHNICAL NOTE
  
  This distribution collects statistics by the virtual F</proc> filesystem (procfs) and is
  developed on the default vanilla kernel. It is tested on x86 hardware with the distributions
  RHEL, Fedora, Debian, Ubuntu, Asianux, Slackware, Mandriva and openSuSE (SLES on zSeries as
  well but a long time ago) on kernel versions 2.4 and/or 2.6. It's possible that it doesn't
  run on all linux distributions if some procfs features are deactivated or too much modified.
  As example the linux kernel 2.4 can compiled with the option C<CONFIG_BLK_STATS> what turn
  on or off block statistics for devices.
  
  Don't give up if some of the modules doesn't run on your hardware! Tell me what's wrong
  and I will try to solve it! You just have to make the first move and to send me a mail. :-)
  
  =head1 VIRTUAL MACHINES
  
  Note that if you try to install or run C<Sys::Statistics::Linux> under virtual machines
  on guest systems that some statistics are not available, such as C<SockStats>, C<PgSwStats>
  and C<DiskStats>. The reason is that not all /proc data are passed to the guests.
  
  If the installation fails then try to force the installation with
  
      cpan> force install Sys::Statistics::Linux
  
  and notice which tests fails, because this statistics maybe not available on the virtual machine - sorry.
  
  =head1 DELTAS
  
  The statistics for C<CpuStats>, C<ProcStats>, C<PgSwStats>, C<NetStats>, C<DiskStats> and C<Processes>
  are deltas, for this reason it's necessary to initialize the statistics before the data can be
  prepared by C<get()>. These statistics can be initialized with the methods C<new()>, C<set()> and
  C<init()>. For any option that is set to 1, the statistics will be initialized by the call of
  C<new()> or C<set()>. The call of init() re-initialize all statistics that are set to 1 or 2.
  By the call of C<get()> the initial statistics will be updated automatically. Please refer the
  section L</METHODS> to get more information about the usage of C<new()>, C<set()>, C<init()>
  and C<get()>.
  
  Another exigence is to sleep for a while - at least for one second - before the call of C<get()>
  if you want to get useful statistics. The statistics for C<SysInfo>, C<MemStats>, C<SockStats>,
  C<DiskUsage>, C<LoadAVG> and C<FileStats> are no deltas. If you need only one of these information
  you don't need to sleep before the call of C<get()>.
  
  The method C<get()> prepares all requested statistics and returns the statistics as a
  L<Sys::Statistics::Linux::Compilation> object. The inital statistics will be updated.
  
  =head1 MANUAL PROC(5)
  
  The Linux Programmer's Manual
  
      http://www.kernel.org/doc/man-pages/online/pages/man5/proc.5.html
  
  If you have questions or don't understand the sense of some statistics then take a look
  into this awesome documentation.
  
  =head1 OPTIONS
  
  All options are identical with the package names of the distribution in lowercase. To activate
  the gathering of statistics you have to set the options by the call of C<new()> or C<set()>.
  In addition you can deactivate statistics with C<set()>.
  
  The options must be set with one of the following values:
  
      0 - deactivate statistics
      1 - activate and init statistics
      2 - activate statistics but don't init
  
  In addition it's possible to pass a hash reference with options.
  
      my $lxs = Sys::Statistics::Linux->new(
          processes => {
              init => 1,
              pids => [ 1, 2, 3 ]
          },
          netstats => {
              init => 1,
              initfile => $file,
          },
      );
  
  Option C<initfile> is useful if you want to store initial statistics on the filesystem.
  
      my $lxs = Sys::Statistics::Linux->new(
          cpustats => {
              init     => 1,
              initfile => '/tmp/cpustats.yml',
          },
          diskstats => {
              init     => 1,
              initfile => '/tmp/diskstats.yml',
          },
          netstats => {
              init     => 1,
              initfile => '/tmp/netstats.yml',
          },
          pgswstats => {
              init     => 1,
              initfile => '/tmp/pgswstats.yml',
          },
          procstats => {
              init     => 1,
              initfile => '/tmp/procstats.yml',
          },
      );
  
  Example:
  
      #!/usr/bin/perl
      use strict;
      use warnings;
      use Sys::Statistics::Linux;
  
      my $lxs = Sys::Statistics::Linux->new(
          pgswstats => {
              init => 1,
              initfile => '/tmp/pgswstats.yml'
          }
      );
  
      $lxs->get(); # without to sleep
  
  The initial statistics are stored to the temporary file:
  
      #> cat /tmp/pgswstats.yml
      --- 
      pgfault: 397040955
      pgmajfault: 4611
      pgpgin: 21531693
      pgpgout: 49511043
      pswpin: 8
      pswpout: 272
      time: 1236783534.9328
  
  Every time you call the script the initial statistics are loaded/stored from/to the file.
  This could be helpful if you doesn't run it as daemon and if you want to calculate the
  average load of your system since the last call. Do you understand? I hope so :)
  
  To get more information about the statistics refer the different modules of the distribution.
  
      sysinfo     -  Collect system information              with Sys::Statistics::Linux::SysInfo.
      cpustats    -  Collect cpu statistics                  with Sys::Statistics::Linux::CpuStats.
      procstats   -  Collect process statistics              with Sys::Statistics::Linux::ProcStats.
      memstats    -  Collect memory statistics               with Sys::Statistics::Linux::MemStats.
      pgswstats   -  Collect paging and swapping statistics  with Sys::Statistics::Linux::PgSwStats.
      netstats    -  Collect net statistics                  with Sys::Statistics::Linux::NetStats.
      sockstats   -  Collect socket statistics               with Sys::Statistics::Linux::SockStats.
      diskstats   -  Collect disk statistics                 with Sys::Statistics::Linux::DiskStats.
      diskusage   -  Collect the disk usage                  with Sys::Statistics::Linux::DiskUsage.
      loadavg     -  Collect the load average                with Sys::Statistics::Linux::LoadAVG.
      filestats   -  Collect inode statistics                with Sys::Statistics::Linux::FileStats.
      processes   -  Collect process statistics              with Sys::Statistics::Linux::Processes.
  
  =head1 METHODS
  
  =head2 new()
  
  Call C<new()> to create a new Sys::Statistics::Linux object. You can call C<new()> with options.
  This options would be passed to the method C<set()>.
  
  Without options
  
      my $lxs = Sys::Statistics::Linux->new();
  
  Or with options
  
      my $lxs = Sys::Statistics::Linux->new( cpustats => 1 );
  
  Would do nothing
  
      my $lxs = Sys::Statistics::Linux->new( cpustats => 0 );
  
  It's possible to call C<new()> with a hash reference of options.
  
      my %options = (
          cpustats => 1,
          memstats => 1
      );
  
      my $lxs = Sys::Statistics::Linux->new(\%options);
  
  =head2 set()
  
  Call C<set()> to activate or deactivate options.
  
  The following example would call C<new()> and initialize C<Sys::Statistics::Linux::CpuStats>
  and delete the object of C<Sys::Statistics::Linux::SysInfo>.
  
      $lxs->set(
          processes =>  0, # deactivate this statistic
          pgswstats =>  1, # activate the statistic and calls new() and init() if necessary
          netstats  =>  2, # activate the statistic and call new() if necessary but not init()
      );
  
  It's possible to call C<set()> with a hash reference of options.
  
      my %options = (
          cpustats => 2,
          memstats => 2
      );
  
      $lxs->set(\%options);
  
  =head2 get()
  
  Call C<get()> to get the collected statistics. C<get()> returns a L<Sys::Statistics::Linux::Compilation>
  object.
  
      my $lxs  = Sys::Statistics::Linux->new(\%options);
      sleep(1);
      my $stat = $lxs->get();
  
  Or you can pass the time to sleep with the call of C<get()>.
  
      my $stat = $lxs->get($time_to_sleep);
  
  Now the statistcs are available with
  
      $stat->cpustats
  
      # or
  
      $stat->{cpustats}
  
  Take a look to the documentation of L<Sys::Statistics::Linux::Compilation> for more information.
  
  =head2 init()
  
  The call of C<init()> initiate all activated statistics that are necessary for deltas. That could
  be helpful if your script runs in a endless loop with a high sleep interval. Don't forget that if
  you call C<get()> that the statistics are deltas since the last time they were initiated.
  
  The following example would calculate average statistics for 30 minutes:
  
      # initiate cpustats
      my $lxs = Sys::Statistics::Linux->new( cpustats => 1 );
  
      while ( 1 ) {
          sleep(1800);
          my $stat = $lxs->get;
      }
  
  If you just want a current snapshot of the system each 30 minutes and not the average
  then the following example would be better for you:
  
      # do not initiate cpustats
      my $lxs = Sys::Statistics::Linux->new( cpustats => 2 );
  
      while ( 1 ) {
          $lxs->init;              # init the statistics
          my $stat = $lxs->get(1); # get the statistics
          sleep(1800);             # sleep until the next run
      }
  
  If you want to write a simple command line utility that prints the current workload
  to the screen then you can use something like this:
  
      my @order = qw(user system iowait idle nice irq softirq total);
      printf "%-20s%8s%8s%8s%8s%8s%8s%8s%8s\n", 'time', @order;
  
      my $lxs = Sys::Statistics::Linux->new( cpustats => 1 );
  
      while ( 1 ){
          my $cpu  = $lxs->get(1)->cpustats;
          my $time = $lxs->gettime;
          printf "%-20s%8s%8s%8s%8s%8s%8s%8s%8s\n",
              $time, @{$cpu->{cpu}}{@order};
      }
  
  =head2 settime()
  
  Call C<settime()> to define a POSIX formatted time stamp, generated with localtime().
  
      $lxs->settime('%Y/%m/%d %H:%M:%S');
  
  To get more information about the formats take a look at C<strftime()> of POSIX.pm
  or the manpage C<strftime(3)>.
  
  =head2 gettime()
  
  C<gettime()> returns a POSIX formatted time stamp, @foo in list and $bar in scalar context.
  If the time format isn't set then the default format "%Y-%m-%d %H:%M:%S" will be set
  automatically. You can also set a time format with C<gettime()>.
  
      my $date_time = $lxs->gettime;
  
  Or
  
      my ($date, $time) = $lxs->gettime();
  
  Or
  
      my ($date, $time) = $lxs->gettime('%Y/%m/%d %H:%M:%S');
  
  =head1 EXAMPLES
  
  A very simple perl script could looks like this:
  
      use strict;
      use warnings;
      use Sys::Statistics::Linux;
  
      my $lxs = Sys::Statistics::Linux->new( cpustats => 1 );
      sleep(1);
      my $stat = $lxs->get;
      my $cpu  = $stat->cpustats->{cpu};
  
      print "Statistics for CpuStats (all)\n";
      print "  user      $cpu->{user}\n";
      print "  nice      $cpu->{nice}\n";
      print "  system    $cpu->{system}\n";
      print "  idle      $cpu->{idle}\n";
      print "  ioWait    $cpu->{iowait}\n";
      print "  total     $cpu->{total}\n";
  
  Set and get a time stamp:
  
      use strict;
      use warnings;
      use Sys::Statistics::Linux;
  
      my $lxs = Sys::Statistics::Linux->new();
      $lxs->settime('%Y/%m/%d %H:%M:%S');
      print $lxs->gettime, "\n";
  
  If you want to know how the data structure looks like you can use C<Data::Dumper> to check it:
  
      use strict;
      use warnings;
      use Sys::Statistics::Linux;
      use Data::Dumper;
  
      my $lxs = Sys::Statistics::Linux->new( cpustats => 1 );
      sleep(1);
      my $stat = $lxs->get;
  
      print Dumper($stat);
  
  How to get the top 5 processes with the highest cpu workload:
  
      use strict;
      use warnings;
      use Sys::Statistics::Linux;
  
      my $lxs = Sys::Statistics::Linux->new( processes => 1 );
      sleep(1);
      my $stat = $lxs->get;
      my @top5 = $stat->pstop( ttime => 5 );
  
  =head1 BACKWARD COMPATIBILITY
  
  The old options and keys - CpuStats, NetStats, etc - are still available but deprecated!
  It's not possible to access the statistics via L<Sys::Statistics::Linux::Compilation> and it's
  not possible to call C<search()> and C<psfind()> if you use the old options.
  
  You should use the new options and access the statistics over the accessors
  
      $stats->cpustats
  
  or directly with
  
      $stats->{cpustats}
  
  =head1 PREREQUISITES
  
      Carp
      POSIX
      Test::More
      Time::HiRes
      UNIVERSAL
  
  =head1 EXPORTS
  
  No exports.
  
  =head1 TODOS
  
     * Are there any wishs from your side? Send me a mail!
  
  =head1 REPORTING BUGS
  
  Please report all bugs to <jschulz.cpan(at)bloonix.de>.
  
  =head1 AUTHOR
  
  Jonny Schulz <jschulz.cpan(at)bloonix.de>.
  
  =head1 COPYRIGHT
  
  Copyright (C) 2006-2008 by Jonny Schulz. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
  
  package Sys::Statistics::Linux;
  our $VERSION = '0.66';
  
  use strict;
  use warnings;
  use Carp qw(croak);
  use POSIX qw(strftime);
  use UNIVERSAL;
  use Sys::Statistics::Linux::Compilation;
  
  sub new {
      my $class = shift;
      my $self  = bless { obj => { } }, $class; 
  
      my @options = qw(
          SysInfo   CpuStats  ProcStats
          MemStats  PgSwStats NetStats
          SockStats DiskStats DiskUsage
          LoadAVG   FileStats Processes
      );
  
      foreach my $opt (@options) {
          # backward compatibility
          $self->{opts}->{$opt} = 0;
          $self->{maps}->{$opt} = $opt;
          # new style
          my $lcopt = lc($opt);
          $self->{opts}->{$lcopt} = 0;
          $self->{maps}->{$lcopt} = $opt;
      }
  
      $self->set(@_) if @_;
      return $self;
  }
  
  sub set {
      my $self  = shift;
      my $class = ref $self;
      my $args  = ref($_[0]) eq 'HASH' ? shift : {@_};
      my $opts  = $self->{opts};
      my $obj   = $self->{obj};
      my $maps  = $self->{maps};
      my $pids  = ();
  
      foreach my $opt (keys %$args) {
          if (!exists $opts->{$opt}) {
              croak "$class: invalid option '$opt'";
          }
  
          if (ref($args->{$opt})) {
              $opts->{$opt} = delete $args->{$opt}->{init} || 1;
          } elsif ($args->{$opt} !~ qr/^[012]\z/) {
              croak "$class: invalid value for '$opt'";
          } else {
              $opts->{$opt} = $args->{$opt};
          }
  
          if ($opts->{$opt}) {
              my $package = $class.'::'.$maps->{$opt};
  
              # require module - require know which modules are loaded
              # and doesn't load a module twice.
              my $require = $package;
              $require =~ s/::/\//g;
              $require .= '.pm';
              require $require;
  
              if (!$obj->{$opt}) {
                  if (ref($args->{$opt})) {
                      $obj->{$opt} = $package->new(%{$args->{$opt}});
                  } else {
                      $obj->{$opt} = $package->new();
                  }
              }
  
              # get initial statistics if the function init() exists
              # and the option is set to 1
              if ($opts->{$opt} == 1 && UNIVERSAL::can($package, 'init')) {
                  $obj->{$opt}->init();
              }
  
          } elsif (exists $obj->{$opt}) {
              delete $obj->{$opt};
          }
      }
  }
  
  sub init {
      my $self  = shift;
      my $class = ref $self;
      my $maps  = $self->{maps};
  
      foreach my $opt (keys %{$self->{opts}}) {
          if ($self->{opts}->{$opt} > 0 && UNIVERSAL::can(ref($self->{obj}->{$opt}), 'init')) {
              $self->{obj}->{$opt}->init();
          }
      }
  }
  
  sub get {
      my ($self, $time) = @_;
      sleep $time if $time;
      my %stat = ();
  
      foreach my $opt (keys %{$self->{opts}}) {
          if ($self->{opts}->{$opt}) {
              $stat{$opt} = $self->{obj}->{$opt}->get();
              if ($opt eq 'netstats') {
                  $stat{netinfo} = $self->{obj}->{$opt}->get_raw();
              }
          }
      }
  
      return Sys::Statistics::Linux::Compilation->new(\%stat);
  }
  
  sub settime {
      my $self = shift;
      my $format = @_ ? shift : '%Y-%m-%d %H:%M:%S';
      $self->{timeformat} = $format;
  }
  
  sub gettime {
      my $self = shift;
      $self->settime(@_) unless $self->{timeformat};
      my $tm = strftime($self->{timeformat}, localtime);
      return wantarray ? split /\s+/, $tm : $tm;
  }
  
  1;
SYS_STATISTICS_LINUX

$fatpacked{"Sys/Statistics/Linux/Compilation.pm"} = <<'SYS_STATISTICS_LINUX_COMPILATION';
  =head1 NAME
  
  Sys::Statistics::Linux::Compilation - Statistics compilation.
  
  =head1 SYNOPSIS
  
      use Sys::Statistics::Linux;
  
      my $lxs  = Sys::Statistics::Linux->new( loadavg => 1 );
      my $stat = $lxs->get;
  
      foreach my $key ($stat->loadavg) {
          print $key, " ", $stat->loadavg($key), "\n";
      }
  
      # or
  
      use Sys::Statistics::Linux::LoadAVG;
      use Sys::Statistics::Linux::Compilation;
  
      my $lxs  = Sys::Statistics::Linux::LoadAVG->new();
      my $load = $lxs->get;
      my $stat = Sys::Statistics::Linux::Compilation->new({ loadavg => $load });
  
      foreach my $key ($stat->loadavg) {
          print $key, " ", $stat->loadavg($key), "\n";
      }
  
      # or
  
      foreach my $key ($stat->loadavg) {
          print $key, " ", $stat->loadavg->{$key}, "\n";
      }
  
  =head1 DESCRIPTION
  
  This module provides different methods to access and filter the statistics compilation.
  
  =head1 METHODS
  
  =head2 new()
  
  Create a new C<Sys::Statistics::Linux::Compilation> object. This creator is only useful if you
  don't call C<get()> of C<Sys::Statistics::Linux>. You can create a new object with:
  
      my $lxs  = Sys::Statistics::Linux::LoadAVG->new();
      my $load = $lxs->get;
      my $stat = Sys::Statistics::Linux::Compilation->new({ loadavg => $load });
  
  =head2 Statistic methods
  
  =over 4
  
  =item sysinfo()
  
  =item cpustats()
  
  =item procstats()
  
  =item memstats()
  
  =item pgswstats()
  
  =item netstats()
  
  =item netinfo()
  
  C<netinfo()> provides raw data - no deltas.
  
  =item sockstats()
  
  =item diskstats()
  
  =item diskusage()
  
  =item loadavg()
  
  =item filestats()
  
  =item processes()
  
  =back
  
  All methods returns the statistics as a hash reference in scalar context. In list all methods
  returns the first level keys of the statistics. Example:
  
      my $net  = $stat->netstats;                 # netstats as a hash reference
      my @dev  = $stat->netstats;                 # the devices eth0, eth1, ...
      my $eth0 = $stat->netstats('eth0');         # eth0 statistics as a hash reference
      my @keys = $stat->netstats('eth0');         # the statistic keys
      my @vals = $stat->netstats('eth0', @keys);  # the values for the passed device and @keys
      my $val  = $stat->netstats('eth0', $key);   # the value for the passed device and key
  
  Sorted ...
  
      my @dev  = sort $stat->netstats;
      my @keys = sort $stat->netstats('eth0');
  
  =head2 pstop()
  
  This method is looking for top processes and returns a sorted list of PIDs as an array or
  array reference depending on the context. It expected two values: a key name and the number
  of top processes to return.
  
  As example you want to get the top 5 processes with the highest cpu usage:
  
      my @top5 = $stat->pstop( ttime => 5 );
      # or as a reference
      my $top5 = $stat->pstop( ttime => 5 );
  
  If you want to get all processes:
  
      my @top_all = $stat->pstop( ttime => $FALSE );
      # or just
      my @top_all = $stat->pstop( 'ttime' );
  
  =head2 search(), psfind()
  
  Both methods provides a simple scan engine to find special statistics. Both methods except a filter
  as a hash reference. It's possible to pass the statistics as second argument if the data is not stored
  in the object.
  
  The method C<search()> scans for statistics and rebuilds the hash tree until that keys that matched
  your filter and returns the hits as a hash reference.
  
      my $hits = $stat->search({
          processes => {
              cmd   => qr/\[su\]/,
              owner => qr/root/
          },
          cpustats => {
              idle   => 'lt:10',
              iowait => 'gt:10'
          },
          diskusage => {
              '/dev/sda1' => {
                  usageper => 'gt:80'
              }
          }
      });
  
  This would return the following matches:
  
      * processes with the command "[su]"
      * processes with the owner "root"
      * all cpu where "idle" is less than 50
      * all cpu where "iowait" is grather than 10
      * only disk '/dev/sda1' if "usageper" is grather than 80
  
  The method C<psfind()> scans for processes only and returns a array reference with all process
  IDs that matched the filter. Example:
  
      my $pids = $stat->psfind({ cmd => qr/init/, owner => 'eq:apache' });
  
  This would return the following process ids:
  
      * processes that matched the command "init"
      * processes with the owner "apache"
  
  There are different match operators available:
  
      gt  -  grather than
      lt  -  less than
      eq  -  is equal
      ne  -  is not equal
  
  Notation examples:
  
      gt:50
      lt:50
      eq:50
      ne:50
  
  Both argumnents have to be set as a hash reference.
  
  Note: the operators < > = ! are not available any more. It's possible that in further releases
  could be different changes for C<search()> and C<psfind()>. So please take a look to the 
  documentation if you use it.
  
  =head1 EXPORTS
  
  No exports.
  
  =head1 TODOS
  
     * Are there any wishs from your side? Send me a mail!
  
  =head1 REPORTING BUGS
  
  Please report all bugs to <jschulz.cpan(at)bloonix.de>.
  
  =head1 AUTHOR
  
  Jonny Schulz <jschulz.cpan(at)bloonix.de>.
  
  Thanks to Moritz Lenz for his suggestion for the name of this module.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2007 by Jonny Schulz. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
  
  package Sys::Statistics::Linux::Compilation;
  
  use strict;
  use warnings;
  use Carp qw(croak);
  
  our $VERSION = '0.10';
  
  # Creating the statistics accessors
  BEGIN {
      foreach my $stat (qw/sysinfo procstats memstats sockstats loadavg filestats/) {
          no strict 'refs';
          *{$stat} = sub {
              use strict 'refs';
              my ($self, @keys) = @_;
              return () unless $self->{$stat};
              if (@keys) {
                  return @{$self->{$stat}}{@keys};
              }
              return wantarray ? keys %{$self->{$stat}} : $self->{$stat};
          };
      }
      foreach my $stat (qw/cpustats pgswstats netstats netinfo diskstats diskusage processes/) {
          no strict 'refs';
          *{$stat} = sub {
              use strict 'refs';
              my ($self, $sub, @keys) = @_;
              return () unless $self->{$stat};
              if ($sub) {
                  my $ref = $self->{$stat};
                  return () unless exists $ref->{$sub};
                  if (@keys) {
                      return @{$ref->{$sub}}{@keys};
                  } else {
                      return wantarray ? keys %{$ref->{$sub}} : $ref->{$sub};
                  }
              }
              return wantarray ? keys %{$self->{$stat}} : $self->{$stat};
          };
      }
  }
  
  sub new {
      my ($class, $stats) = @_;
      unless (ref($stats) eq 'HASH') {
          croak 'Usage: $class->new( \%statistics )';
      }
      return bless $stats, $class;
  }
  
  sub search {
      my $self   = shift;
      my $filter = ref($_[0]) eq 'HASH' ? shift : {@_};
      my $class  = ref($self);
      my %hits   = ();
  
      foreach my $opt (keys %{$filter}) {
  
          unless (ref($filter->{$opt}) eq 'HASH') {
              croak "$class: not a hash ref opt '$opt'";
          }
  
          # next if the object isn't loaded
          next unless exists $self->{$opt};
          my $fref = $filter->{$opt};
          my $proc = $self->{$opt};
          my $subref;
  
          # we search for matches for each key that is defined
          # in %filter and rebuild the tree until that key that
          # matched the searched string
  
          foreach my $x (keys %{$fref}) {
              if (ref($fref->{$x}) eq 'HASH') {
                  # if the key $proc->{eth0} doesn't exists
                  # then we continue with the next defined filter
                  next unless exists $proc->{$x};
                  $subref = $proc->{$x};
  
                  while ( my ($name, $value) = each %{$fref->{$x}} ) {
                      if (exists $subref->{$name} && $self->_compare($subref->{$name}, $value)) {
                          $hits{$opt}{$x}{$name} = $subref->{$name};
                      }
                  }
              } else {
                  foreach my $key (keys %{$proc}) {
                      if (ref($proc->{$key}) eq 'HASH') {
                          $subref = $proc->{$key};
                          if (ref $subref->{$x} eq 'HASH') {
                              foreach my $y (keys %{$subref->{$x}}) {
                                  if ($self->_compare($subref->{$x}->{$y}, $fref->{$x})) {
                                      $hits{$opt}{$key}{$x}{$y} = $subref->{$x}->{$y};
                                  }
                              }
                          } elsif (defined $subref->{$x} && $self->_compare($subref->{$x}, $fref->{$x})) {
                              $hits{$opt}{$key}{$x} = $subref->{$x};
                          }
                      } else { # must be a scalar now
                          if (defined $proc->{$x} && $self->_compare($proc->{$x}, $fref->{$x})) {
                              $hits{$opt}{$x} = $proc->{$x}
                          }
                          last;
                      }
                  }
              }
          }
      }
  
      return wantarray ? %hits : \%hits;
  }
  
  sub psfind {
      my $self   = shift;
      my $filter = ref($_[0]) eq 'HASH' ? shift : {@_};
      my $proc   = $self->{processes} or return undef;
      my @hits   = ();
  
      PID: foreach my $pid (keys %{$proc}) {
          my $proc = $proc->{$pid};
          while ( my ($key, $value) = each %{$filter} ) {
              if (exists $proc->{$key}) {
                  if (ref $proc->{$key} eq 'HASH') {
                      foreach my $v (values %{$proc->{$key}}) {
                          if ($self->_compare($v, $value)) {
                              push @hits, $pid;
                              next PID;
                          }
                      }
                  } elsif ($self->_compare($proc->{$key}, $value)) {
                      push @hits, $pid;
                      next PID;
                  }
              }
          }
      }
  
      return wantarray ? @hits : \@hits;
  }
  
  sub pstop {
      my ($self, $key, $count) = @_;
      unless ($key) {
          croak 'Usage: pstop( $key => $count )';
      }
      my $proc = $self->{processes};
      my @top = (
          map { $_->[0] }
          reverse sort { $a->[1] <=> $b->[1] }
          map { [ $_, $proc->{$_}->{$key} ] } keys %{$proc}
      );
      if ($count) {
          @top = @top[0..--$count];
      }
      return wantarray ? @top : \@top;
  }
  
  #
  # private stuff
  #
  
  sub _compare {
      my ($self, $x, $y) = @_;
  
      if (ref($y) eq 'Regexp') {
          return $x =~ $y;
      } elsif ($y =~ s/^eq://) {
          return $x eq $y;
      } elsif ($y =~ s/^ne://) {
          return $x ne $y;
      } elsif ($y =~ s/^gt://) {
          return $x > $y;
      } elsif ($y =~ s/^lt://) {
          return $x < $y;
      } else {
          croak ref($self).": bad search() / psfind() operator '$y'";
      }
  
      return undef;
  }
  
  1;
SYS_STATISTICS_LINUX_COMPILATION

$fatpacked{"Sys/Statistics/Linux/CpuStats.pm"} = <<'SYS_STATISTICS_LINUX_CPUSTATS';
  =head1 NAME
  
  Sys::Statistics::Linux::CpuStats - Collect linux cpu statistics.
  
  =head1 SYNOPSIS
  
      use Sys::Statistics::Linux::CpuStats;
  
      my $lxs = Sys::Statistics::Linux::CpuStats->new;
      $lxs->init;
      sleep 1;
      my $stats = $lxs->get;
  
  Or
  
      my $lxs = Sys::Statistics::Linux::CpuStats->new(initfile => $file);
      $lxs->init;
      my $stats = $lxs->get;
  
  =head1 DESCRIPTION
  
  Sys::Statistics::Linux::CpuStats gathers cpu statistics from the virtual
  F</proc> filesystem (procfs).
  
  For more information read the documentation of the front-end module
  L<Sys::Statistics::Linux>.
  
  =head1 CPU STATISTICS
  
  Generated by F</proc/stat> for each cpu (cpu0, cpu1 ...). F<cpu> without
  a number is the summary.
  
      user    -  Percentage of CPU utilization at the user level.
      nice    -  Percentage of CPU utilization at the user level with nice priority.
      system  -  Percentage of CPU utilization at the system level.
      idle    -  Percentage of time the CPU is in idle state.
      total   -  Total percentage of CPU utilization.
  
  Statistics with kernels >= 2.6.
  
      iowait  -  Percentage of time the CPU is in idle state because an I/O operation
                 is waiting to complete.
      irq     -  Percentage of time the CPU is servicing interrupts.
      softirq -  Percentage of time the CPU is servicing softirqs.
      steal   -  Percentage of stolen CPU time, which is the time spent in other
                 operating systems when running in a virtualized environment (>=2.6.11).
  
  =head1 METHODS
  
  =head2 new()
  
  Call C<new()> to create a new object.
  
      my $lxs = Sys::Statistics::Linux::CpuStats->new;
  
  Maybe you want to store/load the initial statistics to/from a file:
  
      my $lxs = Sys::Statistics::Linux::CpuStats->new(initfile => '/tmp/cpustats.yml');
  
  If you set C<initfile> it's not necessary to call sleep before C<get()>.
  
  It's also possible to set the path to the proc filesystem.
  
       Sys::Statistics::Linux::CpuStats->new(
          files => {
              # This is the default
              path => '/proc'
              stat => 'stat',
          }
      );
  
  =head2 init()
  
  Call C<init()> to initialize the statistics.
  
      $lxs->init;
  
  =head2 get()
  
  Call C<get()> to get the statistics. C<get()> returns the statistics as a hash reference.
  
      my $stats = $lxs->get;
  
  =head2 raw()
  
  Get raw values.
  
  =head1 EXPORTS
  
  No exports.
  
  =head1 SEE ALSO
  
  B<proc(5)>
  
  =head1 REPORTING BUGS
  
  Please report all bugs to <jschulz.cpan(at)bloonix.de>.
  
  =head1 AUTHOR
  
  Jonny Schulz <jschulz.cpan(at)bloonix.de>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2007 by Jonny Schulz. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
  
  package Sys::Statistics::Linux::CpuStats;
  
  use strict;
  use warnings;
  use Carp qw(croak);
  
  our $VERSION = '0.20';
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my %self = (
          files => {
              path => '/proc',
              stat => 'stat',
          }
      );
  
      if (defined $opts->{initfile}) {
          require YAML::Syck;
          $self{initfile} = $opts->{initfile};
      }
  
      foreach my $file (keys %{ $opts->{files} }) {
          $self{files}{$file} = $opts->{files}->{$file};
      }
  
      return bless \%self, $class;
  }
  
  sub raw {
      my $self = shift;
      my $stat = $self->_load;
      return $stat;
  }
  
  sub init {
      my $self = shift;
  
      if ($self->{initfile} && -r $self->{initfile}) {
          $self->{init} = YAML::Syck::LoadFile($self->{initfile});
      } else {
          $self->{init} = $self->_load;
      }
  }
  
  sub get {
      my $self  = shift;
      my $class = ref $self;
  
      if (!exists $self->{init}) {
          croak "$class: there are no initial statistics defined";
      }
  
      $self->{stats} = $self->_load;
      $self->_deltas;
  
      if ($self->{initfile}) {
          YAML::Syck::DumpFile($self->{initfile}, $self->{init});
      }
  
      return $self->{stats};
  }
  
  #
  # private stuff
  #
  
  sub _load {
      my $self  = shift;
      my $class = ref $self;
      my $file  = $self->{files};
      my (%stats, $iowait, $irq, $softirq, $steal);
  
      my $filename = $file->{path} ? "$file->{path}/$file->{stat}" : $file->{stat};
      open my $fh, '<', $filename or croak "$class: unable to open $filename ($!)";
  
      while (my $line = <$fh>) {
          if ($line =~ /^(cpu.*?)\s+(.*)$/) {
              my $cpu = \%{$stats{$1}};
              (@{$cpu}{qw(user nice system idle)},
                  $iowait, $irq, $softirq, $steal) = split /\s+/, $2;
              # iowait, irq and softirq are only set 
              # by kernel versions higher than 2.4.
              # steal is available since 2.6.11.
              $cpu->{iowait}  = $iowait  if defined $iowait;
              $cpu->{irq}     = $irq     if defined $irq;
              $cpu->{softirq} = $softirq if defined $softirq;
              $cpu->{steal}   = $steal   if defined $steal;
          }
      }
  
      close($fh);
      return \%stats;
  }
  
  sub _deltas {
      my $self  = shift;
      my $class = ref $self;
      my $istat = $self->{init};
      my $lstat = $self->{stats};
  
      foreach my $cpu (keys %{$lstat}) {
          my $icpu = $istat->{$cpu};
          my $dcpu = $lstat->{$cpu};
          my $uptime;
  
          while (my ($k, $v) = each %{$dcpu}) {
              if (!defined $icpu->{$k}) {
                  croak "$class: not defined key found '$k'";
              }
  
              if ($v !~ /^\d+\z/ || $dcpu->{$k} !~ /^\d+\z/) {
                  croak "$class: invalid value for key '$k'";
              }
  
              $dcpu->{$k} -= $icpu->{$k};
              $icpu->{$k}  = $v;
              $uptime += $dcpu->{$k};
          }
  
          foreach my $k (keys %{$dcpu}) {
              if ($dcpu->{$k} > 0) {
                  $dcpu->{$k} = sprintf('%.2f', 100 * $dcpu->{$k} / $uptime);
              } elsif ($dcpu->{$k} < 0) {
                  $dcpu->{$k} = sprintf('%.2f', 0);
              } else {
                  $dcpu->{$k} = sprintf('%.2f', $dcpu->{$k});
              }
          }
  
          $dcpu->{total} = sprintf('%.2f', 100 - $dcpu->{idle});
      }
  }
  
  1;
SYS_STATISTICS_LINUX_CPUSTATS

$fatpacked{"Sys/Statistics/Linux/DiskStats.pm"} = <<'SYS_STATISTICS_LINUX_DISKSTATS';
  =head1 NAME
  
  Sys::Statistics::Linux::DiskStats - Collect linux disk statistics.
  
  =head1 SYNOPSIS
  
      use Sys::Statistics::Linux::DiskStats;
  
      my $lxs = Sys::Statistics::Linux::DiskStats->new;
      $lxs->init;
      sleep 1;
      my $stat = $lxs->get;
  
  Or
  
      my $lxs = Sys::Statistics::Linux::DiskStats->new(initfile => $file);
      $lxs->init;
      my $stat = $lxs->get;
  
  =head1 DESCRIPTION
  
  Sys::Statistics::Linux::DiskStats gathers disk statistics from the virtual F</proc> filesystem (procfs).
  
  For more information read the documentation of the front-end module L<Sys::Statistics::Linux>.
  
  =head1 DISK STATISTICS
  
  Generated by F</proc/diskstats> or F</proc/partitions>.
  
      major   -  The mayor number of the disk
      minor   -  The minor number of the disk
      rdreq   -  Number of read requests that were made to physical disk per second.
      rdbyt   -  Number of bytes that were read from physical disk per second.
      wrtreq  -  Number of write requests that were made to physical disk per second.
      wrtbyt  -  Number of bytes that were written to physical disk per second.
      ttreq   -  Total number of requests were made from/to physical disk per second.
      ttbyt   -  Total number of bytes transmitted from/to physical disk per second.
  
  =head1 METHODS
  
  =head2 new()
  
  Call C<new()> to create a new object.
  
      my $lxs = Sys::Statistics::Linux::DiskStats->new;
  
  Maybe you want to store/load the initial statistics to/from a file:
  
      my $lxs = Sys::Statistics::Linux::DiskStats->new(initfile => '/tmp/diskstats.yml');
  
  If you set C<initfile> it's not necessary to call sleep before C<get()>.
  
  It's also possible to set the path to the proc filesystem.
  
       Sys::Statistics::Linux::DiskStats->new(
          files => {
              # This is the default
              path       => '/proc',
              diskstats  => 'diskstats',
              partitions => 'partitions',
          }
      );
  
  =head2 init()
  
  Call C<init()> to initialize the statistics.
  
      $lxs->init;
  
  =head2 get()
  
  Call C<get()> to get the statistics. C<get()> returns the statistics as a hash reference.
  
      my $stat = $lxs->get;
  
  =head2 raw()
  
  Get raw values.
  
  =head1 EXPORTS
  
  No exports.
  
  =head1 SEE ALSO
  
  B<proc(5)>
  
  =head1 REPORTING BUGS
  
  Please report all bugs to <jschulz.cpan(at)bloonix.de>.
  
  =head1 AUTHOR
  
  Jonny Schulz <jschulz.cpan(at)bloonix.de>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2007 by Jonny Schulz. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
  
  package Sys::Statistics::Linux::DiskStats;
  
  use strict;
  use warnings;
  use Carp qw(croak);
  use Time::HiRes;
  
  our $VERSION = '0.24';
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my %self = (
          files => {
              path       => '/proc',
              diskstats  => 'diskstats',
              partitions => 'partitions',
          },
          # --------------------------------------------------------------
          # The sectors are equivalent with blocks and have a size of 512
          # bytes since 2.4 kernels. This value is needed to calculate the
          # amount of disk i/o's in bytes.
          # --------------------------------------------------------------
          blocksize => 512,
      );
  
      if (defined $opts->{initfile}) {
          require YAML::Syck;
          $self{initfile} = $opts->{initfile};
      }
  
      foreach my $file (keys %{ $opts->{files} }) {
          $self{files}{$file} = $opts->{files}->{$file};
      }
  
      if ($opts->{blocksize}) {
          $self{blocksize} = $opts->{blocksize};
      }
  
      return bless \%self, $class;
  }
  
  sub init {
      my $self = shift;
  
      if ($self->{initfile} && -r $self->{initfile}) {
          $self->{init} = YAML::Syck::LoadFile($self->{initfile});
          $self->{time} = delete $self->{init}->{time};
      } else {
          $self->{time} = Time::HiRes::gettimeofday();
          $self->{init} = $self->_load;
      }
  }
  
  sub get {
      my $self  = shift;
      my $class = ref $self;
  
      if (!exists $self->{init}) {
          croak "$class: there are no initial statistics defined";
      }
  
      $self->{stats} = $self->_load;
      $self->_deltas;
  
      if ($self->{initfile}) {
          $self->{init}->{time} = $self->{time};
          YAML::Syck::DumpFile($self->{initfile}, $self->{init});
      }
  
      return $self->{stats};
  }
  
  sub raw {
      my $self = shift;
      my $raw  = $self->_load;
  
      return $raw;
  }
  
  #
  # private stuff
  #
  
  sub _load {
      my $self  = shift;
      my $class = ref $self;
      my $file  = $self->{files};
      my $bksz  = $self->{blocksize};
      my (%stats, $fh);
  
      # -----------------------------------------------------------------------------
      # one of the both must be opened for the disk statistics!
      # if diskstats (2.6) doesn't exists then let's try to read
      # the partitions (2.4)
      #
      # /usr/src/linux/Documentation/iostat.txt shortcut
      #
      # ... the statistics fields are those after the device name.
      #
      # Field  1 -- # of reads issued
      #     This is the total number of reads completed successfully.
      # Field  2 -- # of reads merged, field 6 -- # of writes merged
      #     Reads and writes which are adjacent to each other may be merged for
      #     efficiency.  Thus two 4K reads may become one 8K read before it is
      #     ultimately handed to the disk, and so it will be counted (and queued)
      #     as only one I/O.  This field lets you know how often this was done.
      # Field  3 -- # of sectors read
      #     This is the total number of sectors read successfully.
      # Field  4 -- # of milliseconds spent reading
      #     This is the total number of milliseconds spent by all reads (as
      #     measured from __make_request() to end_that_request_last()).
      # Field  5 -- # of writes completed
      #     This is the total number of writes completed successfully.
      # Field  7 -- # of sectors written
      #     This is the total number of sectors written successfully.
      # Field  8 -- # of milliseconds spent writing
      #     This is the total number of milliseconds spent by all writes (as
      #     measured from __make_request() to end_that_request_last()).
      # Field  9 -- # of I/Os currently in progress
      #     The only field that should go to zero. Incremented as requests are
      #     given to appropriate request_queue_t and decremented as they finish.
      # Field 10 -- # of milliseconds spent doing I/Os
      #     This field is increases so long as field 9 is nonzero.
      # Field 11 -- weighted # of milliseconds spent doing I/Os
      #     This field is incremented at each I/O start, I/O completion, I/O
      #     merge, or read of these stats by the number of I/Os in progress
      #     (field 9) times the number of milliseconds spent doing I/O since the
      #     last update of this field.  This can provide an easy measure of both
      #     I/O completion time and the backlog that may be accumulating.
      # -----------------------------------------------------------------------------
  
      my $file_diskstats  = $file->{path} ? "$file->{path}/$file->{diskstats}"  : $file->{diskstats};
      my $file_partitions = $file->{path} ? "$file->{path}/$file->{partitions}" : $file->{partitions};
  
      if (open $fh, '<', $file_diskstats) {
          while (my $line = <$fh>) {
              #                   --      --      --      F1     F2     F3     F4     F5     F6     F7     F8    F9    F10   F11
              #                   $1      $2      $3      $4     --     $5     --     $6     --     $7     --    --    --    --
              if ($line =~ /^\s+(\d+)\s+(\d+)\s+(.+?)\s+(\d+)\s+\d+\s+(\d+)\s+\d+\s+(\d+)\s+\d+\s+(\d+)\s+\d+\s+\d+\s+\d+\s+\d+$/) {
                  for my $x ($stats{$3}) { # $3 -> the device name
                      $x->{major}   = $1;
                      $x->{minor}   = $2;
                      $x->{rdreq}   = $4;         # Field 1
                      $x->{rdbyt}   = $5 * $bksz; # Field 3
                      $x->{wrtreq}  = $6;         # Field 5
                      $x->{wrtbyt}  = $7 * $bksz; # Field 7
                      $x->{ttreq}  += $x->{rdreq} + $x->{wrtreq};
                      $x->{ttbyt}  += $x->{rdbyt} + $x->{wrtbyt};
                  }
              }
  
              # -----------------------------------------------------------------------------
              # Field  1 -- # of reads issued
              #     This is the total number of reads issued to this partition.
              # Field  2 -- # of sectors read
              #     This is the total number of sectors requested to be read from this
              #     partition.
              # Field  3 -- # of writes issued
              #     This is the total number of writes issued to this partition.
              # Field  4 -- # of sectors written
              #     This is the total number of sectors requested to be written to
              #     this partition.
              # -----------------------------------------------------------------------------
              #                      --      --      --      F1      F2      F3      F4
              #                      $1      $2      $3      $4      $5      $6      $7
              elsif ($line =~ /^\s+(\d+)\s+(\d+)\s+(.+?)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)$/) {
                  for my $x ($stats{$3}) { # $3 -> the device name
                      $x->{major}   = $1;
                      $x->{minor}   = $2;
                      $x->{rdreq}   = $4;         # Field 1
                      $x->{rdbyt}   = $5 * $bksz; # Field 2
                      $x->{wrtreq}  = $6;         # Field 3
                      $x->{wrtbyt}  = $7 * $bksz; # Field 4
                      $x->{ttreq}  += $x->{rdreq} + $x->{wrtreq};
                      $x->{ttbyt}  += $x->{rdbyt} + $x->{wrtbyt};
                  }
              }
          }
          close($fh);
      } elsif (open $fh, '<', $file_partitions) {
          while (my $line = <$fh>) {
              #                           --      --     --     --      F1     F2     F3     F4     F5     F6     F7     F8    F9    F10   F11
              #                           $1      $2     --     $3      $4     --     $5     --     $6     --     $7     --    --    --    --
              next unless $line =~ /^\s+(\d+)\s+(\d+)\s+\d+\s+(.+?)\s+(\d+)\s+\d+\s+(\d+)\s+\d+\s+(\d+)\s+\d+\s+(\d+)\s+\d+\s+\d+\s+\d+\s+\d+$/;
              for my $x ($stats{$3}) { # $3 -> the device name
                  $x->{major}   = $1;
                  $x->{minor}   = $2;
                  $x->{rdreq}   = $4;         # Field 1
                  $x->{rdbyt}   = $5 * $bksz; # Field 3
                  $x->{wrtreq}  = $6;         # Field 5
                  $x->{wrtbyt}  = $7 * $bksz; # Field 7
                  $x->{ttreq}  += $x->{rdreq} + $x->{wrtreq};
                  $x->{ttbyt}  += $x->{rdbyt} + $x->{wrtbyt};
              }
          }
          close($fh);
      } else {
          croak "$class: unable to open $file_diskstats or $file_partitions ($!)";
      }
  
      if (!-e $file_diskstats || !scalar %stats) {
          croak "$class: no diskstats found! your system seems not to be compiled with CONFIG_BLK_STATS=y";
      }
  
      return \%stats;
  }
  
  sub _deltas {
      my $self  = shift;
      my $class = ref $self;
      my $istat = $self->{init};
      my $lstat = $self->{stats};
      my $time  = Time::HiRes::gettimeofday();
      my $delta = sprintf('%.2f', $time - $self->{time});
      $self->{time} = $time;
  
      foreach my $dev (keys %{$lstat}) {
          if (!exists $istat->{$dev}) {
              delete $lstat->{$dev};
              next;
          }
  
          my $idev = $istat->{$dev};
          my $ldev = $lstat->{$dev};
  
          while (my ($k, $v) = each %{$ldev}) {
              next if $k =~ /^major\z|^minor\z/;
  
              if (!defined $idev->{$k}) {
                  croak "$class: not defined key found '$k'";
              }
  
              if ($v !~ /^\d+\z/ || $ldev->{$k} !~ /^\d+\z/) {
                  croak "$class: invalid value for key '$k'";
              }
  
              if ($ldev->{$k} == $idev->{$k} || $idev->{$k} > $ldev->{$k}) {
                  $ldev->{$k} = sprintf('%.2f', 0);
              } elsif ($delta > 0) {
                  $ldev->{$k} = sprintf('%.2f', ($ldev->{$k} - $idev->{$k}) / $delta);
              } else {
                  $ldev->{$k} = sprintf('%.2f', $ldev->{$k} - $idev->{$k});
              }
  
              $idev->{$k}  = $v;
          }
      }
  }
  
  1;
SYS_STATISTICS_LINUX_DISKSTATS

$fatpacked{"Sys/Statistics/Linux/DiskUsage.pm"} = <<'SYS_STATISTICS_LINUX_DISKUSAGE';
  =head1 NAME
  
  Sys::Statistics::Linux::DiskUsage - Collect linux disk usage.
  
  =head1 SYNOPSIS
  
      use Sys::Statistics::Linux::DiskUsage;
  
      my $lxs  = new Sys::Statistics::Linux::DiskUsage;
      my $stat = $lxs->get;
  
  =head1 DESCRIPTION
  
  Sys::Statistics::Linux::DiskUsage gathers the disk usage with the command C<df>.
  
  For more information read the documentation of the front-end module L<Sys::Statistics::Linux>.
  
  =head1 DISK USAGE INFORMATIONS
  
  Generated by F</bin/df -kP>.
  
      total       -  The total size of the disk.
      usage       -  The used disk space in kilobytes.
      free        -  The free disk space in kilobytes.
      usageper    -  The used disk space in percent.
      mountpoint  -  The moint point of the disk.
  
  =head2 GLOBAL VARS
  
  If you want to change the path or arguments for C<df> you can use the following
  variables...
  
      $Sys::Statistics::Linux::DiskUsage::DF_PATH = '/bin';
      $Sys::Statistics::Linux::DiskUsage::DF_CMD  = 'df -akP';
  
  Example:
  
      use Sys::Statistics::Linux;
      use Sys::Statistics::Linux::DiskUsage;
      $Sys::Statistics::Linux::DiskUsage::DF_CMD = 'df -akP';
  
      my $sys  = Sys::Statistics::Linux->new(diskusage => 1);
      my $disk = $sys->get;
  
  =head1 METHODS
  
  =head2 new()
  
  Call C<new()> to create a new object.
  
      my $lxs = Sys::Statistics::Linux::DiskUsage->new;
  
  It's possible to set the path to df.
  
       Sys::Statistics::Linux::DiskUsage->new(
          cmd => {
              # This is the default
              path => '/bin',
              df   => 'df -kP 2>/dev/null',
          }
      );
  
  =head2 get()
  
  Call C<get()> to get the statistics. C<get()> returns the statistics as a hash reference.
  
      my $stat = $lxs->get;
  
  =head1 EXPORTS
  
  No exports.
  
  =head1 SEE ALSO
  
  B<df(1)>
  
  =head1 REPORTING BUGS
  
  Please report all bugs to <jschulz.cpan(at)bloonix.de>.
  
  =head1 AUTHOR
  
  Jonny Schulz <jschulz.cpan(at)bloonix.de>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2007 by Jonny Schulz. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
  
  package Sys::Statistics::Linux::DiskUsage;
  
  use strict;
  use warnings;
  use Carp qw(croak);
  
  our $VERSION = '0.14';
  our $DF_PATH = undef;
  our $DF_CMD  = undef;
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my %self = (
          cmd => {
              path => '/bin',
              df   => 'df -kP 2>/dev/null',
          }
      );
  
      foreach my $p (keys %{ $opts->{cmd} }) {
          $self{cmd}{$p} = $opts->{cmd}->{$p};
      }
  
      return bless \%self, $class;
  }
  
  sub get {
      my $self   = shift;
      my $class  = ref $self;
      my $cmd    = $self->{cmd};
      my $df_cmd = $DF_CMD || $cmd->{df};
      my (%disk_usage);
  
      local $ENV{PATH} = $DF_PATH || $cmd->{path};
      open my $fh, "$df_cmd|" or croak "$class: unable to execute '$df_cmd' ($!)";
  
      # filter the header
      {my $null = <$fh>;}
  
      while (my $line = <$fh>) {
          next unless $line =~ /^(.+?)\s+(.+)$/;
  
          @{$disk_usage{$1}}{qw(
              total
              usage
              free
              usageper
              mountpoint
          )} = (split /\s+/, $2)[0..4];
  
          $disk_usage{$1}{usageper} =~ s/%//;
      }
  
      close($fh);
      return \%disk_usage;
  }
  
  1;
SYS_STATISTICS_LINUX_DISKUSAGE

$fatpacked{"Sys/Statistics/Linux/FileStats.pm"} = <<'SYS_STATISTICS_LINUX_FILESTATS';
  =head1 NAME
  
  Sys::Statistics::Linux::FileStats - Collect linux file statistics.
  
  =head1 SYNOPSIS
  
      use Sys::Statistics::Linux::FileStats;
  
      my $lxs  = Sys::Statistics::Linux::FileStats->new;
      my $stat = $lxs->get;
  
  =head1 DESCRIPTION
  
  Sys::Statistics::Linux::FileStats gathers file statistics from the virtual F</proc> filesystem (procfs).
  
  For more information read the documentation of the front-end module L<Sys::Statistics::Linux>.
  
  =head1 FILE STATISTICS
  
  Generated by F</proc/sys/fs/file-nr>, F</proc/sys/fs/inode-nr> and F</proc/sys/fs/dentry-state>.
  
      fhalloc    -  Number of allocated file handles.
      fhfree     -  Number of free file handles.
      fhmax      -  Number of maximum file handles.
      inalloc    -  Number of allocated inodes.
      infree     -  Number of free inodes.
      inmax      -  Number of maximum inodes.
      dentries   -  Dirty directory cache entries.
      unused     -  Free diretory cache size.
      agelimit   -  Time in seconds the dirty cache entries can be reclaimed.
      wantpages  -  Pages that are requested by the system when memory is short.
  
  =head1 METHODS
  
  =head2 new()
  
  Call C<new()> to create a new object.
  
      my $lxs = Sys::Statistics::Linux::FileStats->new;
  
  It's possible to set the path to the proc filesystem.
  
       Sys::Statistics::Linux::FileStats->new(
          files => {
              # This is the default
              path     => '/proc',
              file_nr  => 'sys/fs/file-nr',
              inode_nr => 'sys/fs/inode-nr',
              dentries => 'sys/fs/dentry-state',
          }
      );
  
  =head2 get()
  
  Call C<get()> to get the statistics. C<get()> returns the statistics as a hash reference.
  
      my $stat = $lxs->get;
  
  =head1 EXPORTS
  
  No exports.
  
  =head1 SEE ALSO
  
  B<proc(5)>
  
  =head1 REPORTING BUGS
  
  Please report all bugs to <jschulz.cpan(at)bloonix.de>.
  
  =head1 AUTHOR
  
  Jonny Schulz <jschulz.cpan(at)bloonix.de>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2007 by Jonny Schulz. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
  
  package Sys::Statistics::Linux::FileStats;
  
  use strict;
  use warnings;
  use Carp qw(croak);
  
  our $VERSION = '0.09';
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my %self = (
          files => {
              path     => '/proc',
              file_nr  => 'sys/fs/file-nr',
              inode_nr => 'sys/fs/inode-nr',
              dentries => 'sys/fs/dentry-state',
          }
      );
  
      foreach my $file (keys %{ $opts->{files} }) {
          $self{files}{$file} = $opts->{files}->{$file};
      }
  
      return bless \%self, $class;
  }
  
  sub get {
      my $self  = shift;
      my $class = ref $self;
      my $file  = $self->{files};
      my $stats = { };
  
      $self->{stats} = $stats;
      $self->_get_file_nr;
      $self->_get_inode_nr;
      $self->_get_dentries;
  
      return $stats;
  }
  
  sub _get_file_nr {
      my $self  = shift;
      my $class = ref $self;
      my $file  = $self->{files};
      my $stats = $self->{stats};
  
      my $filename = $file->{path} ? "$file->{path}/$file->{file_nr}" : $file->{file_nr};
      open my $fh, '<', $filename or croak "$class: unable to open $filename ($!)";
      @$stats{qw(fhalloc fhfree fhmax)} = (split /\s+/, <$fh>)[0..2];
      close($fh);
  }
  
  sub _get_inode_nr {
      my $self  = shift;
      my $class = ref $self;
      my $file  = $self->{files};
      my $stats = $self->{stats};
  
      my $filename = $file->{path} ? "$file->{path}/$file->{inode_nr}" : $file->{inode_nr};
      open my $fh, '<', $filename or croak "$class: unable to open $filename ($!)";
      @$stats{qw(inalloc infree)} = (split /\s+/, <$fh>)[0..1];
      $stats->{inmax} = $stats->{inalloc} + $stats->{infree};
      close($fh);
  }
  
  sub _get_dentries {
      my $self  = shift;
      my $class = ref $self;
      my $file  = $self->{files};
      my $stats = $self->{stats};
  
      my $filename = $file->{path} ? "$file->{path}/$file->{dentries}" : $file->{dentries};
      open my $fh, '<', $filename or croak "$class: unable to open $filename ($!)";
      @$stats{qw(dentries unused agelimit wantpages)} = (split /\s+/, <$fh>)[0..3];
      close($fh);
  }
  
  1;
SYS_STATISTICS_LINUX_FILESTATS

$fatpacked{"Sys/Statistics/Linux/LoadAVG.pm"} = <<'SYS_STATISTICS_LINUX_LOADAVG';
  =head1 NAME
  
  Sys::Statistics::Linux::LoadAVG - Collect linux load average statistics.
  
  =head1 SYNOPSIS
  
      use Sys::Statistics::Linux::LoadAVG;
  
      my $lxs  = Sys::Statistics::Linux::LoadAVG->new;
      my $stat = $lxs->get;
  
  =head1 DESCRIPTION
  
  Sys::Statistics::Linux::LoadAVG gathers the load average from the virtual F</proc> filesystem (procfs).
  
  For more information read the documentation of the front-end module L<Sys::Statistics::Linux>.
  
  =head1 LOAD AVERAGE STATISTICS
  
  Generated by F</proc/loadavg>.
  
      avg_1   -  The average processor workload of the last minute.
      avg_5   -  The average processor workload of the last five minutes.
      avg_15  -  The average processor workload of the last fifteen minutes.
  
  =head1 METHODS
  
  =head2 new()
  
  Call C<new()> to create a new object.
  
      my $lxs = Sys::Statistics::Linux::LoadAVG->new;
  
  It's possible to set the path to the proc filesystem.
  
       Sys::Statistics::Linux::LoadAVG->new(
          files => {
              # This is the default
              path    => '/proc',
              loadavg => 'loadavg',
          }
      );
  
  =head2 get()
  
  Call C<get()> to get the statistics. C<get()> returns the statistics as a hash reference.
  
      my $stat = $lxs->get;
  
  =head1 EXPORTS
  
  No exports.
  
  =head1 SEE ALSO
  
  B<proc(5)>
  
  =head1 REPORTING BUGS
  
  Please report all bugs to <jschulz.cpan(at)bloonix.de>.
  
  =head1 AUTHOR
  
  Jonny Schulz <jschulz.cpan(at)bloonix.de>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2007 by Jonny Schulz. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
  
  package Sys::Statistics::Linux::LoadAVG;
  
  use strict;
  use warnings;
  use Carp qw(croak);
  
  our $VERSION = '0.08';
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my %self = (
          files => {
              path    => '/proc',
              loadavg => 'loadavg',
          }
      );
  
      foreach my $file (keys %{ $opts->{files} }) {
          $self{files}{$file} = $opts->{files}->{$file};
      }
  
      return bless \%self, $class;
  }
  
  sub get {
      my $self  = shift;
      my $class = ref $self;
      my $file  = $self->{files};
      my %lavg  = ();
  
      my $filename = $file->{path} ? "$file->{path}/$file->{loadavg}" : $file->{loadavg};
      open my $fh, '<', $filename or croak "$class: unable to open $filename ($!)";
  
      ( $lavg{avg_1}
      , $lavg{avg_5}
      , $lavg{avg_15}
      ) = (split /\s+/, <$fh>)[0..2];
  
      close($fh);
      return \%lavg;
  }
  
  1;
SYS_STATISTICS_LINUX_LOADAVG

$fatpacked{"Sys/Statistics/Linux/MemStats.pm"} = <<'SYS_STATISTICS_LINUX_MEMSTATS';
  =head1 NAME
  
  Sys::Statistics::Linux::MemStats - Collect linux memory information.
  
  =head1 SYNOPSIS
  
      use Sys::Statistics::Linux::MemStats;
  
      my $lxs  = Sys::Statistics::Linux::MemStats->new;
      my $stat = $lxs->get;
  
  =head1 DESCRIPTION
  
  Sys::Statistics::Linux::MemStats gathers memory statistics from the virtual F</proc> filesystem (procfs).
  
  For more information read the documentation of the front-end module L<Sys::Statistics::Linux>.
  
  =head1 MEMORY INFORMATIONS
  
  Generated by F</proc/meminfo>.
  
      memused         -  Total size of used memory in kilobytes.
      memfree         -  Total size of free memory in kilobytes.
      memusedper      -  Total size of used memory in percent.
      memtotal        -  Total size of memory in kilobytes.
      buffers         -  Total size of buffers used from memory in kilobytes.
      cached          -  Total size of cached memory in kilobytes.
      realfree        -  Total size of memory is real free (memfree + buffers + cached).
      realfreeper     -  Total size of memory is real free in percent of total memory.
      swapused        -  Total size of swap space is used is kilobytes.
      swapfree        -  Total size of swap space is free in kilobytes.
      swapusedper     -  Total size of swap space is used in percent.
      swaptotal       -  Total size of swap space in kilobytes.
      swapcached      -  Memory that once was swapped out, is swapped back in but still also is in the swapfile.
      active          -  Memory that has been used more recently and usually not reclaimed unless absolutely necessary.
      inactive        -  Memory which has been less recently used and is more eligible to be reclaimed for other purposes.
                         On earlier kernels (2.4) Inact_dirty + Inact_laundry + Inact_clean.
  
      The following statistics are only available by kernels from 2.6.
  
      slab            -  Total size of memory in kilobytes that used by kernel for data structure allocations.
      dirty           -  Total size of memory pages in kilobytes that waits to be written back to disk.
      mapped          -  Total size of memory in kilbytes that is mapped by devices or libraries with mmap.
      writeback       -  Total size of memory that was written back to disk.
      committed_as    -  The amount of memory presently allocated on the system.
  
      The following statistic is only available by kernels from 2.6.9.
  
      commitlimit     -  Total amount of memory currently available to be allocated on the system.
  
  =head1 METHODS
  
  =head2 new()
  
  Call C<new()> to create a new object.
  
      my $lxs = Sys::Statistics::Linux::MemStats->new;
  
  It's possible to set the path to the proc filesystem.
  
       Sys::Statistics::Linux::MemStats->new(
          files => {
              # This is the default
              path    => '/proc',
              meminfo => 'meminfo',
          }
      );
  
  =head2 get()
  
  Call C<get()> to get the statistics. C<get()> returns the statistics as a hash reference.
  
      my $stat = $lxs->get;
  
  =head1 EXPORTS
  
  No exports.
  
  =head1 SEE ALSO
  
  B<proc(5)>
  
  =head1 REPORTING BUGS
  
  Please report all bugs to <jschulz.cpan(at)bloonix.de>.
  
  =head1 AUTHOR
  
  Jonny Schulz <jschulz.cpan(at)bloonix.de>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2007 by Jonny Schulz. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
  
  package Sys::Statistics::Linux::MemStats;
  
  use strict;
  use warnings;
  use Carp qw(croak);
  
  our $VERSION = '0.16';
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my %self = (
          files => {
              path    => '/proc',
              meminfo => 'meminfo',
          }
      );
  
      foreach my $file (keys %{ $opts->{files} }) {
          $self{files}{$file} = $opts->{files}->{$file};
      }
  
      return bless \%self, $class;
  }
  
  sub get {
      my $self    = shift;
      my $class   = ref($self);
      my $file    = $self->{files};
      my %meminfo = ();
  
      my $filename = $file->{path} ? "$file->{path}/$file->{meminfo}" : $file->{meminfo};
      open my $fh, '<', $filename or croak "$class: unable to open $filename ($!)";
  
      # MemTotal:      1035648 kB
      # MemFree:         15220 kB
      # Buffers:          4280 kB
      # Cached:          47664 kB
      # SwapCached:     473988 kB
      # Active:         661992 kB
      # Inactive:       314312 kB
      # HighTotal:      130884 kB
      # HighFree:          264 kB
      # LowTotal:       904764 kB
      # LowFree:         14956 kB
      # SwapTotal:     1951856 kB
      # SwapFree:      1164864 kB
      # Dirty:             520 kB
      # Writeback:           0 kB
      # AnonPages:      908892 kB
      # Mapped:          34308 kB
      # Slab:            19284 kB
      # SReclaimable:     7532 kB
      # SUnreclaim:      11752 kB
      # PageTables:       3056 kB
      # NFS_Unstable:        0 kB
      # Bounce:              0 kB
      # CommitLimit:   2469680 kB
      # Committed_AS:  1699568 kB
      # VmallocTotal:   114680 kB
      # VmallocUsed:     12284 kB
      # VmallocChunk:   100992 kB
  
      # kernel <= 2.4
      # Inact_dirty: 138632 kB
      # Inact_laundry: 35520 kB
      # Inact_clean: 7544 kB
  
      while (my $line = <$fh>) {
          if ($line =~ /^((?:Mem|Swap)(?:Total|Free)|Buffers|Cached|SwapCached|Active|Inactive|
                          Dirty|Writeback|Mapped|Slab|Commit(?:Limit|ted_AS)):\s*(\d+)/x) {
              my ($n, $v) = ($1, $2);
              $n =~ tr/A-Z/a-z/;
              $meminfo{$n} = $v;
          } elsif ($line =~ /^Inact_(?:dirty|laundry|clean):\s*(\d+)/) {
              $meminfo{inactive} += $1;
          }
      }
  
      close($fh);
  
      $meminfo{memused}     = sprintf('%u', $meminfo{memtotal} - $meminfo{memfree});
      $meminfo{memusedper}  = sprintf('%.2f', 100 * $meminfo{memused} / $meminfo{memtotal});
      $meminfo{swapused}    = sprintf('%u', $meminfo{swaptotal} - $meminfo{swapfree});
      $meminfo{realfree}    = sprintf('%u', $meminfo{memfree} + $meminfo{buffers} + $meminfo{cached});
      $meminfo{realfreeper} = sprintf('%.2f', 100 * $meminfo{realfree} / $meminfo{memtotal});
  
      # maybe there is no swap space on the machine
      if (!$meminfo{swaptotal}) {
          $meminfo{swapusedper} = '0.00';
      } else {
          $meminfo{swapusedper} = sprintf('%.2f', 100 * $meminfo{swapused} / $meminfo{swaptotal});
      }
  
      return \%meminfo;
  }
  
  1;
SYS_STATISTICS_LINUX_MEMSTATS

$fatpacked{"Sys/Statistics/Linux/NetStats.pm"} = <<'SYS_STATISTICS_LINUX_NETSTATS';
  =head1 NAME
  
  Sys::Statistics::Linux::NetStats - Collect linux net statistics.
  
  =head1 SYNOPSIS
  
      use Sys::Statistics::Linux::NetStats;
  
      my $lxs = Sys::Statistics::Linux::NetStats->new;
      $lxs->init;
      sleep 1;
      my $stat = $lxs->get;
  
  Or
  
      my $lxs = Sys::Statistics::Linux::NetStats->new(initfile => $file);
      $lxs->init;
      my $stat = $lxs->get;
  
  =head1 DESCRIPTION
  
  Sys::Statistics::Linux::NetStats gathers net statistics from the virtual F</proc> filesystem (procfs).
  
  For more information read the documentation of the front-end module L<Sys::Statistics::Linux>.
  
  =head1 NET STATISTICS
  
  Generated by F</proc/net/dev>.
  
      rxbyt    -  Number of bytes received per second.
      rxpcks   -  Number of packets received per second.
      rxerrs   -  Number of errors that happend while received packets per second.
      rxdrop   -  Number of packets that were dropped per second.
      rxfifo   -  Number of FIFO overruns that happend on received packets per second.
      rxframe  -  Number of carrier errors that happend on received packets per second.
      rxcompr  -  Number of compressed packets received per second.
      rxmulti  -  Number of multicast packets received per second.
      txbyt    -  Number of bytes transmitted per second.
      txpcks   -  Number of packets transmitted per second.
      txerrs   -  Number of errors that happend while transmitting packets per second.
      txdrop   -  Number of packets that were dropped per second.
      txfifo   -  Number of FIFO overruns that happend on transmitted packets per second.
      txcolls  -  Number of collisions that were detected per second.
      txcarr   -  Number of carrier errors that happend on transmitted packets per second.
      txcompr  -  Number of compressed packets transmitted per second.
      ttpcks   -  Number of total packets (received + transmitted) per second.
      ttbyt    -  Number of total bytes (received + transmitted) per second.
  
  =head1 METHODS
  
  =head2 new()
  
  Call C<new()> to create a new object.
  
      my $lxs = Sys::Statistics::Linux::NetStats->new;
  
  Maybe you want to store/load the initial statistics to/from a file:
  
      my $lxs = Sys::Statistics::Linux::NetStats->new(initfile => '/tmp/netstats.yml');
  
  If you set C<initfile> it's not necessary to call sleep before C<get()>.
  
  It's also possible to set the path to the proc filesystem.
  
       Sys::Statistics::Linux::NetStats->new(
          files => {
              # This is the default
              path   => '/proc',
              netdev => 'net/dev',
          }
      );
  
  =head2 init()
  
  Call C<init()> to initialize the statistics.
  
      $lxs->init;
  
  =head2 get()
  
  Call C<get()> to get the statistics. C<get()> returns the statistics as a hash reference.
  
      my $stat = $lxs->get;
  
  =head2 raw()
  
  The same as get_raw() but it's not necessary to call init() first.
  
  =head2 get_raw()
  
  Call C<get_raw()> to get the raw data - no deltas.
  
  =head1 EXPORTS
  
  No exports.
  
  =head1 SEE ALSO
  
  B<proc(5)>
  
  =head1 REPORTING BUGS
  
  Please report all bugs to <jschulz.cpan(at)bloonix.de>.
  
  =head1 AUTHOR
  
  Jonny Schulz <jschulz.cpan(at)bloonix.de>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2007 by Jonny Schulz. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
  
  package Sys::Statistics::Linux::NetStats;
  
  use strict;
  use warnings;
  use Carp qw(croak);
  use Time::HiRes;
  
  our $VERSION = '0.21';
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my %self = (
          files => {
              path   => '/proc',
              netdev => 'net/dev',
          }
      );
  
      if (defined $opts->{initfile}) {
          require YAML::Syck;
          $self{initfile} = $opts->{initfile};
      }
  
      foreach my $file (keys %{ $opts->{files} }) {
          $self{files}{$file} = $opts->{files}->{$file};
      }
  
      return bless \%self, $class;
  }
  
  sub init {
      my $self = shift;
  
      if ($self->{initfile} && -r $self->{initfile}) {
          $self->{init} = YAML::Syck::LoadFile($self->{initfile});
          $self->{time} = delete $self->{init}->{time};
      } else {
          $self->{time} = Time::HiRes::gettimeofday();
          $self->{init} = $self->_load;
      }
  }
  
  sub get {
      my $self  = shift;
      my $class = ref $self;
  
      if (!exists $self->{init}) {
          croak "$class: there are no initial statistics defined";
      }
  
      $self->{stats} = $self->_load;
      $self->_deltas;
  
      if ($self->{initfile}) {
          $self->{init}->{time} = $self->{time};
          YAML::Syck::DumpFile($self->{initfile}, $self->{init});
      }
  
      return $self->{stats};
  }
  
  sub raw {
      my $self = shift;
      my $stat = $self->_load;
  
      return $stat;
  }
  
  sub get_raw {
      my $self = shift;
      my %raw  = %{$self->{init}};
      delete $raw{time};
      return \%raw;
  }
  
  #
  # private stuff
  #
  
  sub _load {
      my $self  = shift;
      my $class = ref $self;
      my $file  = $self->{files};
      my %stats = ();
  
      my $filename = $file->{path} ? "$file->{path}/$file->{netdev}" : $file->{netdev};
      open my $fh, '<', $filename or croak "$class: unable to open $filename ($!)";
  
      while (my $line = <$fh>) {
          next unless $line =~ /^\s*(.+?):\s*(.*)/;
          @{$stats{$1}}{qw(
              rxbyt rxpcks rxerrs rxdrop rxfifo rxframe rxcompr rxmulti
              txbyt txpcks txerrs txdrop txfifo txcolls txcarr txcompr
          )} = split /\s+/, $2;
          $stats{$1}{ttbyt} = $stats{$1}{rxbyt} + $stats{$1}{txbyt};
          $stats{$1}{ttpcks} = $stats{$1}{rxpcks} + $stats{$1}{txpcks};
      }
  
      close($fh);
      return \%stats;
  }
  
  sub _deltas {
      my $self  = shift;
      my $class = ref $self;
      my $istat = $self->{init};
      my $lstat = $self->{stats};
      my $time  = Time::HiRes::gettimeofday();
      my $delta = sprintf('%.2f', $time - $self->{time});
      $self->{time} = $time;
  
      foreach my $dev (keys %{$lstat}) {
          if (!exists $istat->{$dev}) {
              delete $lstat->{$dev};
              next;
          }
  
          my $idev = $istat->{$dev};
          my $ldev = $lstat->{$dev};
  
          while (my ($k, $v) = each %{$ldev}) {
              if (!defined $idev->{$k}) {
                  croak "$class: not defined key found '$k'";
              }
  
              if ($v !~ /^\d+\z/ || $ldev->{$k} !~ /^\d+\z/) {
                  croak "$class: invalid value for key '$k'";
              }
  
              if ($ldev->{$k} == $idev->{$k} || $idev->{$k} > $ldev->{$k}) {
                  $ldev->{$k} = sprintf('%.2f', 0);
              } elsif ($delta > 0) {
                  $ldev->{$k} = sprintf('%.2f', ($ldev->{$k} - $idev->{$k}) / $delta);
              } else {
                  $ldev->{$k} = sprintf('%.2f', $ldev->{$k} - $idev->{$k});
              }
  
              $idev->{$k} = $v;
          }
      }
  }
  
  1;
SYS_STATISTICS_LINUX_NETSTATS

$fatpacked{"Sys/Statistics/Linux/PgSwStats.pm"} = <<'SYS_STATISTICS_LINUX_PGSWSTATS';
  =head1 NAME
  
  Sys::Statistics::Linux::PgSwStats - Collect linux paging and swapping statistics.
  
  =head1 SYNOPSIS
  
      use Sys::Statistics::Linux::PgSwStats;
  
      my $lxs = Sys::Statistics::Linux::PgSwStats->new;
      $lxs->init;
      sleep 1;
      my $stat = $lxs->get;
  
  Or
  
      my $lxs = Sys::Statistics::Linux::PgSwStats->new(initfile => $file);
      $lxs->init;
      my $stat = $lxs->get;
  
  =head1 DESCRIPTION
  
  Sys::Statistics::Linux::PgSwStats gathers paging and swapping statistics from the virtual F</proc> filesystem (procfs).
  
  For more information read the documentation of the front-end module L<Sys::Statistics::Linux>.
  
  =head1 PAGING AND SWAPPING STATISTICS
  
  Generated by F</proc/stat> or F</proc/vmstat>.
  
      pgpgin      -  Number of pages the system has paged in from disk per second.
      pgpgout     -  Number of pages the system has paged out to disk per second.
      pswpin      -  Number of pages the system has swapped in from disk per second.
      pswpout     -  Number of pages the system has swapped out to disk per second.
  
      The following statistics are only available by kernels from 2.6.
  
      pgfault     -  Number of page faults the system has made per second (minor + major).
      pgmajfault  -  Number of major faults per second the system required loading a memory page from disk.
  
  =head1 METHODS
  
  =head2 new()
  
  Call C<new()> to create a new object.
  
      my $lxs = Sys::Statistics::Linux::PgSwStats->new;
  
  Maybe you want to store/load the initial statistics to/from a file:
  
      my $lxs = Sys::Statistics::Linux::PgSwStats->new(initfile => '/tmp/pgswstats.yml');
  
  If you set C<initfile> it's not necessary to call sleep before C<get()>.
  
  It's also possible to set the path to the proc filesystem.
  
       Sys::Statistics::Linux::PgSwStats->new(
          files => {
              # This is the default
              path   => '/proc',
              stat   => 'stat',
              vmstat => 'vmstat',
          }
      );
  
  =head2 init()
  
  Call C<init()> to initialize the statistics.
  
      $lxs->init;
  
  =head2 get()
  
  Call C<get()> to get the statistics. C<get()> returns the statistics as a hash reference.
  
      my $stat = $lxs->get;
  
  =head2 raw()
  
  Get raw values.
  
  =head1 EXPORTS
  
  No exports.
  
  =head1 SEE ALSO
  
  B<proc(5)>
  
  =head1 REPORTING BUGS
  
  Please report all bugs to <jschulz.cpan(at)bloonix.de>.
  
  =head1 AUTHOR
  
  Jonny Schulz <jschulz.cpan(at)bloonix.de>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2007 by Jonny Schulz. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
  
  package Sys::Statistics::Linux::PgSwStats;
  
  use strict;
  use warnings;
  use Carp qw(croak);
  use Time::HiRes;
  
  our $VERSION = '0.18';
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my %self = (
          files => {
              path   => '/proc',
              stat   => 'stat',
              vmstat => 'vmstat',
          }
      );
  
      if (defined $opts->{initfile}) {
          require YAML::Syck;
          $self{initfile} = $opts->{initfile};
      }
  
      foreach my $file (keys %{ $opts->{files} }) {
          $self{files}{$file} = $opts->{files}->{$file};
      }
  
      return bless \%self, $class;
  }
  
  sub init {
      my $self = shift;
  
      if ($self->{initfile} && -r $self->{initfile}) {
          $self->{init} = YAML::Syck::LoadFile($self->{initfile});
          $self->{time} = delete $self->{init}->{time};
      } else {
          $self->{time} = Time::HiRes::gettimeofday();
          $self->{init} = $self->_load;
      }
  }
  
  sub get {
      my $self  = shift;
      my $class = ref $self;
  
      if (!exists $self->{init}) {
          croak "$class: there are no initial statistics defined";
      }
  
      $self->{stats} = $self->_load;
      $self->_deltas;
  
      if ($self->{initfile}) {
          $self->{init}->{time} = $self->{time};
          YAML::Syck::DumpFile($self->{initfile}, $self->{init});
      }
  
      return $self->{stats};
  }
  
  sub raw {
      my $self = shift;
      my $stat = $self->_load;
  
      return $stat;
  }
  
  #
  # private stuff
  #
  
  sub _load {
      my $self  = shift;
      my $class = ref $self;
      my $file  = $self->{files};
      my %stats = ();
  
      my $filename = $file->{path} ? "$file->{path}/$file->{stat}" : $file->{stat};
      open my $fh, '<', $filename or croak "$class: unable to open $filename ($!)";
  
      while (my $line = <$fh>) {
          if ($line =~ /^page\s+(\d+)\s+(\d+)$/) {
              @stats{qw(pgpgin pgpgout)} = ($1, $2);
          } elsif ($line =~ /^swap\s+(\d+)\s+(\d+)$/) {
              @stats{qw(pswpin pswpout)} = ($1, $2);
          }
      }
  
      close($fh);
  
      # if paging and swapping are not found in /proc/stat
      # then let's try a look into /proc/vmstat (since 2.6)
  
      if (!defined $stats{pswpout}) {
          my $filename = $file->{path} ? "$file->{path}/$file->{vmstat}" : $file->{vmstat};
          open my $fh, '<', $filename or croak "$class: unable to open $filename ($!)";
          while (my $line = <$fh>) {
              next unless $line =~ /^(pgpgin|pgpgout|pswpin|pswpout|pgfault|pgmajfault)\s+(\d+)/;
              $stats{$1} = $2;
          }
          close($fh);
      }
  
      return \%stats;
  }
  
  sub _deltas {
      my $self  = shift;
      my $class = ref $self;
      my $istat = $self->{init};
      my $lstat = $self->{stats};
      my $time  = Time::HiRes::gettimeofday();
      my $delta = sprintf('%.2f', $time - $self->{time});
      $self->{time} = $time;
  
      while (my ($k, $v) = each %{$lstat}) {
          if (!defined $istat->{$k} || !defined $lstat->{$k}) {
              croak "$class: not defined key found '$k'";
          }
  
          if ($v !~ /^\d+\z/ || $istat->{$k} !~ /^\d+\z/) {
              croak "$class: invalid value for key '$k'";
          }
  
          if ($lstat->{$k} == $istat->{$k} || $istat->{$k} > $lstat->{$k}) {
              $lstat->{$k} = sprintf('%.2f', 0);
          } elsif ($delta > 0) {
              $lstat->{$k} = sprintf('%.2f', ($lstat->{$k} - $istat->{$k}) / $delta);
          } else {
              $lstat->{$k} = sprintf('%.2f', $lstat->{$k} - $istat->{$k});
          }
  
          $istat->{$k}  = $v;
      }
  }
  
  1;
SYS_STATISTICS_LINUX_PGSWSTATS

$fatpacked{"Sys/Statistics/Linux/ProcStats.pm"} = <<'SYS_STATISTICS_LINUX_PROCSTATS';
  =head1 NAME
  
  Sys::Statistics::Linux::ProcStats - Collect linux process statistics.
  
  =head1 SYNOPSIS
  
      use Sys::Statistics::Linux::ProcStats;
  
      my $lxs = Sys::Statistics::Linux::ProcStats->new;
      $lxs->init;
      sleep 1;
      my $stat = $lxs->get;
  
  Or
  
      my $lxs = Sys::Statistics::Linux::ProcStats->new(initfile => $file);
      $lxs->init;
      my $stat = $lxs->get;
  
  =head1 DESCRIPTION
  
  Sys::Statistics::Linux::ProcStats gathers process statistics from the virtual F</proc> filesystem (procfs).
  
  For more information read the documentation of the front-end module L<Sys::Statistics::Linux>.
  
  =head1 IMPORTANT
  
  I renamed key C<procs_blocked> to C<blocked>!
  
  =head1 LOAD AVERAGE STATISTICS
  
  Generated by F</proc/stat> and F</proc/loadavg>.
  
      new       -  Number of new processes that were produced per second.
      runqueue  -  The number of currently executing kernel scheduling entities (processes, threads).
      count     -  The number of kernel scheduling entities that currently exist on the system (processes, threads).
      blocked   -  Number of processes blocked waiting for I/O to complete (Linux 2.5.45 onwards).
      running   -  Number of processes in runnable state (Linux 2.5.45 onwards).
  
  =head1 METHODS
  
  =head2 new()
  
  Call C<new()> to create a new object.
  
      my $lxs = Sys::Statistics::Linux::ProcStats->new;
  
  Maybe you want to store/load the initial statistics to/from a file:
  
      my $lxs = Sys::Statistics::Linux::ProcStats->new(initfile => '/tmp/procstats.yml');
  
  If you set C<initfile> it's not necessary to call sleep before C<get()>.
  
  It's also possible to set the path to the proc filesystem.
  
       Sys::Statistics::Linux::ProcStats->new(
          files => {
              # This is the default
              path    => '/proc',
              loadavg => 'loadavg',
              stat    => 'stat',
          }
      );
  
  =head2 init()
  
  Call C<init()> to initialize the statistics.
  
      $lxs->init;
  
  =head2 get()
  
  Call C<get()> to get the statistics. C<get()> returns the statistics as a hash reference.
  
      my $stat = $lxs->get;
  
  =head2 raw()
  
  Get raw values.
  
  =head1 EXPORTS
  
  No exports.
  
  =head1 SEE ALSO
  
  B<proc(5)>
  
  =head1 REPORTING BUGS
  
  Please report all bugs to <jschulz.cpan(at)bloonix.de>.
  
  =head1 AUTHOR
  
  Jonny Schulz <jschulz.cpan(at)bloonix.de>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2007 by Jonny Schulz. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
  
  package Sys::Statistics::Linux::ProcStats;
  
  use strict;
  use warnings;
  use Carp qw(croak);
  use Time::HiRes;
  
  our $VERSION = '0.20';
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my %self = (
          files => {
              path    => '/proc',
              loadavg => 'loadavg',
              stat    => 'stat',
          }
      );
  
      if (defined $opts->{initfile}) {
          require YAML::Syck;
          $self{initfile} = $opts->{initfile};
      }
  
      foreach my $file (keys %{ $opts->{files} }) {
          $self{files}{$file} = $opts->{files}->{$file};
      }
  
      return bless \%self, $class;
  }
  
  sub init {
      my $self = shift;
  
      if ($self->{initfile} && -r $self->{initfile}) {
          $self->{init} = YAML::Syck::LoadFile($self->{initfile});
          $self->{time} = delete $self->{init}->{time};
      } else {
          $self->{time} = Time::HiRes::gettimeofday();
          $self->{init} = $self->_load;
      }
  }
  
  sub get {
      my $self  = shift;
      my $class = ref $self;
  
      if (!exists $self->{init}) {
          croak "$class: there are no initial statistics defined";
      }
  
      $self->{stats} = $self->_load;
      $self->_deltas;
  
      if ($self->{initfile}) {
          $self->{init}->{time} = $self->{time};
          YAML::Syck::DumpFile($self->{initfile}, $self->{init});
      }
  
      return $self->{stats};
  }
  
  sub raw {
      my $self = shift;
      my $stat = $self->_load;
  
      return $stat;
  }
  
  #
  # private stuff
  #
  
  sub _load {
      my $self  = shift;
      my $class = ref $self;
      my $file  = $self->{files};
      my $lavg  = $self->_procs;
  
      my $filename = $file->{path} ? "$file->{path}/$file->{loadavg}" : $file->{loadavg};
      open my $fh, '<', $filename or croak "$class: unable to open $filename ($!)";
      ($lavg->{runqueue}, $lavg->{count}) = (split m@/@, (split /\s+/, <$fh>)[3]);
      close($fh);
  
      return $lavg;
  }
  
  sub _procs {
      my $self  = shift;
      my $class = ref $self;
      my $file  = $self->{files};
      my %stat  = ();
  
      my $filename = $file->{path} ? "$file->{path}/$file->{stat}" : $file->{stat};
      open my $fh, '<', $filename or croak "$class: unable to open $filename ($!)";
  
      while (my $line = <$fh>) {
          if ($line =~ /^processes\s+(\d+)/) {
              $stat{new} = $1;
          } elsif ($line =~ /^procs_(blocked|running)\s+(\d+)/) {
              $stat{$1} = $2;
          }
      }
  
      close($fh);
      return \%stat;
  }
  
  sub _deltas {
      my $self  = shift;
      my $class = ref $self;
      my $istat = $self->{init};
      my $lstat = $self->{stats};
      my $time  = Time::HiRes::gettimeofday();
      my $delta = sprintf('%.2f', $time - $self->{time});
      $self->{time} = $time;
  
      if (!defined $istat->{new} || !defined $lstat->{new}) {
          croak "$class: not defined key found 'new'";
      }
      if ($istat->{new} !~ /^\d+\z/ || $lstat->{new} !~ /^\d+\z/) {
          croak "$class: invalid value for key 'new'";
      }
  
      my $new_init = $lstat->{new};
  
      if ($lstat->{new} == $istat->{new} || $istat->{new} > $lstat->{new}) {
          $lstat->{new} = sprintf('%.2f', 0);
      } elsif ($delta > 0) {
          $lstat->{new} = sprintf('%.2f', ($new_init - $istat->{new}) / $delta );
      } else {
          $lstat->{new} = sprintf('%.2f', $new_init - $istat->{new});
      }
  
      $istat->{new} = $new_init;
  }
  
  1;
SYS_STATISTICS_LINUX_PROCSTATS

$fatpacked{"Sys/Statistics/Linux/Processes.pm"} = <<'SYS_STATISTICS_LINUX_PROCESSES';
  =head1 NAME
  
  Sys::Statistics::Linux::Processes - Collect linux process statistics.
  
  =head1 SYNOPSIS
  
      use Sys::Statistics::Linux::Processes;
  
      my $lxs = Sys::Statistics::Linux::Processes->new;
      # or Sys::Statistics::Linux::Processes->new(pids => \@pids)
  
      $lxs->init;
      sleep 1;
      my $stat = $lxs->get;
  
  =head1 DESCRIPTION
  
  Sys::Statistics::Linux::Processes gathers process information from the virtual
  F</proc> filesystem (procfs).
  
  For more information read the documentation of the front-end module
  L<Sys::Statistics::Linux>.
  
  =head1 PROCESS STATISTICS
  
  Generated by F</proc/E<lt>pidE<gt>/stat>, F</proc/E<lt>pidE<gt>/status>,
  F</proc/E<lt>pidE<gt>/cmdline> and F<getpwuid()>.
  
  Note that if F</etc/passwd> isn't readable, the key owner is set to F<N/a>.
  
      ppid      -  The parent process ID of the process.
      nlwp      -  The number of light weight processes that runs by this process.
      owner     -  The owner name of the process.
      pgrp      -  The group ID of the process.
      state     -  The status of the process.
      session   -  The session ID of the process.
      ttynr     -  The tty the process use.
      minflt    -  The number of minor faults the process made.
      cminflt   -  The number of minor faults the child process made.
      mayflt    -  The number of mayor faults the process made.
      cmayflt   -  The number of mayor faults the child process made.
      stime     -  The number of jiffies the process have beed scheduled in kernel mode.
      utime     -  The number of jiffies the process have beed scheduled in user mode.
      ttime     -  The number of jiffies the process have beed scheduled (user + kernel).
      cstime    -  The number of jiffies the process waited for childrens have been scheduled in kernel mode.
      cutime    -  The number of jiffies the process waited for childrens have been scheduled in user mode.
      prior     -  The priority of the process (+15).
      nice      -  The nice level of the process.
      sttime    -  The time in jiffies the process started after system boot.
      actime    -  The time in D:H:M:S (days, hours, minutes, seconds) the process is active.
      vsize     -  The size of virtual memory of the process.
      nswap     -  The size of swap space of the process.
      cnswap    -  The size of swap space of the childrens of the process.
      cpu       -  The CPU number the process was last executed on.
      wchan     -  The "channel" in which the process is waiting.
      fd        -  This is a subhash containing each file which the process has open, named by its file descriptor.
                   0 is standard input, 1 standard output, 2 standard error, etc. Because only the owner or root
                   can read /proc/<pid>/fd this hash could be empty.
      cmd       -  Command of the process.
      cmdline   -  Command line of the process.
  
  Generated by F</proc/E<lt>pidE<gt>/statm>. All statistics provides information
  about memory in pages:
  
      size      -  The total program size of the process.
      resident  -  Number of resident set size, this includes the text, data and stack space.
      share     -  Total size of shared pages of the process.
      trs       -  Total text size of the process.
      drs       -  Total data/stack size of the process.
      lrs       -  Total library size of the process.
      dtp       -  Total size of dirty pages of the process (unused since kernel 2.6).
  
  It's possible to convert pages to bytes or kilobytes. Example - if the pagesize of your
  system is 4kb:
  
      $Sys::Statistics::Linux::Processes::PAGES_TO_BYTES =    0; # pages (default)
      $Sys::Statistics::Linux::Processes::PAGES_TO_BYTES =    4; # convert to kilobytes
      $Sys::Statistics::Linux::Processes::PAGES_TO_BYTES = 4096; # convert to bytes
  
      # or with
      Sys::Statistics::Linux::Processes->new(pages_to_bytes => 4096);
  
  Generated by F</proc/E<lt>pidE<gt>/io>.
  
      rchar                 -  Bytes read from storage (might have been from pagecache).
      wchar                 -  Bytes written.
      syscr                 -  Number of read syscalls.
      syscw                 -  Numner of write syscalls.
      read_bytes            -  Bytes really fetched from storage layer.
      write_bytes           -  Bytes sent to the storage layer.
      cancelled_write_bytes -  Refer to docs.
  
  See Documentation/filesystems/proc.txt for more (from kernel 2.6.20)
  
  =head1 METHODS
  
  =head2 new()
  
  Call C<new()> to create a new object.
  
      my $lxs = Sys::Statistics::Linux::Processes->new;
  
  It's possible to handoff an array reference with a PID list.
  
      my $lxs = Sys::Statistics::Linux::Processes->new(pids => [ 1, 2, 3 ]);
  
  It's also possible to set the path to the proc filesystem.
  
       Sys::Statistics::Linux::Processes->new(
          files => {
              # This is the default
              path    => '/proc',
              uptime  => 'uptime',
              stat    => 'stat',
              statm   => 'statm',
              status  => 'status',
              cmdline => 'cmdline',
              wchan   => 'wchan',
              fd      => 'fd',
              io      => 'io',
          }
      );
  
  =head2 init()
  
  Call C<init()> to initialize the statistics.
  
      $lxs->init;
  
  =head2 get()
  
  Call C<get()> to get the statistics. C<get()> returns the statistics as a hash reference.
  
      my $stat = $lxs->get;
  
  Note:
  
  Processes that were created between the call of init() and get() are returned as well,
  but the keys minflt, cminflt, mayflt, cmayflt, utime, stime, cutime, and cstime are set
  to the value 0.00 because there are no inititial values to calculate the deltas.
  
  =head2 raw()
  
  Get raw values.
  
  =head1 EXPORTS
  
  No exports.
  
  =head1 SEE ALSO
  
  B<proc(5)>
  
  B<perldoc -f getpwuid>
  
  =head1 REPORTING BUGS
  
  Please report all bugs to <jschulz.cpan(at)bloonix.de>.
  
  =head1 AUTHOR
  
  Jonny Schulz <jschulz.cpan(at)bloonix.de>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2007 by Jonny Schulz. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  package Sys::Statistics::Linux::Processes;
  
  use strict;
  use warnings;
  use Time::HiRes;
  use constant NUMBER => qr/^-{0,1}\d+(?:\.\d+){0,1}\z/;
  
  our $VERSION = "0.38";
  our $PAGES_TO_BYTES = 0;
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my %self = (
          files => {
              path    => '/proc',
              uptime  => 'uptime',
              stat    => 'stat',
              statm   => 'statm',
              status  => 'status',
              cmdline => 'cmdline',
              wchan   => 'wchan',
              fd      => 'fd',
              io      => 'io',
          },
      );
  
      if (defined $opts->{pids}) {
          if (ref($opts->{pids}) ne 'ARRAY') {
              die "the PIDs must be passed as a array reference to new()";
          }
  
          foreach my $pid (@{$opts->{pids}}) {
              if ($pid !~ /^\d+\z/) {
                  die "PID '$pid' is not a number";
              }
          }
  
          $self{pids} = $opts->{pids};
      }
  
      foreach my $file (keys %{ $opts->{files} }) {
          $self{files}{$file} = $opts->{files}->{$file};
      }
  
      if ($opts->{pages_to_bytes}) {
          $self{pages_to_bytes} = $opts->{pages_to_bytes};
      }
  
      return bless \%self, $class;
  }
  
  sub init {
      my $self = shift;
      $self->{init} = $self->_init;
  }
  
  sub get {
      my $self = shift;
  
      if (!exists $self->{init}) {
          die "there are no initial statistics defined";
      }
  
      $self->{stats} = $self->_load;
      $self->_deltas;
      return $self->{stats};
  }
  
  sub raw {
      my $self = shift;
      my $stat = $self->_load;
  
      return $stat;
  }
  
  #
  # private stuff
  #
  
  sub _init {
      my $self  = shift;
      my $file  = $self->{files};
      my $pids  = $self->_get_pids;
      my $stats = { };
  
      $stats->{time} = Time::HiRes::gettimeofday();
  
      foreach my $pid (@$pids) {
          my $stat = $self->_get_stat($pid);
  
          if (defined $stat) {
              foreach my $key (qw/minflt cminflt mayflt cmayflt utime stime cutime cstime sttime/) {
                  $stats->{$pid}->{$key} = $stat->{$key};
              }
              $stats->{$pid}->{io} = $self->_get_io($pid);
          }
      }
  
      return $stats;
  }
  
  sub _load {
      my $self   = shift;
      my $file   = $self->{files};
      my $uptime = $self->_uptime;
      my $pids   = $self->_get_pids;
      my $stats  = { };
  
      $stats->{time} = Time::HiRes::gettimeofday();
  
      PID: foreach my $pid (@$pids) {
          foreach my $key (qw/statm stat io owner cmdline wchan fd/) {
              my $method = "_get_$key";
              my $data = $self->$method($pid);
  
              if (!defined $data) {
                  delete $stats->{$pid};
                  next PID;
              }
  
              if ($key eq "statm" || $key eq "stat") {
                  for my $x (keys %$data) {
                      $stats->{$pid}->{$x} = $data->{$x};
                  }
              } else {
                  $stats->{$pid}->{$key} = $data;
              }
          }
      }
  
      return $stats;
  }
  
  sub _deltas {
      my $self   = shift;
      my $istat  = $self->{init};
      my $lstat  = $self->{stats};
      my $uptime = $self->_uptime;
  
      if (!defined $istat->{time} || !defined $lstat->{time}) {
          die "not defined key found 'time'";
      }
  
      if ($istat->{time} !~ NUMBER || $lstat->{time} !~ NUMBER) {
          die "invalid value for key 'time'";
      }
  
      my $time = $lstat->{time} - $istat->{time};
      $istat->{time} = $lstat->{time};
      delete $lstat->{time};
  
      for my $pid (keys %{$lstat}) {
          my $ipid = $istat->{$pid};
          my $lpid = $lstat->{$pid};
  
          # yeah, what happends if the start time is different... it seems that a new
          # process with the same process-id were created... for this reason I have to
          # check if the start time is equal!
          if ($ipid && $ipid->{sttime} == $lpid->{sttime}) {
              for my $k (qw(minflt cminflt mayflt cmayflt utime stime cutime cstime)) {
                  if (!defined $ipid->{$k}) {
                      die "not defined key found '$k'";
                  }
                  if ($ipid->{$k} !~ NUMBER || $lpid->{$k} !~ NUMBER) {
                      die "invalid value for key '$k'";
                  }
  
                  $lpid->{$k} -= $ipid->{$k};
                  $ipid->{$k} += $lpid->{$k};
  
                  if ($lpid->{$k} > 0 && $time > 0) {
                      $lpid->{$k} = sprintf('%.2f', $lpid->{$k} / $time);
                  } else {
                      $lpid->{$k} = sprintf('%.2f', $lpid->{$k});
                  }
              }
  
              $lpid->{ttime} = sprintf('%.2f', $lpid->{stime} + $lpid->{utime});
  
              for my $k (qw(rchar wchar syscr syscw read_bytes write_bytes cancelled_write_bytes)) {
                  if(defined $ipid->{io}->{$k} && defined $lpid->{io}->{$k}){
                      if($ipid->{io}->{$k} !~ NUMBER || $lpid->{io}->{$k} !~ NUMBER){
                          die "invalid value for io key '$k'";
                      }
                      $lpid->{io}->{$k} -= $ipid->{io}->{$k};
                      $ipid->{io}->{$k} += $lpid->{io}->{$k};
                      if ($lpid->{io}->{$k} > 0 && $time > 0) { 
                          $lpid->{io}->{$k} = sprintf('%.2f', $lpid->{io}->{$k} / $time);
                      } else {
                          $lpid->{io}->{$k} = sprintf('%.2f', $lpid->{io}->{$k});
                      }
                  }
              }
          } else {
              # calculate the statistics since process creation
              for my $k (qw(minflt cminflt mayflt cmayflt utime stime cutime cstime)) {
                  my $p_uptime = $uptime - $lpid->{sttime} / 100;
                  $istat->{$pid}->{$k} = $lpid->{$k};
  
                  if ($p_uptime > 0) {
                      $lpid->{$k} = sprintf('%.2f', $lpid->{$k} / $p_uptime);
                  } else {
                      $lpid->{$k} = sprintf('%.2f', $lpid->{$k});
                  }
              }
  
              for my $k (qw(rchar wchar syscr syscw read_bytes write_bytes cancelled_write_bytes)) {
                  my $p_uptime = $uptime - $lpid->{sttime} / 100;
                  $lpid->{io}->{$k} ||= 0;
                  $istat->{$pid}->{io}->{$k} = $lpid->{io}->{$k};
  
                  if ($p_uptime > 0) {
                      $lpid->{io}->{$k} = sprintf('%.2f', $lpid->{io}->{$k} / $p_uptime);
                  } else {
                      $lpid->{io}->{$k} = sprintf('%.2f', $lpid->{io}->{$k});
                  }
              }
  
              $lpid->{ttime} = sprintf('%.2f', $lpid->{stime} + $lpid->{utime});
              $istat->{$pid}->{sttime} = $lpid->{sttime};
          }
      }
  }
  
  sub _get_statm {
      my ($self, $pid) = @_;
      my $file = $self->{files};
      my %stat = ();
  
      open my $fh, '<', "$file->{path}/$pid/$file->{statm}"
          or return undef;
  
      my @line = split /\s+/, <$fh>;
  
      if (@line < 7) {
          return undef;
      }
  
      my $ptb = $self->{pages_to_bytes} || $PAGES_TO_BYTES;
  
      if ($ptb) {
          @stat{qw(size resident share trs lrs drs dtp)} = map { $_ * $ptb } @line;
      } else {
          @stat{qw(size resident share trs lrs drs dtp)} = @line;
      }
  
      close($fh);
      return \%stat;
  }
  
  sub _get_stat {
      my ($self, $pid) = @_;
      my $file = $self->{files};
      my %stat = ();
  
      open my $fh, '<', "$file->{path}/$pid/$file->{stat}"
          or return undef;
  
      my @line = split /\s+/, <$fh>;
  
      if (@line < 38) {
          return undef;
      }
  
      @stat{qw(
          cmd     state   ppid    pgrp    session ttynr   minflt
          cminflt mayflt  cmayflt utime   stime   cutime  cstime
          prior   nice    nlwp    sttime  vsize   nswap   cnswap
          cpu
      )} = @line[1..6,9..19,21..22,35..36,38];
  
      my $uptime = $self->_uptime;
      my ($d, $h, $m, $s) = $self->_calsec(sprintf('%li', $uptime - $stat{sttime} / 100));
      $stat{actime} = "$d:".sprintf('%02d:%02d:%02d', $h, $m, $s);
  
      close($fh);
      return \%stat;
  }
  
  sub _get_owner {
      my ($self, $pid) = @_;
      my $file = $self->{files};
      my $owner = "N/a";
  
      open my $fh, '<', "$file->{path}/$pid/$file->{status}"
          or return undef;
  
      while (my $line = <$fh>) {
          if ($line =~ /^Uid:(?:\s+|\t+)(\d+)/) {
              $owner = getpwuid($1) || "N/a";
              last;
          }
      }
  
      close($fh);
      return $owner;
  }
  
  sub _get_cmdline {
      my ($self, $pid) = @_;
      my $file = $self->{files};
  
      open my $fh, '<', "$file->{path}/$pid/$file->{cmdline}"
          or return undef;
  
      my $cmdline = <$fh>;
      close $fh;
  
      if (!defined $cmdline) {
          $cmdline = "N/a";
      }
  
      $cmdline =~ s/\0/ /g;
      $cmdline =~ s/^\s+//;
      $cmdline =~ s/\s+$//;
      chomp $cmdline;
      return $cmdline;
  }
  
  sub _get_wchan {
      my ($self, $pid) = @_;
      my $file = $self->{files};
  
      open my $fh, '<', "$file->{path}/$pid/$file->{wchan}"
          or return undef;
  
      my $wchan = <$fh>;
      close $fh;
  
      if (!defined $wchan) {
          $wchan = defined;
      }
  
      chomp $wchan;
      return $wchan;
  }
  
  sub _get_io {
      my ($self, $pid) = @_;
      my $file = $self->{files};
      my %stat = ();
  
      if (open my $fh, '<', "$file->{path}/$pid/$file->{io}") {
          while (my $line = <$fh>) {
              if ($line =~ /^([a-z_]+):\s+(\d+)/) {
                  $stat{$1} = $2;
              }
          }
  
          close($fh);
      }
  
      return \%stat;
  }
  
  sub _get_fd {
      my ($self, $pid) = @_;
      my $file = $self->{files};
      my %stat = ();
  
      if (opendir my $dh, "$file->{path}/$pid/$file->{fd}") {
          foreach my $link (grep !/^\.+\z/, readdir($dh)) {
              if (my $target = readlink("$file->{path}/$pid/$file->{fd}/$link")) {
                  $stat{$pid}{fd}{$link} = $target;
              }
          }
      }
  
      return \%stat;
  }
  
  sub _get_pids {
      my $self = shift;
      my $file = $self->{files};
  
      if ($self->{pids}) {
          return $self->{pids};
      }
  
      opendir my $dh, $file->{path}
          or die "unable to open directory $file->{path} ($!)";
      my @pids = grep /^\d+\z/, readdir $dh;
      closedir $dh;
      return \@pids;
  }
  
  sub _uptime {
      my $self = shift;
      my $file = $self->{files};
  
      my $filename = $file->{path} ? "$file->{path}/$file->{uptime}" : $file->{uptime};
      open my $fh, '<', $filename or die "unable to open $filename ($!)";
      my ($up, $idle) = split /\s+/, <$fh>;
      close($fh);
      return $up;
  }
  
  sub _calsec {
      my $self = shift;
      my ($s, $m, $h, $d) = (shift, 0, 0, 0);
      $s >= 86400 and $d = sprintf('%i', $s / 86400) and $s = $s % 86400;
      $s >= 3600  and $h = sprintf('%i', $s / 3600)  and $s = $s % 3600;
      $s >= 60    and $m = sprintf('%i', $s / 60)    and $s = $s % 60;
      return ($d, $h, $m, $s);
  }
  
  1;
SYS_STATISTICS_LINUX_PROCESSES

$fatpacked{"Sys/Statistics/Linux/SockStats.pm"} = <<'SYS_STATISTICS_LINUX_SOCKSTATS';
  =head1 NAME
  
  Sys::Statistics::Linux::SockStats - Collect linux socket statistics.
  
  =head1 SYNOPSIS
  
      use Sys::Statistics::Linux::SockStats;
  
      my $lxs  = Sys::Statistics::Linux::SockStats->new;
      my $stat = $lxs->get;
  
  =head1 DESCRIPTION
  
  Sys::Statistics::Linux::SockStats gathers socket statistics from the virtual F</proc> filesystem (procfs).
  
  For more information read the documentation of the front-end module L<Sys::Statistics::Linux>.
  
  =head1 SOCKET STATISTICS
  
  Generated by F</proc/net/sockstat>.
  
      used    -  Total number of used sockets.
      tcp     -  Number of tcp sockets in use.
      udp     -  Number of udp sockets in use.
      raw     -  Number of raw sockets in use.
      ipfrag  -  Number of ip fragments in use (only available by kernels > 2.2).
  
  =head1 METHODS
  
  =head2 new()
  
  Call C<new()> to create a new object.
  
      my $lxs = Sys::Statistics::Linux::SockStats->new;
  
  It's possible to set the path to the proc filesystem.
  
       Sys::Statistics::Linux::SockStats->new(
          files => {
              # This is the default
              path => '/proc',
              sockstat => 'net/sockstat',
          }
      );
  
  =head2 get()
  
  Call C<get()> to get the statistics. C<get()> returns the statistics as a hash reference.
  
      my $stat = $lxs->get;
  
  =head1 EXPORTS
  
  No exports.
  
  =head1 SEE ALSO
  
  B<proc(5)>
  
  =head1 REPORTING BUGS
  
  Please report all bugs to <jschulz.cpan(at)bloonix.de>.
  
  =head1 AUTHOR
  
  Jonny Schulz <jschulz.cpan(at)bloonix.de>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2007 by Jonny Schulz. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
  
  package Sys::Statistics::Linux::SockStats;
  
  use strict;
  use warnings;
  use Carp qw(croak);
  
  our $VERSION = '0.09';
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my %self = (
          files => {
              path => '/proc',
              sockstat => 'net/sockstat',
          }
      );
  
      foreach my $file (keys %{ $opts->{files} }) {
          $self{files}{$file} = $opts->{files}->{$file};
      }
  
      return bless \%self, $class;
  }
  
  sub get {
      my $self = shift;
      my $class = ref $self;
      my $file  = $self->{files};
      my %socks = ();
  
      my $filename = $file->{path} ? "$file->{path}/$file->{sockstat}" : $file->{sockstat};
      open my $fh, '<', $filename or croak "$class: unable to open $filename ($!)";
  
      while (my $line = <$fh>) {
          if ($line =~ /sockets: used (\d+)/) {
              $socks{used} = $1;
          } elsif ($line =~ /TCP: inuse (\d+)/) {
              $socks{tcp} = $1;
          } elsif ($line =~ /UDP: inuse (\d+)/) {
              $socks{udp} = $1;
          } elsif ($line =~ /RAW: inuse (\d+)/) {
              $socks{raw} = $1;
          } elsif ($line =~ /FRAG: inuse (\d+)/) {
              $socks{ipfrag} = $1;
          }
      }
  
      close($fh);
      return \%socks;
  }
  
  1;
SYS_STATISTICS_LINUX_SOCKSTATS

$fatpacked{"Sys/Statistics/Linux/SysInfo.pm"} = <<'SYS_STATISTICS_LINUX_SYSINFO';
  =head1 NAME
  
  Sys::Statistics::Linux::SysInfo - Collect linux system information.
  
  =head1 SYNOPSIS
  
      use Sys::Statistics::Linux::SysInfo;
  
      my $lxs  = Sys::Statistics::Linux::SysInfo->new;
      my $info = $lxs->get;
  
  =head1 DESCRIPTION
  
  Sys::Statistics::Linux::SysInfo gathers system information from the virtual F</proc> filesystem (procfs).
  
  For more information read the documentation of the front-end module L<Sys::Statistics::Linux>.
  
  =head1 SYSTEM INFOMATIONS
  
  Generated by F</proc/sys/kernel/{hostname,domainname,ostype,osrelease,version}>
  and F</proc/cpuinfo>, F</proc/meminfo>, F</proc/uptime>, F</proc/net/dev>.
  
      hostname   -  The host name.
      domain     -  The host domain name.
      kernel     -  The kernel name.
      release    -  The kernel release.
      version    -  The kernel version.
      memtotal   -  The total size of memory.
      swaptotal  -  The total size of swap space.
      uptime     -  The uptime of the system.
      idletime   -  The idle time of the system.
      pcpucount  -  The total number of physical CPUs.
      tcpucount  -  The total number of CPUs (cores, hyper threading).
      interfaces -  The interfaces of the system.
      arch       -  The machine hardware name (uname -m).
  
      # countcpus is the same like tcpucount
      countcpus  -  The total (maybe logical) number of CPUs.
  
  C<pcpucount> and C<tcpucount> are really easy to understand. Both values
  are collected from C</proc/cpuinfo>. C<pcpucount> is the number of physical
  CPUs, counted by C<physical id>. C<tcpucount> is just the total number 
  counted by C<processor>.
  
  If you want to get C<uptime> and C<idletime> as raw value you can set
  
      $Sys::Statistics::Linux::SysInfo::RAWTIME = 1;
      # or with
      Sys::Statistics::Linux::SysInfo->new(rawtime => 1)
  
  =head1 METHODS
  
  =head2 new()
  
  Call C<new()> to create a new object.
  
      my $lxs = Sys::Statistics::Linux::SysInfo->new;
  
  =head2 get()
  
  Call C<get()> to get the statistics. C<get()> returns the statistics as a hash reference.
  
      my $info = $lxs->get;
  
  =head1 EXPORTS
  
  No exports.
  
  =head1 SEE ALSO
  
  B<proc(5)>
  
  =head1 REPORTING BUGS
  
  Please report all bugs to <jschulz.cpan(at)bloonix.de>.
  
  =head1 AUTHOR
  
  Jonny Schulz <jschulz.cpan(at)bloonix.de>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2007 by Jonny Schulz. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
  
  package Sys::Statistics::Linux::SysInfo;
  
  use strict;
  use warnings;
  use Carp qw(croak);
  
  our $VERSION = '0.13';
  our $RAWTIME = 0;
  
  sub new {
      my $class = shift;
      my $opts  = ref($_[0]) ? shift : {@_};
  
      my %self = (
          files => {
              path     => "/proc",
              meminfo  => "meminfo",
              sysinfo  => "sysinfo",
              cpuinfo  => "cpuinfo",
              uptime   => "uptime",
              hostname => "sys/kernel/hostname",
              domain   => "sys/kernel/domainname",
              kernel   => "sys/kernel/ostype",
              release  => "sys/kernel/osrelease",
              version  => "sys/kernel/version",
              netdev   => "net/dev",
              arch     => [ "/bin/uname", "-m" ],
          }
      );
  
      foreach my $file (keys %{ $opts->{files} }) {
          $self{files}{$file} = $opts->{files}->{$file};
      }
  
      foreach my $param (qw(rawtime cpuinfo)) {
          if ($opts->{$param}) {
              $self{$param} = $opts->{$param};
          }
      }
  
      return bless \%self, $class;
  }
  
  sub get {
      my $self  = shift;
      my $class = ref $self;
      my $file  = $self->{files};
      my $stats = { };
  
      $self->{stats} = $stats;
  
      $self->_get_common;
      $self->_get_meminfo;
      $self->_get_uptime;
      $self->_get_interfaces;
      $self->_get_cpuinfo;
  
      foreach my $key (keys %$stats) {
          chomp $stats->{$key};
          $stats->{$key} =~ s/\t+/ /g;
          $stats->{$key} =~ s/\s+/ /g;
      }
  
     return $stats;
  }
  
  sub _get_common {
      my $self  = shift;
      my $class = ref($self);
      my $file  = $self->{files};
      my $stats = $self->{stats};
  
      for my $x (qw(hostname domain kernel release version)) {
          my $filename = $file->{path} ? "$file->{path}/$file->{$x}" : $file->{$x};
          open my $fh, '<', $filename or croak "$class: unable to open $filename ($!)";
          $stats->{$x} = <$fh>;
          close($fh);
      }
  
      if (-x $file->{arch}->[0] ) {
          my $cmd = join(" ", @{$file->{arch}});
          $stats->{arch} = `$cmd`;
      }
  }
  
  sub _get_meminfo {
      my $self  = shift;
      my $class = ref($self);
      my $file  = $self->{files};
      my $stats = $self->{stats};
  
      my $filename = $file->{path} ? "$file->{path}/$file->{meminfo}" : $file->{meminfo};
      open my $fh, '<', $filename or croak "$class: unable to open $filename ($!)";
  
      while (my $line = <$fh>) {
          if ($line =~ /^MemTotal:\s+(\d+ \w+)/) {
              $stats->{memtotal} = $1;
          } elsif ($line =~ /^SwapTotal:\s+(\d+ \w+)/) {
              $stats->{swaptotal} = $1;
          }
      }
  
      close($fh);
  }
  
  sub _get_cpuinfo {
      my $self  = shift;
      my $class = ref($self);
      my $file  = $self->{files};
      my $stats = $self->{stats};
      my (%cpu, $phyid);
  
      $stats->{countcpus} = 0;
  
      my $filename = $file->{path} ? "$file->{path}/$file->{cpuinfo}" : $file->{cpuinfo};
      open my $fh, '<', $filename or croak "$class: unable to open $filename ($!)";
  
      while (my $line = <$fh>) {
          if ($line =~ /^physical\s+id\s*:\s*(\d+)/) {
              $phyid = $1;
              $cpu{$phyid}{count}++;
          } elsif ($line =~ /^core\s+id\s*:\s*(\d+)/) {
              $cpu{$phyid}{cores}{$1}++;
          } elsif ($line =~ /^processor\s*:\s*\d+/) {       # x86
              $stats->{countcpus}++;
          } elsif ($line =~ /^# processors\s*:\s*(\d+)/) {  # s390
              $stats->{countcpus} = $1;
              last;
          }
      }
  
      close($fh);
  
      $stats->{countcpus} ||= 1; # if it was not possible to match
      $stats->{tcpucount} = $stats->{countcpus};
      $stats->{pcpucount} = scalar keys %cpu || $stats->{countcpus};
  }
  
  sub _get_interfaces {
      my $self  = shift;
      my $class = ref($self);
      my $file  = $self->{files};
      my $stats = $self->{stats};
      my @iface = ();
  
      my $filename = $file->{path} ? "$file->{path}/$file->{netdev}" : $file->{netdev};
      open my $fh, '<', $filename or croak "$class: unable to open $filename ($!)";
      { my $head = <$fh>; }
  
      while (my $line = <$fh>) {
          if ($line =~ /^\s*(\w+):/) {
              push @iface, $1;
          }
      }
  
      close $fh;
  
      $stats->{interfaces} = join(", ", @iface);
      $stats->{interfaces} ||= "";
  }
  
  sub _get_uptime {
      my $self  = shift;
      my $class = ref($self);
      my $file  = $self->{files};
      my $stats = $self->{stats};
  
      my $filename = $file->{path} ? "$file->{path}/$file->{uptime}" : $file->{uptime};
      open my $fh, '<', $filename or croak "$class: unable to open $filename ($!)";
      ($stats->{uptime}, $stats->{idletime}) = split /\s+/, <$fh>;
      close $fh;
  
      if (!$RAWTIME && !$self->{rawtime}) {
          foreach my $x (qw/uptime idletime/) {
              my ($d, $h, $m, $s) = $self->_calsec(sprintf('%li', $stats->{$x}));
              $stats->{$x} = "${d}d ${h}h ${m}m ${s}s";
          }
      }
  }
  
  sub _calsec {
      my $self = shift;
      my ($s, $m, $h, $d) = (shift, 0, 0, 0);
      $s >= 86400 and $d = sprintf('%i',$s / 86400) and $s = $s % 86400;
      $s >= 3600  and $h = sprintf('%i',$s / 3600)  and $s = $s % 3600;
      $s >= 60    and $m = sprintf('%i',$s / 60)    and $s = $s % 60;
      return ($d, $h, $m, $s);
  }
  
  1;
SYS_STATISTICS_LINUX_SYSINFO

$fatpacked{"Try/Tiny.pm"} = <<'TRY_TINY';
  package Try::Tiny;
  
  use strict;
  #use warnings;
  
  use vars qw(@EXPORT @EXPORT_OK $VERSION @ISA);
  
  BEGIN {
  	require Exporter;
  	@ISA = qw(Exporter);
  }
  
  $VERSION = "0.11";
  
  $VERSION = eval $VERSION;
  
  @EXPORT = @EXPORT_OK = qw(try catch finally);
  
  $Carp::Internal{+__PACKAGE__}++;
  
  # Need to prototype as @ not $$ because of the way Perl evaluates the prototype.
  # Keeping it at $$ means you only ever get 1 sub because we need to eval in a list
  # context & not a scalar one
  
  sub try (&;@) {
  	my ( $try, @code_refs ) = @_;
  
  	# we need to save this here, the eval block will be in scalar context due
  	# to $failed
  	my $wantarray = wantarray;
  
  	my ( $catch, @finally );
  
  	# find labeled blocks in the argument list.
  	# catch and finally tag the blocks by blessing a scalar reference to them.
  	foreach my $code_ref (@code_refs) {
  		next unless $code_ref;
  
  		my $ref = ref($code_ref);
  
  		if ( $ref eq 'Try::Tiny::Catch' ) {
  			$catch = ${$code_ref};
  		} elsif ( $ref eq 'Try::Tiny::Finally' ) {
  			push @finally, ${$code_ref};
  		} else {
  			use Carp;
  			confess("Unknown code ref type given '${ref}'. Check your usage & try again");
  		}
  	}
  
  	# save the value of $@ so we can set $@ back to it in the beginning of the eval
  	my $prev_error = $@;
  
  	my ( @ret, $error, $failed );
  
  	# FIXME consider using local $SIG{__DIE__} to accumulate all errors. It's
  	# not perfect, but we could provide a list of additional errors for
  	# $catch->();
  
  	{
  		# localize $@ to prevent clobbering of previous value by a successful
  		# eval.
  		local $@;
  
  		# failed will be true if the eval dies, because 1 will not be returned
  		# from the eval body
  		$failed = not eval {
  			$@ = $prev_error;
  
  			# evaluate the try block in the correct context
  			if ( $wantarray ) {
  				@ret = $try->();
  			} elsif ( defined $wantarray ) {
  				$ret[0] = $try->();
  			} else {
  				$try->();
  			};
  
  			return 1; # properly set $fail to false
  		};
  
  		# copy $@ to $error; when we leave this scope, local $@ will revert $@
  		# back to its previous value
  		$error = $@;
  	}
  
  	# set up a scope guard to invoke the finally block at the end
  	my @guards =
      map { Try::Tiny::ScopeGuard->_new($_, $failed ? $error : ()) }
      @finally;
  
  	# at this point $failed contains a true value if the eval died, even if some
  	# destructor overwrote $@ as the eval was unwinding.
  	if ( $failed ) {
  		# if we got an error, invoke the catch block.
  		if ( $catch ) {
  			# This works like given($error), but is backwards compatible and
  			# sets $_ in the dynamic scope for the body of C<$catch>
  			for ($error) {
  				return $catch->($error);
  			}
  
  			# in case when() was used without an explicit return, the C<for>
  			# loop will be aborted and there's no useful return value
  		}
  
  		return;
  	} else {
  		# no failure, $@ is back to what it was, everything is fine
  		return $wantarray ? @ret : $ret[0];
  	}
  }
  
  sub catch (&;@) {
  	my ( $block, @rest ) = @_;
  
  	return (
  		bless(\$block, 'Try::Tiny::Catch'),
  		@rest,
  	);
  }
  
  sub finally (&;@) {
  	my ( $block, @rest ) = @_;
  
  	return (
  		bless(\$block, 'Try::Tiny::Finally'),
  		@rest,
  	);
  }
  
  {
    package # hide from PAUSE
      Try::Tiny::ScopeGuard;
  
    sub _new {
      shift;
      bless [ @_ ];
    }
  
    sub DESTROY {
      my @guts = @{ shift() };
      my $code = shift @guts;
      $code->(@guts);
    }
  }
  
  __PACKAGE__
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Try::Tiny - minimal try/catch with proper localization of $@
  
  =head1 SYNOPSIS
  
  You can use Try::Tiny's C<try> and C<catch> to expect and handle exceptional
  conditions, avoiding quirks in Perl and common mistakes:
  
  	# handle errors with a catch handler
  	try {
  		die "foo";
  	} catch {
  		warn "caught error: $_"; # not $@
  	};
  
  You can also use it like a stanalone C<eval> to catch and ignore any error
  conditions.  Obviously, this is an extreme measure not to be undertaken
  lightly:
  
  	# just silence errors
  	try {
  		die "foo";
  	};
  
  =head1 DESCRIPTION
  
  This module provides bare bones C<try>/C<catch>/C<finally> statements that are designed to
  minimize common mistakes with eval blocks, and NOTHING else.
  
  This is unlike L<TryCatch> which provides a nice syntax and avoids adding
  another call stack layer, and supports calling C<return> from the try block to
  return from the parent subroutine. These extra features come at a cost of a few
  dependencies, namely L<Devel::Declare> and L<Scope::Upper> which are
  occasionally problematic, and the additional catch filtering uses L<Moose>
  type constraints which may not be desirable either.
  
  The main focus of this module is to provide simple and reliable error handling
  for those having a hard time installing L<TryCatch>, but who still want to
  write correct C<eval> blocks without 5 lines of boilerplate each time.
  
  It's designed to work as correctly as possible in light of the various
  pathological edge cases (see L<BACKGROUND>) and to be compatible with any style
  of error values (simple strings, references, objects, overloaded objects, etc).
  
  If the try block dies, it returns the value of the last statement executed in
  the catch block, if there is one. Otherwise, it returns C<undef> in scalar
  context or the empty list in list context. The following two examples both
  assign C<"bar"> to C<$x>.
  
  	my $x = try { die "foo" } catch { "bar" };
  
  	my $x = eval { die "foo" } || "bar";
  
  You can add finally blocks making the following true.
  
  	my $x;
  	try { die 'foo' } finally { $x = 'bar' };
  	try { die 'foo' } catch { warn "Got a die: $_" } finally { $x = 'bar' };
  
  Finally blocks are always executed making them suitable for cleanup code
  which cannot be handled using local.  You can add as many finally blocks to a
  given try block as you like.
  
  =head1 EXPORTS
  
  All functions are exported by default using L<Exporter>.
  
  If you need to rename the C<try>, C<catch> or C<finally> keyword consider using
  L<Sub::Import> to get L<Sub::Exporter>'s flexibility.
  
  =over 4
  
  =item try (&;@)
  
  Takes one mandatory try subroutine, an optional catch subroutine & finally
  subroutine.
  
  The mandatory subroutine is evaluated in the context of an C<eval> block.
  
  If no error occurred the value from the first block is returned, preserving
  list/scalar context.
  
  If there was an error and the second subroutine was given it will be invoked
  with the error in C<$_> (localized) and as that block's first and only
  argument.
  
  C<$@> does B<not> contain the error. Inside the C<catch> block it has the same
  value it had before the C<try> block was executed.
  
  Note that the error may be false, but if that happens the C<catch> block will
  still be invoked.
  
  Once all execution is finished then the finally block if given will execute.
  
  =item catch (&;$)
  
  Intended to be used in the second argument position of C<try>.
  
  Returns a reference to the subroutine it was given but blessed as
  C<Try::Tiny::Catch> which allows try to decode correctly what to do
  with this code reference.
  
  	catch { ... }
  
  Inside the catch block the caught error is stored in C<$_>, while previous
  value of C<$@> is still available for use.  This value may or may not be
  meaningful depending on what happened before the C<try>, but it might be a good
  idea to preserve it in an error stack.
  
  For code that captures C<$@> when throwing new errors (i.e.
  L<Class::Throwable>), you'll need to do:
  
  	local $@ = $_;
  
  =item finally (&;$)
  
    try     { ... }
    catch   { ... }
    finally { ... };
  
  Or
  
    try     { ... }
    finally { ... };
  
  Or even
  
    try     { ... }
    finally { ... }
    catch   { ... };
  
  Intended to be the second or third element of C<try>. Finally blocks are always
  executed in the event of a successful C<try> or if C<catch> is run. This allows
  you to locate cleanup code which cannot be done via C<local()> e.g. closing a file
  handle.
  
  When invoked, the finally block is passed the error that was caught.  If no
  error was caught, it is passed nothing.  (Note that the finally block does not
  localize C<$_> with the error, since unlike in a catch block, there is no way
  to know if C<$_ == undef> implies that there were no errors.) In other words,
  the following code does just what you would expect:
  
    try {
      die_sometimes();
    } catch {
      # ...code run in case of error
    } finally {
      if (@_) {
        print "The try block died with: @_\n";
      } else {
        print "The try block ran without error.\n";
      }
    };
  
  B<You must always do your own error handling in the finally block>. C<Try::Tiny> will
  not do anything about handling possible errors coming from code located in these
  blocks.
  
  In the same way C<catch()> blesses the code reference this subroutine does the same
  except it bless them as C<Try::Tiny::Finally>.
  
  =back
  
  =head1 BACKGROUND
  
  There are a number of issues with C<eval>.
  
  =head2 Clobbering $@
  
  When you run an eval block and it succeeds, C<$@> will be cleared, potentially
  clobbering an error that is currently being caught.
  
  This causes action at a distance, clearing previous errors your caller may have
  not yet handled.
  
  C<$@> must be properly localized before invoking C<eval> in order to avoid this
  issue.
  
  More specifically, C<$@> is clobbered at the beginning of the C<eval>, which
  also makes it impossible to capture the previous error before you die (for
  instance when making exception objects with error stacks).
  
  For this reason C<try> will actually set C<$@> to its previous value (before
  the localization) in the beginning of the C<eval> block.
  
  =head2 Localizing $@ silently masks errors
  
  Inside an eval block C<die> behaves sort of like:
  
  	sub die {
  		$@ = $_[0];
  		return_undef_from_eval();
  	}
  
  This means that if you were polite and localized C<$@> you can't die in that
  scope, or your error will be discarded (printing "Something's wrong" instead).
  
  The workaround is very ugly:
  
  	my $error = do {
  		local $@;
  		eval { ... };
  		$@;
  	};
  
  	...
  	die $error;
  
  =head2 $@ might not be a true value
  
  This code is wrong:
  
  	if ( $@ ) {
  		...
  	}
  
  because due to the previous caveats it may have been unset.
  
  C<$@> could also be an overloaded error object that evaluates to false, but
  that's asking for trouble anyway.
  
  The classic failure mode is:
  
  	sub Object::DESTROY {
  		eval { ... }
  	}
  
  	eval {
  		my $obj = Object->new;
  
  		die "foo";
  	};
  
  	if ( $@ ) {
  
  	}
  
  In this case since C<Object::DESTROY> is not localizing C<$@> but still uses
  C<eval>, it will set C<$@> to C<"">.
  
  The destructor is called when the stack is unwound, after C<die> sets C<$@> to
  C<"foo at Foo.pm line 42\n">, so by the time C<if ( $@ )> is evaluated it has
  been cleared by C<eval> in the destructor.
  
  The workaround for this is even uglier than the previous ones. Even though we
  can't save the value of C<$@> from code that doesn't localize, we can at least
  be sure the eval was aborted due to an error:
  
  	my $failed = not eval {
  		...
  
  		return 1;
  	};
  
  This is because an C<eval> that caught a C<die> will always return a false
  value.
  
  =head1 SHINY SYNTAX
  
  Using Perl 5.10 you can use L<perlsyn/"Switch statements">.
  
  The C<catch> block is invoked in a topicalizer context (like a C<given> block),
  but note that you can't return a useful value from C<catch> using the C<when>
  blocks without an explicit C<return>.
  
  This is somewhat similar to Perl 6's C<CATCH> blocks. You can use it to
  concisely match errors:
  
  	try {
  		require Foo;
  	} catch {
  		when (/^Can't locate .*?\.pm in \@INC/) { } # ignore
  		default { die $_ }
  	};
  
  =head1 CAVEATS
  
  =over 4
  
  =item *
  
  C<@_> is not available within the C<try> block, so you need to copy your
  arglist. In case you want to work with argument values directly via C<@_>
  aliasing (i.e. allow C<$_[1] = "foo">), you need to pass C<@_> by reference:
  
  	sub foo {
  		my ( $self, @args ) = @_;
  		try { $self->bar(@args) }
  	}
  
  or
  
  	sub bar_in_place {
  		my $self = shift;
  		my $args = \@_;
  		try { $_ = $self->bar($_) for @$args }
  	}
  
  =item *
  
  C<return> returns from the C<try> block, not from the parent sub (note that
  this is also how C<eval> works, but not how L<TryCatch> works):
  
    sub parent_sub {
        try {
            die;
        }
        catch {
            return;
        };
  
        say "this text WILL be displayed, even though an exception is thrown";
    }
  
  Instead, you should capture the return value:
  
    sub parent_sub {
        my $success = try {
            die;
            1;
        }
        return unless $success;
  
        say "This text WILL NEVER appear!";
    }
  
  Note that if you have a catch block, it must return undef for this to work,
  since if a catch block exists, its return value is returned in place of undef
  when an exception is thrown.
  
  =item *
  
  C<try> introduces another caller stack frame. L<Sub::Uplevel> is not used. L<Carp>
  will not report this when using full stack traces, though, because
  C<%Carp::Internal> is used. This lack of magic is considered a feature.
  
  =item *
  
  The value of C<$_> in the C<catch> block is not guaranteed to be the value of
  the exception thrown (C<$@>) in the C<try> block.  There is no safe way to
  ensure this, since C<eval> may be used unhygenically in destructors.  The only
  guarantee is that the C<catch> will be called if an exception is thrown.
  
  =item *
  
  The return value of the C<catch> block is not ignored, so if testing the result
  of the expression for truth on success, be sure to return a false value from
  the C<catch> block:
  
  	my $obj = try {
  		MightFail->new;
  	} catch {
  		...
  
  		return; # avoid returning a true value;
  	};
  
  	return unless $obj;
  
  =item *
  
  C<$SIG{__DIE__}> is still in effect.
  
  Though it can be argued that C<$SIG{__DIE__}> should be disabled inside of
  C<eval> blocks, since it isn't people have grown to rely on it. Therefore in
  the interests of compatibility, C<try> does not disable C<$SIG{__DIE__}> for
  the scope of the error throwing code.
  
  =item *
  
  Lexical C<$_> may override the one set by C<catch>.
  
  For example Perl 5.10's C<given> form uses a lexical C<$_>, creating some
  confusing behavior:
  
  	given ($foo) {
  		when (...) {
  			try {
  				...
  			} catch {
  				warn $_; # will print $foo, not the error
  				warn $_[0]; # instead, get the error like this
  			}
  		}
  	}
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<TryCatch>
  
  Much more feature complete, more convenient semantics, but at the cost of
  implementation complexity.
  
  =item L<autodie>
  
  Automatic error throwing for builtin functions and more. Also designed to
  work well with C<given>/C<when>.
  
  =item L<Throwable>
  
  A lightweight role for rolling your own exception classes.
  
  =item L<Error>
  
  Exception object implementation with a C<try> statement. Does not localize
  C<$@>.
  
  =item L<Exception::Class::TryCatch>
  
  Provides a C<catch> statement, but properly calling C<eval> is your
  responsibility.
  
  The C<try> keyword pushes C<$@> onto an error stack, avoiding some of the
  issues with C<$@>, but you still need to localize to prevent clobbering.
  
  =back
  
  =head1 LIGHTNING TALK
  
  I gave a lightning talk about this module, you can see the slides (Firefox
  only):
  
  L<http://nothingmuch.woobling.org/talks/takahashi.xul?data=yapc_asia_2009/try_tiny.txt>
  
  Or read the source:
  
  L<http://nothingmuch.woobling.org/talks/yapc_asia_2009/try_tiny.yml>
  
  =head1 VERSION CONTROL
  
  L<http://github.com/nothingmuch/try-tiny/>
  
  =head1 AUTHOR
  
  Yuval Kogman E<lt>nothingmuch@woobling.orgE<gt>
  
  =head1 COPYRIGHT
  
  	Copyright (c) 2009 Yuval Kogman. All rights reserved.
  	This program is free software; you can redistribute
  	it and/or modify it under the terms of the MIT license.
  
  =cut
  
TRY_TINY

$fatpacked{"i686-linux/Class/Load/XS.pm"} = <<'I686-LINUX_CLASS_LOAD_XS';
  package Class::Load::XS;
  {
    $Class::Load::XS::VERSION = '0.03';
  }
  
  use strict;
  use warnings;
  
  use XSLoader;
  XSLoader::load(
      __PACKAGE__,
      exists $Class::Load::XS::{VERSION}
      ? ${ $Class::Load::XS::{VERSION} }
      : (),
  );
  
  1;
  
  # ABSTRACT: XS implementation of parts of Class::Load
  
  
  
  =pod
  
  =head1 NAME
  
  Class::Load::XS - XS implementation of parts of Class::Load
  
  =head1 VERSION
  
  version 0.03
  
  =head1 SYNOPSIS
  
      use Class::Load;
  
  =head1 DESCRIPTION
  
  This module provides an XS implementation for portions of L<Class::Load>. See
  L<Class::Load> for API details.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2011 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  =cut
  
  
  __END__
  
I686-LINUX_CLASS_LOAD_XS

$fatpacked{"i686-linux/Class/MOP.pm"} = <<'I686-LINUX_CLASS_MOP';
  
  package Class::MOP;
  BEGIN {
    $Class::MOP::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Class::MOP::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use 5.008;
  
  use MRO::Compat;
  
  use Carp          'confess';
  use Class::Load   ();
  use Scalar::Util  'weaken', 'isweak', 'reftype', 'blessed';
  use Data::OptList;
  use Try::Tiny;
  
  use Class::MOP::Mixin::AttributeCore;
  use Class::MOP::Mixin::HasAttributes;
  use Class::MOP::Mixin::HasMethods;
  use Class::MOP::Class;
  use Class::MOP::Attribute;
  use Class::MOP::Method;
  
  BEGIN {
      *IS_RUNNING_ON_5_10 = ($] < 5.009_005)
          ? sub () { 0 }
          : sub () { 1 };
  
      # this is either part of core or set up appropriately by MRO::Compat
      *check_package_cache_flag = \&mro::get_pkg_gen;
  }
  
  XSLoader::load(
      'Moose',
      $Class::MOP::{VERSION} ? ${ $Class::MOP::{VERSION} } : ()
  );
  
  {
      # Metaclasses are singletons, so we cache them here.
      # there is no need to worry about destruction though
      # because they should die only when the program dies.
      # After all, do package definitions even get reaped?
      # Anonymous classes manage their own destruction.
      my %METAS;
  
      sub get_all_metaclasses         {        %METAS         }
      sub get_all_metaclass_instances { values %METAS         }
      sub get_all_metaclass_names     { keys   %METAS         }
      sub get_metaclass_by_name       { $METAS{$_[0]}         }
      sub store_metaclass_by_name     { $METAS{$_[0]} = $_[1] }
      sub weaken_metaclass            { weaken($METAS{$_[0]}) }
      sub metaclass_is_weak           { isweak($METAS{$_[0]}) }
      sub does_metaclass_exist        { exists $METAS{$_[0]} && defined $METAS{$_[0]} }
      sub remove_metaclass_by_name    { delete $METAS{$_[0]}; return }
  
      # This handles instances as well as class names
      sub class_of {
          return unless defined $_[0];
          my $class = blessed($_[0]) || $_[0];
          return $METAS{$class};
      }
  
      # NOTE:
      # We only cache metaclasses, meaning instances of
      # Class::MOP::Class. We do not cache instance of
      # Class::MOP::Package or Class::MOP::Module. Mostly
      # because I don't yet see a good reason to do so.
  }
  
  sub load_class {
      goto &Class::Load::load_class;
  }
  
  sub load_first_existing_class {
      goto &Class::Load::load_first_existing_class;
  }
  
  sub is_class_loaded {
      goto &Class::Load::is_class_loaded;
  }
  
  sub _definition_context {
      my %context;
      @context{qw(package file line)} = caller(1);
  
      return (
          definition_context => \%context,
      );
  }
  
  ## ----------------------------------------------------------------------------
  ## Setting up our environment ...
  ## ----------------------------------------------------------------------------
  ## Class::MOP needs to have a few things in the global perl environment so
  ## that it can operate effectively. Those things are done here.
  ## ----------------------------------------------------------------------------
  
  # ... nothing yet actually ;)
  
  ## ----------------------------------------------------------------------------
  ## Bootstrapping
  ## ----------------------------------------------------------------------------
  ## The code below here is to bootstrap our MOP with itself. This is also
  ## sometimes called "tying the knot". By doing this, we make it much easier
  ## to extend the MOP through subclassing and such since now you can use the
  ## MOP itself to extend itself.
  ##
  ## Yes, I know, thats weird and insane, but it's a good thing, trust me :)
  ## ----------------------------------------------------------------------------
  
  # We need to add in the meta-attributes here so that
  # any subclass of Class::MOP::* will be able to
  # inherit them using _construct_instance
  
  ## --------------------------------------------------------
  ## Class::MOP::Mixin::HasMethods
  
  Class::MOP::Mixin::HasMethods->meta->add_attribute(
      Class::MOP::Attribute->new('_methods' => (
          reader   => {
              # NOTE:
              # we just alias the original method
              # rather than re-produce it here
              '_method_map' => \&Class::MOP::Mixin::HasMethods::_method_map
          },
          default => sub { {} },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::HasMethods->meta->add_attribute(
      Class::MOP::Attribute->new('method_metaclass' => (
          reader   => {
              # NOTE:
              # we just alias the original method
              # rather than re-produce it here
              'method_metaclass' => \&Class::MOP::Mixin::HasMethods::method_metaclass
          },
          default  => 'Class::MOP::Method',
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::HasMethods->meta->add_attribute(
      Class::MOP::Attribute->new('wrapped_method_metaclass' => (
          reader   => {
              # NOTE:
              # we just alias the original method
              # rather than re-produce it here
              'wrapped_method_metaclass' => \&Class::MOP::Mixin::HasMethods::wrapped_method_metaclass
          },
          default  => 'Class::MOP::Method::Wrapped',
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Mixin::HasMethods
  
  Class::MOP::Mixin::HasAttributes->meta->add_attribute(
      Class::MOP::Attribute->new('attributes' => (
          reader   => {
              # NOTE: we need to do this in order
              # for the instance meta-object to
              # not fall into meta-circular death
              #
              # we just alias the original method
              # rather than re-produce it here
              '_attribute_map' => \&Class::MOP::Mixin::HasAttributes::_attribute_map
          },
          default  => sub { {} },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::HasAttributes->meta->add_attribute(
      Class::MOP::Attribute->new('attribute_metaclass' => (
          reader   => {
              # NOTE:
              # we just alias the original method
              # rather than re-produce it here
              'attribute_metaclass' => \&Class::MOP::Mixin::HasAttributes::attribute_metaclass
          },
          default  => 'Class::MOP::Attribute',
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Package
  
  Class::MOP::Package->meta->add_attribute(
      Class::MOP::Attribute->new('package' => (
          reader   => {
              # NOTE: we need to do this in order
              # for the instance meta-object to
              # not fall into meta-circular death
              #
              # we just alias the original method
              # rather than re-produce it here
              'name' => \&Class::MOP::Package::name
          },
          _definition_context(),
      ))
  );
  
  Class::MOP::Package->meta->add_attribute(
      Class::MOP::Attribute->new('namespace' => (
          reader => {
              # NOTE:
              # we just alias the original method
              # rather than re-produce it here
              'namespace' => \&Class::MOP::Package::namespace
          },
          init_arg => undef,
          default  => sub { \undef },
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Module
  
  # NOTE:
  # yeah this is kind of stretching things a bit,
  # but truthfully the version should be an attribute
  # of the Module, the weirdness comes from having to
  # stick to Perl 5 convention and store it in the
  # $VERSION package variable. Basically if you just
  # squint at it, it will look how you want it to look.
  # Either as a package variable, or as a attribute of
  # the metaclass, isn't abstraction great :)
  
  Class::MOP::Module->meta->add_attribute(
      Class::MOP::Attribute->new('version' => (
          reader => {
              # NOTE:
              # we just alias the original method
              # rather than re-produce it here
              'version' => \&Class::MOP::Module::version
          },
          init_arg => undef,
          default  => sub { \undef },
          _definition_context(),
      ))
  );
  
  # NOTE:
  # By following the same conventions as version here,
  # we are opening up the possibility that people can
  # use the $AUTHORITY in non-Class::MOP modules as
  # well.
  
  Class::MOP::Module->meta->add_attribute(
      Class::MOP::Attribute->new('authority' => (
          reader => {
              # NOTE:
              # we just alias the original method
              # rather than re-produce it here
              'authority' => \&Class::MOP::Module::authority
          },
          init_arg => undef,
          default  => sub { \undef },
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Class
  
  Class::MOP::Class->meta->add_attribute(
      Class::MOP::Attribute->new('superclasses' => (
          accessor => {
              # NOTE:
              # we just alias the original method
              # rather than re-produce it here
              'superclasses' => \&Class::MOP::Class::superclasses
          },
          init_arg => undef,
          default  => sub { \undef },
          _definition_context(),
      ))
  );
  
  Class::MOP::Class->meta->add_attribute(
      Class::MOP::Attribute->new('instance_metaclass' => (
          reader   => {
              # NOTE: we need to do this in order
              # for the instance meta-object to
              # not fall into meta-circular death
              #
              # we just alias the original method
              # rather than re-produce it here
              'instance_metaclass' => \&Class::MOP::Class::instance_metaclass
          },
          default  => 'Class::MOP::Instance',
          _definition_context(),
      ))
  );
  
  Class::MOP::Class->meta->add_attribute(
      Class::MOP::Attribute->new('immutable_trait' => (
          reader   => {
              'immutable_trait' => \&Class::MOP::Class::immutable_trait
          },
          default => "Class::MOP::Class::Immutable::Trait",
          _definition_context(),
      ))
  );
  
  Class::MOP::Class->meta->add_attribute(
      Class::MOP::Attribute->new('constructor_name' => (
          reader   => {
              'constructor_name' => \&Class::MOP::Class::constructor_name,
          },
          default => "new",
          _definition_context(),
      ))
  );
  
  Class::MOP::Class->meta->add_attribute(
      Class::MOP::Attribute->new('constructor_class' => (
          reader   => {
              'constructor_class' => \&Class::MOP::Class::constructor_class,
          },
          default => "Class::MOP::Method::Constructor",
          _definition_context(),
      ))
  );
  
  
  Class::MOP::Class->meta->add_attribute(
      Class::MOP::Attribute->new('destructor_class' => (
          reader   => {
              'destructor_class' => \&Class::MOP::Class::destructor_class,
          },
          _definition_context(),
      ))
  );
  
  # NOTE:
  # we don't actually need to tie the knot with
  # Class::MOP::Class here, it is actually handled
  # within Class::MOP::Class itself in the
  # _construct_class_instance method.
  
  ## --------------------------------------------------------
  ## Class::MOP::Mixin::AttributeCore
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('name' => (
          reader   => {
              # NOTE: we need to do this in order
              # for the instance meta-object to
              # not fall into meta-circular death
              #
              # we just alias the original method
              # rather than re-produce it here
              'name' => \&Class::MOP::Mixin::AttributeCore::name
          },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('accessor' => (
          reader    => { 'accessor'     => \&Class::MOP::Mixin::AttributeCore::accessor     },
          predicate => { 'has_accessor' => \&Class::MOP::Mixin::AttributeCore::has_accessor },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('reader' => (
          reader    => { 'reader'     => \&Class::MOP::Mixin::AttributeCore::reader     },
          predicate => { 'has_reader' => \&Class::MOP::Mixin::AttributeCore::has_reader },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('initializer' => (
          reader    => { 'initializer'     => \&Class::MOP::Mixin::AttributeCore::initializer     },
          predicate => { 'has_initializer' => \&Class::MOP::Mixin::AttributeCore::has_initializer },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('definition_context' => (
          reader    => { 'definition_context'     => \&Class::MOP::Mixin::AttributeCore::definition_context     },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('writer' => (
          reader    => { 'writer'     => \&Class::MOP::Mixin::AttributeCore::writer     },
          predicate => { 'has_writer' => \&Class::MOP::Mixin::AttributeCore::has_writer },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('predicate' => (
          reader    => { 'predicate'     => \&Class::MOP::Mixin::AttributeCore::predicate     },
          predicate => { 'has_predicate' => \&Class::MOP::Mixin::AttributeCore::has_predicate },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('clearer' => (
          reader    => { 'clearer'     => \&Class::MOP::Mixin::AttributeCore::clearer     },
          predicate => { 'has_clearer' => \&Class::MOP::Mixin::AttributeCore::has_clearer },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('builder' => (
          reader    => { 'builder'     => \&Class::MOP::Mixin::AttributeCore::builder     },
          predicate => { 'has_builder' => \&Class::MOP::Mixin::AttributeCore::has_builder },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('init_arg' => (
          reader    => { 'init_arg'     => \&Class::MOP::Mixin::AttributeCore::init_arg     },
          predicate => { 'has_init_arg' => \&Class::MOP::Mixin::AttributeCore::has_init_arg },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('default' => (
          # default has a custom 'reader' method ...
          predicate => { 'has_default' => \&Class::MOP::Mixin::AttributeCore::has_default },
          _definition_context(),
      ))
  );
  
  Class::MOP::Mixin::AttributeCore->meta->add_attribute(
      Class::MOP::Attribute->new('insertion_order' => (
          reader      => { 'insertion_order' => \&Class::MOP::Mixin::AttributeCore::insertion_order },
          writer      => { '_set_insertion_order' => \&Class::MOP::Mixin::AttributeCore::_set_insertion_order },
          predicate   => { 'has_insertion_order' => \&Class::MOP::Mixin::AttributeCore::has_insertion_order },
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Attribute
  Class::MOP::Attribute->meta->add_attribute(
      Class::MOP::Attribute->new('associated_class' => (
          reader   => {
              # NOTE: we need to do this in order
              # for the instance meta-object to
              # not fall into meta-circular death
              #
              # we just alias the original method
              # rather than re-produce it here
              'associated_class' => \&Class::MOP::Attribute::associated_class
          },
          _definition_context(),
      ))
  );
  
  Class::MOP::Attribute->meta->add_attribute(
      Class::MOP::Attribute->new('associated_methods' => (
          reader   => { 'associated_methods' => \&Class::MOP::Attribute::associated_methods },
          default  => sub { [] },
          _definition_context(),
      ))
  );
  
  Class::MOP::Attribute->meta->add_method('clone' => sub {
      my $self  = shift;
      $self->meta->clone_object($self, @_);
  });
  
  ## --------------------------------------------------------
  ## Class::MOP::Method
  Class::MOP::Method->meta->add_attribute(
      Class::MOP::Attribute->new('body' => (
          reader   => { 'body' => \&Class::MOP::Method::body },
          _definition_context(),
      ))
  );
  
  Class::MOP::Method->meta->add_attribute(
      Class::MOP::Attribute->new('associated_metaclass' => (
          reader   => { 'associated_metaclass' => \&Class::MOP::Method::associated_metaclass },
          _definition_context(),
      ))
  );
  
  Class::MOP::Method->meta->add_attribute(
      Class::MOP::Attribute->new('package_name' => (
          reader   => { 'package_name' => \&Class::MOP::Method::package_name },
          _definition_context(),
      ))
  );
  
  Class::MOP::Method->meta->add_attribute(
      Class::MOP::Attribute->new('name' => (
          reader   => { 'name' => \&Class::MOP::Method::name },
          _definition_context(),
      ))
  );
  
  Class::MOP::Method->meta->add_attribute(
      Class::MOP::Attribute->new('original_method' => (
          reader   => { 'original_method'      => \&Class::MOP::Method::original_method },
          writer   => { '_set_original_method' => \&Class::MOP::Method::_set_original_method },
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Method::Wrapped
  
  # NOTE:
  # the way this item is initialized, this
  # really does not follow the standard
  # practices of attributes, but we put
  # it here for completeness
  Class::MOP::Method::Wrapped->meta->add_attribute(
      Class::MOP::Attribute->new('modifier_table' => (
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Method::Generated
  
  Class::MOP::Method::Generated->meta->add_attribute(
      Class::MOP::Attribute->new('is_inline' => (
          reader   => { 'is_inline' => \&Class::MOP::Method::Generated::is_inline },
          default  => 0,
          _definition_context(),
      ))
  );
  
  Class::MOP::Method::Generated->meta->add_attribute(
      Class::MOP::Attribute->new('definition_context' => (
          reader   => { 'definition_context' => \&Class::MOP::Method::Generated::definition_context },
          _definition_context(),
      ))
  );
  
  
  ## --------------------------------------------------------
  ## Class::MOP::Method::Inlined
  
  Class::MOP::Method::Inlined->meta->add_attribute(
      Class::MOP::Attribute->new('_expected_method_class' => (
          reader   => { '_expected_method_class' => \&Class::MOP::Method::Inlined::_expected_method_class },
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Method::Accessor
  
  Class::MOP::Method::Accessor->meta->add_attribute(
      Class::MOP::Attribute->new('attribute' => (
          reader   => {
              'associated_attribute' => \&Class::MOP::Method::Accessor::associated_attribute
          },
          _definition_context(),
      ))
  );
  
  Class::MOP::Method::Accessor->meta->add_attribute(
      Class::MOP::Attribute->new('accessor_type' => (
          reader   => { 'accessor_type' => \&Class::MOP::Method::Accessor::accessor_type },
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Method::Constructor
  
  Class::MOP::Method::Constructor->meta->add_attribute(
      Class::MOP::Attribute->new('options' => (
          reader   => {
              'options' => \&Class::MOP::Method::Constructor::options
          },
          default  => sub { +{} },
          _definition_context(),
      ))
  );
  
  Class::MOP::Method::Constructor->meta->add_attribute(
      Class::MOP::Attribute->new('associated_metaclass' => (
          init_arg => "metaclass", # FIXME alias and rename
          reader   => {
              'associated_metaclass' => \&Class::MOP::Method::Constructor::associated_metaclass
          },
          _definition_context(),
      ))
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Instance
  
  # NOTE:
  # these don't yet do much of anything, but are just
  # included for completeness
  
  Class::MOP::Instance->meta->add_attribute(
      Class::MOP::Attribute->new('associated_metaclass',
          reader   => { associated_metaclass => \&Class::MOP::Instance::associated_metaclass },
          _definition_context(),
      ),
  );
  
  Class::MOP::Instance->meta->add_attribute(
      Class::MOP::Attribute->new('_class_name',
          init_arg => undef,
          reader   => { _class_name => \&Class::MOP::Instance::_class_name },
          #lazy     => 1, # not yet supported by Class::MOP but out our version does it anyway
          #default  => sub { $_[0]->associated_metaclass->name },
          _definition_context(),
      ),
  );
  
  Class::MOP::Instance->meta->add_attribute(
      Class::MOP::Attribute->new('attributes',
          reader   => { attributes => \&Class::MOP::Instance::get_all_attributes },
          _definition_context(),
      ),
  );
  
  Class::MOP::Instance->meta->add_attribute(
      Class::MOP::Attribute->new('slots',
          reader   => { slots => \&Class::MOP::Instance::slots },
          _definition_context(),
      ),
  );
  
  Class::MOP::Instance->meta->add_attribute(
      Class::MOP::Attribute->new('slot_hash',
          reader   => { slot_hash => \&Class::MOP::Instance::slot_hash },
          _definition_context(),
      ),
  );
  
  ## --------------------------------------------------------
  ## Class::MOP::Object
  
  # need to replace the meta method there with a real meta method object
  Class::MOP::Object->meta->_add_meta_method('meta');
  
  ## --------------------------------------------------------
  ## Class::MOP::Mixin
  
  # need to replace the meta method there with a real meta method object
  Class::MOP::Mixin->meta->_add_meta_method('meta');
  
  require Class::MOP::Deprecated unless our $no_deprecated;
  
  # we need the meta instance of the meta instance to be created now, in order
  # for the constructor to be able to use it
  Class::MOP::Instance->meta->get_meta_instance;
  
  # pretend the add_method never happenned. it hasn't yet affected anything
  undef Class::MOP::Instance->meta->{_package_cache_flag};
  
  ## --------------------------------------------------------
  ## Now close all the Class::MOP::* classes
  
  # NOTE: we don't need to inline the the accessors this only lengthens
  # the compile time of the MOP, and gives us no actual benefits.
  
  $_->meta->make_immutable(
      inline_constructor  => 0,
      constructor_name    => "_new",
      inline_accessors => 0,
  ) for qw/
      Class::MOP::Package
      Class::MOP::Module
      Class::MOP::Class
  
      Class::MOP::Attribute
      Class::MOP::Method
      Class::MOP::Instance
  
      Class::MOP::Object
  
      Class::MOP::Method::Generated
      Class::MOP::Method::Inlined
  
      Class::MOP::Method::Accessor
      Class::MOP::Method::Constructor
      Class::MOP::Method::Wrapped
  
      Class::MOP::Method::Meta
  /;
  
  $_->meta->make_immutable(
      inline_constructor  => 0,
      constructor_name    => undef,
      inline_accessors => 0,
  ) for qw/
      Class::MOP::Mixin
      Class::MOP::Mixin::AttributeCore
      Class::MOP::Mixin::HasAttributes
      Class::MOP::Mixin::HasMethods
  /;
  
  1;
  
  # ABSTRACT: A Meta Object Protocol for Perl 5
  
  
  
  =pod
  
  =head1 NAME
  
  Class::MOP - A Meta Object Protocol for Perl 5
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This module is a fully functioning meta object protocol for the
  Perl 5 object system. It makes no attempt to change the behavior or
  characteristics of the Perl 5 object system, only to create a
  protocol for its manipulation and introspection.
  
  That said, it does attempt to create the tools for building a rich set
  of extensions to the Perl 5 object system. Every attempt has been made
  to abide by the spirit of the Perl 5 object system that we all know
  and love.
  
  This documentation is sparse on conceptual details. We suggest looking
  at the items listed in the L<SEE ALSO> section for more
  information. In particular the book "The Art of the Meta Object
  Protocol" was very influential in the development of this system.
  
  =head2 What is a Meta Object Protocol?
  
  A meta object protocol is an API to an object system.
  
  To be more specific, it abstracts the components of an object system
  (classes, object, methods, object attributes, etc.). These
  abstractions can then be used to inspect and manipulate the object
  system which they describe.
  
  It can be said that there are two MOPs for any object system; the
  implicit MOP and the explicit MOP. The implicit MOP handles things
  like method dispatch or inheritance, which happen automatically as
  part of how the object system works. The explicit MOP typically
  handles the introspection/reflection features of the object system.
  
  All object systems have implicit MOPs. Without one, they would not
  work. Explicit MOPs are much less common, and depending on the
  language can vary from restrictive (Reflection in Java or C#) to wide
  open (CLOS is a perfect example).
  
  =head2 Yet Another Class Builder! Why?
  
  This is B<not> a class builder so much as a I<class builder
  B<builder>>. The intent is that an end user will not use this module
  directly, but instead this module is used by module authors to build
  extensions and features onto the Perl 5 object system.
  
  This system is used by L<Moose>, which supplies a powerful class
  builder system built entirely on top of C<Class::MOP>.
  
  =head2 Who is this module for?
  
  This module is for anyone who has ever created or wanted to create a
  module for the Class:: namespace. The tools which this module provides
  make doing complex Perl 5 wizardry simpler, by removing such barriers
  as the need to hack symbol tables, or understand the fine details of
  method dispatch.
  
  =head2 What changes do I have to make to use this module?
  
  This module was designed to be as unintrusive as possible. Many of its
  features are accessible without B<any> change to your existing
  code. It is meant to be a compliment to your existing code and not an
  intrusion on your code base. Unlike many other B<Class::> modules,
  this module B<does not> require you subclass it, or even that you
  C<use> it in within your module's package.
  
  The only features which requires additions to your code are the
  attribute handling and instance construction features, and these are
  both completely optional features. The only reason for this is because
  Perl 5's object system does not actually have these features built
  in. More information about this feature can be found below.
  
  =head2 About Performance
  
  It is a common misconception that explicit MOPs are a performance hit.
  This is not a universal truth, it is a side-effect of some specific
  implementations. For instance, using Java reflection is slow because
  the JVM cannot take advantage of any compiler optimizations, and the
  JVM has to deal with much more runtime type information as well.
  
  Reflection in C# is marginally better as it was designed into the
  language and runtime (the CLR). In contrast, CLOS (the Common Lisp
  Object System) was built to support an explicit MOP, and so
  performance is tuned for it.
  
  This library in particular does its absolute best to avoid putting
  B<any> drain at all upon your code's performance. In fact, by itself
  it does nothing to affect your existing code. So you only pay for what
  you actually use.
  
  =head2 About Metaclass compatibility
  
  This module makes sure that all metaclasses created are both upwards
  and downwards compatible. The topic of metaclass compatibility is
  highly esoteric and is something only encountered when doing deep and
  involved metaclass hacking. There are two basic kinds of metaclass
  incompatibility; upwards and downwards.
  
  Upwards metaclass compatibility means that the metaclass of a
  given class is either the same as (or a subclass of) all of the
  class's ancestors.
  
  Downward metaclass compatibility means that the metaclasses of a
  given class's ancestors are all either the same as (or a subclass
  of) that metaclass.
  
  Here is a diagram showing a set of two classes (C<A> and C<B>) and
  two metaclasses (C<Meta::A> and C<Meta::B>) which have correct
  metaclass compatibility both upwards and downwards.
  
      +---------+     +---------+
      | Meta::A |<----| Meta::B |      <....... (instance of  )
      +---------+     +---------+      <------- (inherits from)
           ^               ^
           :               :
      +---------+     +---------+
      |    A    |<----|    B    |
      +---------+     +---------+
  
  In actuality, I<all> of a class's metaclasses must be compatible,
  not just the class metaclass. That includes the instance, attribute,
  and method metaclasses, as well as the constructor and destructor
  classes.
  
  C<Class::MOP> will attempt to fix some simple types of
  incompatibilities. If all the metaclasses for the parent class are
  I<subclasses> of the child's metaclasses then we can simply replace
  the child's metaclasses with the parent's. In addition, if the child
  is missing a metaclass that the parent has, we can also just make the
  child use the parent's metaclass.
  
  As I said this is a highly esoteric topic and one you will only run
  into if you do a lot of subclassing of L<Class::MOP::Class>. If you
  are interested in why this is an issue see the paper I<Uniform and
  safe metaclass composition> linked to in the L<SEE ALSO> section of
  this document.
  
  =head2 Using custom metaclasses
  
  Always use the L<metaclass> pragma when using a custom metaclass, this
  will ensure the proper initialization order and not accidentally
  create an incorrect type of metaclass for you. This is a very rare
  problem, and one which can only occur if you are doing deep metaclass
  programming. So in other words, don't worry about it.
  
  Note that if you're using L<Moose> we encourage you to I<not> use
  L<metaclass> pragma, and instead use L<Moose::Util::MetaRole> to apply
  roles to a class's metaclasses. This topic is covered at length in
  various L<Moose::Cookbook> recipes.
  
  =head1 PROTOCOLS
  
  The meta-object protocol is divided into 4 main sub-protocols:
  
  =head2 The Class protocol
  
  This provides a means of manipulating and introspecting a Perl 5
  class. It handles symbol table hacking for you, and provides a rich
  set of methods that go beyond simple package introspection.
  
  See L<Class::MOP::Class> for more details.
  
  =head2 The Attribute protocol
  
  This provides a consistent representation for an attribute of a Perl 5
  class. Since there are so many ways to create and handle attributes in
  Perl 5 OO, the Attribute protocol provide as much of a unified
  approach as possible. Of course, you are always free to extend this
  protocol by subclassing the appropriate classes.
  
  See L<Class::MOP::Attribute> for more details.
  
  =head2 The Method protocol
  
  This provides a means of manipulating and introspecting methods in the
  Perl 5 object system. As with attributes, there are many ways to
  approach this topic, so we try to keep it pretty basic, while still
  making it possible to extend the system in many ways.
  
  See L<Class::MOP::Method> for more details.
  
  =head2 The Instance protocol
  
  This provides a layer of abstraction for creating object instances.
  Since the other layers use this protocol, it is relatively easy to
  change the type of your instances from the default hash reference to
  some other type of reference. Several examples are provided in the
  F<examples/> directory included in this distribution.
  
  See L<Class::MOP::Instance> for more details.
  
  =head1 FUNCTIONS
  
  Note that this module does not export any constants or functions.
  
  =head2 Utility functions
  
  Note that these are all called as B<functions, not methods>.
  
  =over 4
  
  =item B<Class::MOP::get_code_info($code)>
  
  This function returns two values, the name of the package the C<$code>
  is from and the name of the C<$code> itself. This is used by several
  elements of the MOP to determine where a given C<$code> reference is
  from.
  
  =item B<Class::MOP::class_of($instance_or_class_name)>
  
  This will return the metaclass of the given instance or class name.  If the
  class lacks a metaclass, no metaclass will be initialized, and C<undef> will be
  returned.
  
  =back
  
  =head2 Metaclass cache functions
  
  Class::MOP holds a cache of metaclasses. The following are functions
  (B<not methods>) which can be used to access that cache. It is not
  recommended that you mess with these. Bad things could happen, but if
  you are brave and willing to risk it: go for it!
  
  =over 4
  
  =item B<Class::MOP::get_all_metaclasses>
  
  This will return a hash of all the metaclass instances that have
  been cached by L<Class::MOP::Class>, keyed by the package name.
  
  =item B<Class::MOP::get_all_metaclass_instances>
  
  This will return a list of all the metaclass instances that have
  been cached by L<Class::MOP::Class>.
  
  =item B<Class::MOP::get_all_metaclass_names>
  
  This will return a list of all the metaclass names that have
  been cached by L<Class::MOP::Class>.
  
  =item B<Class::MOP::get_metaclass_by_name($name)>
  
  This will return a cached L<Class::MOP::Class> instance, or nothing
  if no metaclass exists with that C<$name>.
  
  =item B<Class::MOP::store_metaclass_by_name($name, $meta)>
  
  This will store a metaclass in the cache at the supplied C<$key>.
  
  =item B<Class::MOP::weaken_metaclass($name)>
  
  In rare cases (e.g. anonymous metaclasses) it is desirable to
  store a weakened reference in the metaclass cache. This
  function will weaken the reference to the metaclass stored
  in C<$name>.
  
  =item B<Class::MOP::metaclass_is_weak($name)>
  
  Returns true if the metaclass for C<$name> has been weakened
  (via C<weaken_metaclass>).
  
  =item B<Class::MOP::does_metaclass_exist($name)>
  
  This will return true of there exists a metaclass stored in the
  C<$name> key, and return false otherwise.
  
  =item B<Class::MOP::remove_metaclass_by_name($name)>
  
  This will remove the metaclass stored in the C<$name> key.
  
  =back
  
  Some utility functions (such as C<Class::MOP::load_class>) that were
  previously defined in C<Class::MOP> regarding loading of classes have been
  extracted to L<Class::Load>. Please see L<Class::Load> for documentation.
  
  =head1 SEE ALSO
  
  =head2 Books
  
  There are very few books out on Meta Object Protocols and Metaclasses
  because it is such an esoteric topic. The following books are really
  the only ones I have found. If you know of any more, B<I<please>>
  email me and let me know, I would love to hear about them.
  
  =over 4
  
  =item I<The Art of the Meta Object Protocol>
  
  =item I<Advances in Object-Oriented Metalevel Architecture and Reflection>
  
  =item I<Putting MetaClasses to Work>
  
  =item I<Smalltalk: The Language>
  
  =back
  
  =head2 Papers
  
  =over 4
  
  =item "Uniform and safe metaclass composition"
  
  An excellent paper by the people who brought us the original Traits paper.
  This paper is on how Traits can be used to do safe metaclass composition,
  and offers an excellent introduction section which delves into the topic of
  metaclass compatibility.
  
  L<http://www.iam.unibe.ch/~scg/Archive/Papers/Duca05ySafeMetaclassTrait.pdf>
  
  =item "Safe Metaclass Programming"
  
  This paper seems to precede the above paper, and propose a mix-in based
  approach as opposed to the Traits based approach. Both papers have similar
  information on the metaclass compatibility problem space.
  
  L<http://citeseer.ist.psu.edu/37617.html>
  
  =back
  
  =head2 Prior Art
  
  =over 4
  
  =item The Perl 6 MetaModel work in the Pugs project
  
  =over 4
  
  =item L<http://svn.openfoundry.org/pugs/misc/Perl-MetaModel/>
  
  =item L<http://github.com/perl6/p5-modules/tree/master/Perl6-ObjectSpace/>
  
  =back
  
  =back
  
  =head2 Articles
  
  =over 4
  
  =item CPAN Module Review of Class::MOP
  
  L<http://www.oreillynet.com/onlamp/blog/2006/06/cpan_module_review_classmop.html>
  
  =back
  
  =head1 SIMILAR MODULES
  
  As I have said above, this module is a class-builder-builder, so it is
  not the same thing as modules like L<Class::Accessor> and
  L<Class::MethodMaker>. That being said there are very few modules on CPAN
  with similar goals to this module. The one I have found which is most
  like this module is L<Class::Meta>, although its philosophy and the MOP it
  creates are very different from this modules.
  
  =head1 BUGS
  
  All complex software has bugs lurking in it, and this module is no
  exception.
  
  Please report any bugs to C<bug-class-mop@rt.cpan.org>, or through the
  web interface at L<http://rt.cpan.org>.
  
  You can also discuss feature requests or possible bugs on the Moose
  mailing list (moose@perl.org) or on IRC at
  L<irc://irc.perl.org/#moose>.
  
  =head1 ACKNOWLEDGEMENTS
  
  =over 4
  
  =item Rob Kinyon
  
  Thanks to Rob for actually getting the development of this module kick-started.
  
  =back
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_CLASS_MOP

$fatpacked{"i686-linux/Class/MOP/Attribute.pm"} = <<'I686-LINUX_CLASS_MOP_ATTRIBUTE';
  
  package Class::MOP::Attribute;
  BEGIN {
    $Class::MOP::Attribute::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Class::MOP::Attribute::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Class::MOP::Method::Accessor;
  
  use Carp         'confess';
  use Scalar::Util 'blessed', 'weaken';
  use Try::Tiny;
  
  use base 'Class::MOP::Object', 'Class::MOP::Mixin::AttributeCore';
  
  # NOTE: (meta-circularity)
  # This method will be replaced in the
  # boostrap section of Class::MOP, by
  # a new version which uses the
  # &Class::MOP::Class::construct_instance
  # method to build an attribute meta-object
  # which itself is described with attribute
  # meta-objects.
  #     - Ain't meta-circularity grand? :)
  sub new {
      my ( $class, @args ) = @_;
  
      unshift @args, "name" if @args % 2 == 1;
      my %options = @args;
  
      my $name = $options{name};
  
      (defined $name)
          || confess "You must provide a name for the attribute";
  
      $options{init_arg} = $name
          if not exists $options{init_arg};
      if(exists $options{builder}){
          confess("builder must be a defined scalar value which is a method name")
              if ref $options{builder} || !(defined $options{builder});
          confess("Setting both default and builder is not allowed.")
              if exists $options{default};
      } else {
          ($class->is_default_a_coderef(\%options))
              || confess("References are not allowed as default values, you must ".
                         "wrap the default of '$name' in a CODE reference (ex: sub { [] } and not [])")
                  if exists $options{default} && ref $options{default};
      }
      if( $options{required} and not( defined($options{builder}) || defined($options{init_arg}) || exists $options{default} ) ) {
          confess("A required attribute must have either 'init_arg', 'builder', or 'default'");
      }
  
      $class->_new(\%options);
  }
  
  sub _new {
      my $class = shift;
  
      return Class::MOP::Class->initialize($class)->new_object(@_)
          if $class ne __PACKAGE__;
  
      my $options = @_ == 1 ? $_[0] : {@_};
  
      bless {
          'name'               => $options->{name},
          'accessor'           => $options->{accessor},
          'reader'             => $options->{reader},
          'writer'             => $options->{writer},
          'predicate'          => $options->{predicate},
          'clearer'            => $options->{clearer},
          'builder'            => $options->{builder},
          'init_arg'           => $options->{init_arg},
          exists $options->{default}
              ? ('default'     => $options->{default})
              : (),
          'initializer'        => $options->{initializer},
          'definition_context' => $options->{definition_context},
          # keep a weakened link to the
          # class we are associated with
          'associated_class' => undef,
          # and a list of the methods
          # associated with this attr
          'associated_methods' => [],
          # this let's us keep track of
          # our order inside the associated
          # class
          'insertion_order'    => undef,
      }, $class;
  }
  
  # NOTE:
  # this is a primative (and kludgy) clone operation
  # for now, it will be replaced in the Class::MOP
  # bootstrap with a proper one, however we know
  # that this one will work fine for now.
  sub clone {
      my $self    = shift;
      my %options = @_;
      (blessed($self))
          || confess "Can only clone an instance";
      return bless { %{$self}, %options } => ref($self);
  }
  
  sub initialize_instance_slot {
      my ($self, $meta_instance, $instance, $params) = @_;
      my $init_arg = $self->{'init_arg'};
  
      # try to fetch the init arg from the %params ...
  
      # if nothing was in the %params, we can use the
      # attribute's default value (if it has one)
      if(defined $init_arg and exists $params->{$init_arg}){
          $self->_set_initial_slot_value(
              $meta_instance,
              $instance,
              $params->{$init_arg},
          );
      }
      elsif (exists $self->{'default'}) {
          $self->_set_initial_slot_value(
              $meta_instance,
              $instance,
              $self->default($instance),
          );
      }
      elsif (defined( my $builder = $self->{'builder'})) {
          if ($builder = $instance->can($builder)) {
              $self->_set_initial_slot_value(
                  $meta_instance,
                  $instance,
                  $instance->$builder,
              );
          }
          else {
              confess(ref($instance)." does not support builder method '". $self->{'builder'} ."' for attribute '" . $self->name . "'");
          }
      }
  }
  
  sub _set_initial_slot_value {
      my ($self, $meta_instance, $instance, $value) = @_;
  
      my $slot_name = $self->name;
  
      return $meta_instance->set_slot_value($instance, $slot_name, $value)
          unless $self->has_initializer;
  
      my $callback = $self->_make_initializer_writer_callback(
          $meta_instance, $instance, $slot_name
      );
  
      my $initializer = $self->initializer;
  
      # most things will just want to set a value, so make it first arg
      $instance->$initializer($value, $callback, $self);
  }
  
  sub _make_initializer_writer_callback {
      my $self = shift;
      my ($meta_instance, $instance, $slot_name) = @_;
  
      return sub {
          $meta_instance->set_slot_value($instance, $slot_name, $_[0]);
      };
  }
  
  sub get_read_method  {
      my $self   = shift;
      my $reader = $self->reader || $self->accessor;
      # normal case ...
      return $reader unless ref $reader;
      # the HASH ref case
      my ($name) = %$reader;
      return $name;
  }
  
  sub get_write_method {
      my $self   = shift;
      my $writer = $self->writer || $self->accessor;
      # normal case ...
      return $writer unless ref $writer;
      # the HASH ref case
      my ($name) = %$writer;
      return $name;
  }
  
  sub get_read_method_ref {
      my $self = shift;
      if ((my $reader = $self->get_read_method) && $self->associated_class) {
          return $self->associated_class->get_method($reader);
      }
      else {
          my $code = sub { $self->get_value(@_) };
          if (my $class = $self->associated_class) {
              return $class->method_metaclass->wrap(
                  $code,
                  package_name => $class->name,
                  name         => '__ANON__'
              );
          }
          else {
              return $code;
          }
      }
  }
  
  sub get_write_method_ref {
      my $self = shift;
      if ((my $writer = $self->get_write_method) && $self->associated_class) {
          return $self->associated_class->get_method($writer);
      }
      else {
          my $code = sub { $self->set_value(@_) };
          if (my $class = $self->associated_class) {
              return $class->method_metaclass->wrap(
                  $code,
                  package_name => $class->name,
                  name         => '__ANON__'
              );
          }
          else {
              return $code;
          }
      }
  }
  
  # slots
  
  sub slots { (shift)->name }
  
  # class association
  
  sub attach_to_class {
      my ($self, $class) = @_;
      (blessed($class) && $class->isa('Class::MOP::Class'))
          || confess "You must pass a Class::MOP::Class instance (or a subclass)";
      weaken($self->{'associated_class'} = $class);
  }
  
  sub detach_from_class {
      my $self = shift;
      $self->{'associated_class'} = undef;
  }
  
  # method association
  
  sub associate_method {
      my ($self, $method) = @_;
      push @{$self->{'associated_methods'}} => $method;
  }
  
  ## Slot management
  
  sub set_initial_value {
      my ($self, $instance, $value) = @_;
      $self->_set_initial_slot_value(
          Class::MOP::Class->initialize(ref($instance))->get_meta_instance,
          $instance,
          $value
      );
  }
  
  sub set_value { shift->set_raw_value(@_) }
  
  sub set_raw_value {
      my $self = shift;
      my ($instance, $value) = @_;
  
      my $mi = Class::MOP::Class->initialize(ref($instance))->get_meta_instance;
      return $mi->set_slot_value($instance, $self->name, $value);
  }
  
  sub _inline_set_value {
      my $self = shift;
      return $self->_inline_instance_set(@_) . ';';
  }
  
  sub _inline_instance_set {
      my $self = shift;
      my ($instance, $value) = @_;
  
      my $mi = $self->associated_class->get_meta_instance;
      return $mi->inline_set_slot_value($instance, $self->name, $value);
  }
  
  sub get_value { shift->get_raw_value(@_) }
  
  sub get_raw_value {
      my $self = shift;
      my ($instance) = @_;
  
      my $mi = Class::MOP::Class->initialize(ref($instance))->get_meta_instance;
      return $mi->get_slot_value($instance, $self->name);
  }
  
  sub _inline_get_value {
      my $self = shift;
      return $self->_inline_instance_get(@_) . ';';
  }
  
  sub _inline_instance_get {
      my $self = shift;
      my ($instance) = @_;
  
      my $mi = $self->associated_class->get_meta_instance;
      return $mi->inline_get_slot_value($instance, $self->name);
  }
  
  sub has_value {
      my $self = shift;
      my ($instance) = @_;
  
      my $mi = Class::MOP::Class->initialize(ref($instance))->get_meta_instance;
      return $mi->is_slot_initialized($instance, $self->name);
  }
  
  sub _inline_has_value {
      my $self = shift;
      return $self->_inline_instance_has(@_) . ';';
  }
  
  sub _inline_instance_has {
      my $self = shift;
      my ($instance) = @_;
  
      my $mi = $self->associated_class->get_meta_instance;
      return $mi->inline_is_slot_initialized($instance, $self->name);
  }
  
  sub clear_value {
      my $self = shift;
      my ($instance) = @_;
  
      my $mi = Class::MOP::Class->initialize(ref($instance))->get_meta_instance;
      return $mi->deinitialize_slot($instance, $self->name);
  }
  
  sub _inline_clear_value {
      my $self = shift;
      return $self->_inline_instance_clear(@_) . ';';
  }
  
  sub _inline_instance_clear {
      my $self = shift;
      my ($instance) = @_;
  
      my $mi = $self->associated_class->get_meta_instance;
      return $mi->inline_deinitialize_slot($instance, $self->name);
  }
  
  ## load em up ...
  
  sub accessor_metaclass { 'Class::MOP::Method::Accessor' }
  
  sub _process_accessors {
      my ($self, $type, $accessor, $generate_as_inline_methods) = @_;
  
      my $method_ctx = { %{ $self->definition_context || {} } };
  
      if (ref($accessor)) {
          (ref($accessor) eq 'HASH')
              || confess "bad accessor/reader/writer/predicate/clearer format, must be a HASH ref";
          my ($name, $method) = %{$accessor};
  
          $method_ctx->{description} = $self->_accessor_description($name, $type);
  
          $method = $self->accessor_metaclass->wrap(
              $method,
              attribute    => $self,
              package_name => $self->associated_class->name,
              name         => $name,
              associated_metaclass => $self->associated_class,
              definition_context => $method_ctx,
          );
          $self->associate_method($method);
          return ($name, $method);
      }
      else {
          my $inline_me = ($generate_as_inline_methods && $self->associated_class->instance_metaclass->is_inlinable);
          my $method;
          try {
              $method_ctx->{description} = $self->_accessor_description($accessor, $type);
  
              $method = $self->accessor_metaclass->new(
                  attribute     => $self,
                  is_inline     => $inline_me,
                  accessor_type => $type,
                  package_name  => $self->associated_class->name,
                  name          => $accessor,
                  associated_metaclass => $self->associated_class,
                  definition_context => $method_ctx,
              );
          }
          catch {
              confess "Could not create the '$type' method for " . $self->name . " because : $_";
          };
          $self->associate_method($method);
          return ($accessor, $method);
      }
  }
  
  sub _accessor_description {
      my $self = shift;
      my ($name, $type) = @_;
  
      my $desc = "$type " . $self->associated_class->name . "::$name";
      if ( $name ne $self->name ) {
          $desc .= " of attribute " . $self->name;
      }
  
      return $desc;
  }
  
  sub install_accessors {
      my $self   = shift;
      my $inline = shift;
      my $class  = $self->associated_class;
  
      $class->add_method(
          $self->_process_accessors('accessor' => $self->accessor(), $inline)
      ) if $self->has_accessor();
  
      $class->add_method(
          $self->_process_accessors('reader' => $self->reader(), $inline)
      ) if $self->has_reader();
  
      $class->add_method(
          $self->_process_accessors('writer' => $self->writer(), $inline)
      ) if $self->has_writer();
  
      $class->add_method(
          $self->_process_accessors('predicate' => $self->predicate(), $inline)
      ) if $self->has_predicate();
  
      $class->add_method(
          $self->_process_accessors('clearer' => $self->clearer(), $inline)
      ) if $self->has_clearer();
  
      return;
  }
  
  {
      my $_remove_accessor = sub {
          my ($accessor, $class) = @_;
          if (ref($accessor) && ref($accessor) eq 'HASH') {
              ($accessor) = keys %{$accessor};
          }
          my $method = $class->get_method($accessor);
          $class->remove_method($accessor)
              if (ref($method) && $method->isa('Class::MOP::Method::Accessor'));
      };
  
      sub remove_accessors {
          my $self = shift;
          # TODO:
          # we really need to make sure to remove from the
          # associates methods here as well. But this is
          # such a slimly used method, I am not worried
          # about it right now.
          $_remove_accessor->($self->accessor(),  $self->associated_class()) if $self->has_accessor();
          $_remove_accessor->($self->reader(),    $self->associated_class()) if $self->has_reader();
          $_remove_accessor->($self->writer(),    $self->associated_class()) if $self->has_writer();
          $_remove_accessor->($self->predicate(), $self->associated_class()) if $self->has_predicate();
          $_remove_accessor->($self->clearer(),   $self->associated_class()) if $self->has_clearer();
          return;
      }
  
  }
  
  1;
  
  # ABSTRACT: Attribute Meta Object
  
  
  
  =pod
  
  =head1 NAME
  
  Class::MOP::Attribute - Attribute Meta Object
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 SYNOPSIS
  
    Class::MOP::Attribute->new(
        foo => (
            accessor  => 'foo',           # dual purpose get/set accessor
            predicate => 'has_foo',       # predicate check for defined-ness
            init_arg  => '-foo',          # class->new will look for a -foo key
            default   => 'BAR IS BAZ!'    # if no -foo key is provided, use this
        )
    );
  
    Class::MOP::Attribute->new(
        bar => (
            reader    => 'bar',           # getter
            writer    => 'set_bar',       # setter
            predicate => 'has_bar',       # predicate check for defined-ness
            init_arg  => ':bar',          # class->new will look for a :bar key
                                          # no default value means it is undef
        )
    );
  
  =head1 DESCRIPTION
  
  The Attribute Protocol is almost entirely an invention of
  C<Class::MOP>. Perl 5 does not have a consistent notion of
  attributes. There are so many ways in which this is done, and very few
  (if any) are easily discoverable by this module.
  
  With that said, this module attempts to inject some order into this
  chaos, by introducing a consistent API which can be used to create
  object attributes.
  
  =head1 METHODS
  
  =head2 Creation
  
  =over 4
  
  =item B<< Class::MOP::Attribute->new($name, ?%options) >>
  
  An attribute must (at the very least), have a C<$name>. All other
  C<%options> are added as key-value pairs.
  
  =over 8
  
  =item * init_arg
  
  This is a string value representing the expected key in an
  initialization hash. For instance, if we have an C<init_arg> value of
  C<-foo>, then the following code will Just Work.
  
    MyClass->meta->new_object( -foo => 'Hello There' );
  
  If an init_arg is not assigned, it will automatically use the
  attribute's name. If C<init_arg> is explicitly set to C<undef>, the
  attribute cannot be specified during initialization.
  
  =item * builder
  
  This provides the name of a method that will be called to initialize
  the attribute. This method will be called on the object after it is
  constructed. It is expected to return a valid value for the attribute.
  
  =item * default
  
  This can be used to provide an explicit default for initializing the
  attribute. If the default you provide is a subroutine reference, then
  this reference will be called I<as a method> on the object.
  
  If the value is a simple scalar (string or number), then it can be
  just passed as is. However, if you wish to initialize it with a HASH
  or ARRAY ref, then you need to wrap that inside a subroutine
  reference:
  
    Class::MOP::Attribute->new(
        'foo' => (
            default => sub { [] },
        )
    );
  
    # or ...
  
    Class::MOP::Attribute->new(
        'foo' => (
            default => sub { {} },
        )
    );
  
  If you wish to initialize an attribute with a subroutine reference
  itself, then you need to wrap that in a subroutine as well:
  
    Class::MOP::Attribute->new(
        'foo' => (
            default => sub {
                sub { print "Hello World" }
            },
        )
    );
  
  And lastly, if the value of your attribute is dependent upon some
  other aspect of the instance structure, then you can take advantage of
  the fact that when the C<default> value is called as a method:
  
    Class::MOP::Attribute->new(
        'object_identity' => (
            default => sub { Scalar::Util::refaddr( $_[0] ) },
        )
    );
  
  Note that there is no guarantee that attributes are initialized in any
  particular order, so you cannot rely on the value of some other
  attribute when generating the default.
  
  =item * initializer
  
  This option can be either a method name or a subroutine
  reference. This method will be called when setting the attribute's
  value in the constructor. Unlike C<default> and C<builder>, the
  initializer is only called when a value is provided to the
  constructor. The initializer allows you to munge this value during
  object construction.
  
  The initializer is called as a method with three arguments. The first
  is the value that was passed to the constructor. The second is a
  subroutine reference that can be called to actually set the
  attribute's value, and the last is the associated
  C<Class::MOP::Attribute> object.
  
  This contrived example shows an initializer that sets the attribute to
  twice the given value.
  
    Class::MOP::Attribute->new(
        'doubled' => (
            initializer => sub {
                my ( $self, $value, $set, $attr ) = @_;
                $set->( $value * 2 );
            },
        )
    );
  
  Since an initializer can be a method name, you can easily make
  attribute initialization use the writer:
  
    Class::MOP::Attribute->new(
        'some_attr' => (
            writer      => 'some_attr',
            initializer => 'some_attr',
        )
    );
  
  Your writer (actually, a wrapper around the writer, using
  L<method modifications|Moose::Manual::MethodModifiers>) will need to examine
  C<@_> and determine under which
  context it is being called:
  
    around 'some_attr' => sub {
        my $orig = shift;
        my $self = shift;
        # $value is not defined if being called as a reader
        # $setter and $attr are only defined if being called as an initializer
        my ($value, $setter, $attr) = @_;
  
        # the reader behaves normally
        return $self->$orig if not @_;
  
        # mutate $value as desired
        # $value = <something($value);
  
        # if called as an initializer, set the value and we're done
        return $setter->($row) if $setter;
  
        # otherwise, call the real writer with the new value
        $self->$orig($row);
    };
  
  =back
  
  The C<accessor>, C<reader>, C<writer>, C<predicate> and C<clearer>
  options all accept the same parameters. You can provide the name of
  the method, in which case an appropriate default method will be
  generated for you. Or instead you can also provide hash reference
  containing exactly one key (the method name) and one value. The value
  should be a subroutine reference, which will be installed as the
  method itself.
  
  =over 8
  
  =item * accessor
  
  An C<accessor> is a standard Perl-style read/write accessor. It will
  return the value of the attribute, and if a value is passed as an
  argument, it will assign that value to the attribute.
  
  Note that C<undef> is a legitimate value, so this will work:
  
    $object->set_something(undef);
  
  =item * reader
  
  This is a basic read-only accessor. It returns the value of the
  attribute.
  
  =item * writer
  
  This is a basic write accessor, it accepts a single argument, and
  assigns that value to the attribute.
  
  Note that C<undef> is a legitimate value, so this will work:
  
    $object->set_something(undef);
  
  =item * predicate
  
  The predicate method returns a boolean indicating whether or not the
  attribute has been explicitly set.
  
  Note that the predicate returns true even if the attribute was set to
  a false value (C<0> or C<undef>).
  
  =item * clearer
  
  This method will uninitialize the attribute. After an attribute is
  cleared, its C<predicate> will return false.
  
  =item * definition_context
  
  Mostly, this exists as a hook for the benefit of Moose.
  
  This option should be a hash reference containing several keys which
  will be used when inlining the attribute's accessors. The keys should
  include C<line>, the line number where the attribute was created, and
  either C<file> or C<description>.
  
  This information will ultimately be used when eval'ing inlined
  accessor code so that error messages report a useful line and file
  name.
  
  =back
  
  =item B<< $attr->clone(%options) >>
  
  This clones the attribute. Any options you provide will override the
  settings of the original attribute. You can change the name of the new
  attribute by passing a C<name> key in C<%options>.
  
  =back
  
  =head2 Informational
  
  These are all basic read-only accessors for the values passed into
  the constructor.
  
  =over 4
  
  =item B<< $attr->name >>
  
  Returns the attribute's name.
  
  =item B<< $attr->accessor >>
  
  =item B<< $attr->reader >>
  
  =item B<< $attr->writer >>
  
  =item B<< $attr->predicate >>
  
  =item B<< $attr->clearer >>
  
  The C<accessor>, C<reader>, C<writer>, C<predicate>, and C<clearer>
  methods all return exactly what was passed to the constructor, so it
  can be either a string containing a method name, or a hash reference.
  
  =item B<< $attr->initializer >>
  
  Returns the initializer as passed to the constructor, so this may be
  either a method name or a subroutine reference.
  
  =item B<< $attr->init_arg >>
  
  =item B<< $attr->is_default_a_coderef >>
  
  =item B<< $attr->default($instance) >>
  
  The C<$instance> argument is optional. If you don't pass it, the
  return value for this method is exactly what was passed to the
  constructor, either a simple scalar or a subroutine reference.
  
  If you I<do> pass an C<$instance> and the default is a subroutine
  reference, then the reference is called as a method on the
  C<$instance> and the generated value is returned.
  
  =item B<< $attr->slots >>
  
  Return a list of slots required by the attribute. This is usually just
  one, the name of the attribute.
  
  A slot is the name of the hash key used to store the attribute in an
  object instance.
  
  =item B<< $attr->get_read_method >>
  
  =item B<< $attr->get_write_method >>
  
  Returns the name of a method suitable for reading or writing the value
  of the attribute in the associated class.
  
  If an attribute is read- or write-only, then these methods can return
  C<undef> as appropriate.
  
  =item B<< $attr->has_read_method >>
  
  =item B<< $attr->has_write_method >>
  
  This returns a boolean indicating whether the attribute has a I<named>
  read or write method.
  
  =item B<< $attr->get_read_method_ref >>
  
  =item B<< $attr->get_write_method_ref >>
  
  Returns the subroutine reference of a method suitable for reading or
  writing the attribute's value in the associated class. These methods
  always return a subroutine reference, regardless of whether or not the
  attribute is read- or write-only.
  
  =item B<< $attr->insertion_order >>
  
  If this attribute has been inserted into a class, this returns a zero
  based index regarding the order of insertion.
  
  =back
  
  =head2 Informational predicates
  
  These are all basic predicate methods for the values passed into C<new>.
  
  =over 4
  
  =item B<< $attr->has_accessor >>
  
  =item B<< $attr->has_reader >>
  
  =item B<< $attr->has_writer >>
  
  =item B<< $attr->has_predicate >>
  
  =item B<< $attr->has_clearer >>
  
  =item B<< $attr->has_initializer >>
  
  =item B<< $attr->has_init_arg >>
  
  This will be I<false> if the C<init_arg> was set to C<undef>.
  
  =item B<< $attr->has_default >>
  
  This will be I<false> if the C<default> was set to C<undef>, since
  C<undef> is the default C<default> anyway.
  
  =item B<< $attr->has_builder >>
  
  =item B<< $attr->has_insertion_order >>
  
  This will be I<false> if this attribute has not be inserted into a class
  
  =back
  
  =head2 Value management
  
  These methods are basically "back doors" to the instance, and can be
  used to bypass the regular accessors, but still stay within the MOP.
  
  These methods are not for general use, and should only be used if you
  really know what you are doing.
  
  =over 4
  
  =item B<< $attr->initialize_instance_slot($meta_instance, $instance, $params) >>
  
  This method is used internally to initialize the attribute's slot in
  the object C<$instance>.
  
  The C<$params> is a hash reference of the values passed to the object
  constructor.
  
  It's unlikely that you'll need to call this method yourself.
  
  =item B<< $attr->set_value($instance, $value) >>
  
  Sets the value without going through the accessor. Note that this
  works even with read-only attributes.
  
  =item B<< $attr->set_raw_value($instance, $value) >>
  
  Sets the value with no side effects such as a trigger.
  
  This doesn't actually apply to Class::MOP attributes, only to subclasses.
  
  =item B<< $attr->set_initial_value($instance, $value) >>
  
  Sets the value without going through the accessor. This method is only
  called when the instance is first being initialized.
  
  =item B<< $attr->get_value($instance) >>
  
  Returns the value without going through the accessor. Note that this
  works even with write-only accessors.
  
  =item B<< $attr->get_raw_value($instance) >>
  
  Returns the value without any side effects such as lazy attributes.
  
  Doesn't actually apply to Class::MOP attributes, only to subclasses.
  
  =item B<< $attr->has_value($instance) >>
  
  Return a boolean indicating whether the attribute has been set in
  C<$instance>. This how the default C<predicate> method works.
  
  =item B<< $attr->clear_value($instance) >>
  
  This will clear the attribute's value in C<$instance>. This is what
  the default C<clearer> calls.
  
  Note that this works even if the attribute does not have any
  associated read, write or clear methods.
  
  =back
  
  =head2 Class association
  
  These methods allow you to manage the attributes association with
  the class that contains it. These methods should not be used
  lightly, nor are they very magical, they are mostly used internally
  and by metaclass instances.
  
  =over 4
  
  =item B<< $attr->associated_class >>
  
  This returns the C<Class::MOP::Class> with which this attribute is
  associated, if any.
  
  =item B<< $attr->attach_to_class($metaclass) >>
  
  This method stores a weakened reference to the C<$metaclass> object
  internally.
  
  This method does not remove the attribute from its old class,
  nor does it create any accessors in the new class.
  
  It is probably best to use the L<Class::MOP::Class> C<add_attribute>
  method instead.
  
  =item B<< $attr->detach_from_class >>
  
  This method removes the associate metaclass object from the attribute
  it has one.
  
  This method does not remove the attribute itself from the class, or
  remove its accessors.
  
  It is probably best to use the L<Class::MOP::Class>
  C<remove_attribute> method instead.
  
  =back
  
  =head2 Attribute Accessor generation
  
  =over 4
  
  =item B<< $attr->accessor_metaclass >>
  
  Accessor methods are generated using an accessor metaclass. By
  default, this is L<Class::MOP::Method::Accessor>. This method returns
  the name of the accessor metaclass that this attribute uses.
  
  =item B<< $attr->associate_method($method) >>
  
  This associates a L<Class::MOP::Method> object with the
  attribute. Typically, this is called internally when an attribute
  generates its accessors.
  
  =item B<< $attr->associated_methods >>
  
  This returns the list of methods which have been associated with the
  attribute.
  
  =item B<< $attr->install_accessors >>
  
  This method generates and installs code the attributes various
  accessors. It is typically called from the L<Class::MOP::Class>
  C<add_attribute> method.
  
  =item B<< $attr->remove_accessors >>
  
  This method removes all of the accessors associated with the
  attribute.
  
  This does not currently remove methods from the list returned by
  C<associated_methods>.
  
  =item B<< $attr->inline_get >>
  
  =item B<< $attr->inline_set >>
  
  =item B<< $attr->inline_has >>
  
  =item B<< $attr->inline_clear >>
  
  These methods return a code snippet suitable for inlining the relevant
  operation. They expect strings containing variable names to be used in the
  inlining, like C<'$self'> or C<'$_[1]'>.
  
  =back
  
  =head2 Introspection
  
  =over 4
  
  =item B<< Class::MOP::Attribute->meta >>
  
  This will return a L<Class::MOP::Class> instance for this class.
  
  It should also be noted that L<Class::MOP> will actually bootstrap
  this module by installing a number of attribute meta-objects into its
  metaclass.
  
  =back
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
  
  
I686-LINUX_CLASS_MOP_ATTRIBUTE

$fatpacked{"i686-linux/Class/MOP/Class.pm"} = <<'I686-LINUX_CLASS_MOP_CLASS';
  
  package Class::MOP::Class;
  BEGIN {
    $Class::MOP::Class::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Class::MOP::Class::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Class::MOP::Instance;
  use Class::MOP::Method::Wrapped;
  use Class::MOP::Method::Accessor;
  use Class::MOP::Method::Constructor;
  use Class::MOP::MiniTrait;
  
  use Carp         'confess';
  use Class::Load  'is_class_loaded', 'load_class';
  use Scalar::Util 'blessed', 'reftype', 'weaken';
  use Sub::Name    'subname';
  use Try::Tiny;
  use List::MoreUtils 'all';
  
  use base 'Class::MOP::Module',
           'Class::MOP::Mixin::HasAttributes',
           'Class::MOP::Mixin::HasMethods';
  
  # Creation
  
  sub initialize {
      my $class = shift;
  
      my $package_name;
  
      if ( @_ % 2 ) {
          $package_name = shift;
      } else {
          my %options = @_;
          $package_name = $options{package};
      }
  
      ($package_name && !ref($package_name))
          || confess "You must pass a package name and it cannot be blessed";
  
      return Class::MOP::get_metaclass_by_name($package_name)
          || $class->_construct_class_instance(package => $package_name, @_);
  }
  
  sub reinitialize {
      my ( $class, @args ) = @_;
      unshift @args, "package" if @args % 2;
      my %options = @args;
      my $old_metaclass = blessed($options{package})
          ? $options{package}
          : Class::MOP::get_metaclass_by_name($options{package});
      $options{weaken} = Class::MOP::metaclass_is_weak($old_metaclass->name)
          if !exists $options{weaken}
          && blessed($old_metaclass)
          && $old_metaclass->isa('Class::MOP::Class');
      $old_metaclass->_remove_generated_metaobjects
          if $old_metaclass && $old_metaclass->isa('Class::MOP::Class');
      my $new_metaclass = $class->SUPER::reinitialize(%options);
      $new_metaclass->_restore_metaobjects_from($old_metaclass)
          if $old_metaclass && $old_metaclass->isa('Class::MOP::Class');
      return $new_metaclass;
  }
  
  # NOTE: (meta-circularity)
  # this is a special form of _construct_instance
  # (see below), which is used to construct class
  # meta-object instances for any Class::MOP::*
  # class. All other classes will use the more
  # normal &construct_instance.
  sub _construct_class_instance {
      my $class        = shift;
      my $options      = @_ == 1 ? $_[0] : {@_};
      my $package_name = $options->{package};
      (defined $package_name && $package_name)
          || confess "You must pass a package name";
      # NOTE:
      # return the metaclass if we have it cached,
      # and it is still defined (it has not been
      # reaped by DESTROY yet, which can happen
      # annoyingly enough during global destruction)
  
      if (defined(my $meta = Class::MOP::get_metaclass_by_name($package_name))) {
          return $meta;
      }
  
      $class
          = ref $class
          ? $class->_real_ref_name
          : $class;
  
      # now create the metaclass
      my $meta;
      if ($class eq 'Class::MOP::Class') {
          $meta = $class->_new($options);
      }
      else {
          # NOTE:
          # it is safe to use meta here because
          # class will always be a subclass of
          # Class::MOP::Class, which defines meta
          $meta = $class->meta->_construct_instance($options)
      }
  
      # and check the metaclass compatibility
      $meta->_check_metaclass_compatibility();
  
      Class::MOP::store_metaclass_by_name($package_name, $meta);
  
      # NOTE:
      # we need to weaken any anon classes
      # so that they can call DESTROY properly
      Class::MOP::weaken_metaclass($package_name) if $options->{weaken};
  
      $meta;
  }
  
  sub _real_ref_name {
      my $self = shift;
  
      # NOTE: we need to deal with the possibility of class immutability here,
      # and then get the name of the class appropriately
      return $self->is_immutable
          ? $self->_get_mutable_metaclass_name()
          : ref $self;
  }
  
  sub _new {
      my $class = shift;
  
      return Class::MOP::Class->initialize($class)->new_object(@_)
          if $class ne __PACKAGE__;
  
      my $options = @_ == 1 ? $_[0] : {@_};
  
      return bless {
          # inherited from Class::MOP::Package
          'package' => $options->{package},
  
          # NOTE:
          # since the following attributes will
          # actually be loaded from the symbol
          # table, and actually bypass the instance
          # entirely, we can just leave these things
          # listed here for reference, because they
          # should not actually have a value associated
          # with the slot.
          'namespace' => \undef,
          'methods'   => {},
  
          # inherited from Class::MOP::Module
          'version'   => \undef,
          'authority' => \undef,
  
          # defined in Class::MOP::Class
          'superclasses' => \undef,
  
          'attributes' => {},
          'attribute_metaclass' =>
              ( $options->{'attribute_metaclass'} || 'Class::MOP::Attribute' ),
          'method_metaclass' =>
              ( $options->{'method_metaclass'} || 'Class::MOP::Method' ),
          'wrapped_method_metaclass' => (
              $options->{'wrapped_method_metaclass'}
                  || 'Class::MOP::Method::Wrapped'
          ),
          'instance_metaclass' =>
              ( $options->{'instance_metaclass'} || 'Class::MOP::Instance' ),
          'immutable_trait' => (
              $options->{'immutable_trait'}
                  || 'Class::MOP::Class::Immutable::Trait'
          ),
          'constructor_name' => ( $options->{constructor_name} || 'new' ),
          'constructor_class' => (
              $options->{constructor_class} || 'Class::MOP::Method::Constructor'
          ),
          'destructor_class' => $options->{destructor_class},
      }, $class;
  }
  
  ## Metaclass compatibility
  {
      my %base_metaclass = (
          attribute_metaclass      => 'Class::MOP::Attribute',
          method_metaclass         => 'Class::MOP::Method',
          wrapped_method_metaclass => 'Class::MOP::Method::Wrapped',
          instance_metaclass       => 'Class::MOP::Instance',
          constructor_class        => 'Class::MOP::Method::Constructor',
          destructor_class         => 'Class::MOP::Method::Destructor',
      );
  
      sub _base_metaclasses { %base_metaclass }
  }
  
  sub _check_metaclass_compatibility {
      my $self = shift;
  
      my @superclasses = $self->superclasses
          or return;
  
      $self->_fix_metaclass_incompatibility(@superclasses);
  
      my %base_metaclass = $self->_base_metaclasses;
  
      # this is always okay ...
      return
          if ref($self) eq 'Class::MOP::Class'
              && all {
                  my $meta = $self->$_;
                  !defined($meta) || $meta eq $base_metaclass{$_};
          }
          keys %base_metaclass;
  
      for my $superclass (@superclasses) {
          $self->_check_class_metaclass_compatibility($superclass);
      }
  
      for my $metaclass_type ( keys %base_metaclass ) {
          next unless defined $self->$metaclass_type;
          for my $superclass (@superclasses) {
              $self->_check_single_metaclass_compatibility( $metaclass_type,
                  $superclass );
          }
      }
  }
  
  sub _check_class_metaclass_compatibility {
      my $self = shift;
      my ( $superclass_name ) = @_;
  
      if (!$self->_class_metaclass_is_compatible($superclass_name)) {
          my $super_meta = Class::MOP::get_metaclass_by_name($superclass_name);
  
          my $super_meta_type = $super_meta->_real_ref_name;
  
          confess "The metaclass of " . $self->name . " ("
                . (ref($self)) . ")" .  " is not compatible with "
                . "the metaclass of its superclass, "
                . $superclass_name . " (" . ($super_meta_type) . ")";
      }
  }
  
  sub _class_metaclass_is_compatible {
      my $self = shift;
      my ( $superclass_name ) = @_;
  
      my $super_meta = Class::MOP::get_metaclass_by_name($superclass_name)
          || return 1;
  
      my $super_meta_name = $super_meta->_real_ref_name;
  
      return $self->_is_compatible_with($super_meta_name);
  }
  
  sub _check_single_metaclass_compatibility {
      my $self = shift;
      my ( $metaclass_type, $superclass_name ) = @_;
  
      if (!$self->_single_metaclass_is_compatible($metaclass_type, $superclass_name)) {
          my $super_meta = Class::MOP::get_metaclass_by_name($superclass_name);
          my $metaclass_type_name = $metaclass_type;
          $metaclass_type_name =~ s/_(?:meta)?class$//;
          $metaclass_type_name =~ s/_/ /g;
          confess "The $metaclass_type_name metaclass for "
                . $self->name . " (" . ($self->$metaclass_type)
                . ")" . " is not compatible with the "
                . "$metaclass_type_name metaclass of its "
                . "superclass, $superclass_name ("
                . ($super_meta->$metaclass_type) . ")";
      }
  }
  
  sub _single_metaclass_is_compatible {
      my $self = shift;
      my ( $metaclass_type, $superclass_name ) = @_;
  
      my $super_meta = Class::MOP::get_metaclass_by_name($superclass_name)
          || return 1;
  
      # for instance, Moose::Meta::Class has a error_class attribute, but
      # Class::MOP::Class doesn't - this shouldn't be an error
      return 1 unless $super_meta->can($metaclass_type);
      # for instance, Moose::Meta::Class has a destructor_class, but
      # Class::MOP::Class doesn't - this shouldn't be an error
      return 1 unless defined $super_meta->$metaclass_type;
      # if metaclass is defined in superclass but not here, it's not compatible
      # this is a really odd case
      return 0 unless defined $self->$metaclass_type;
  
      return $self->$metaclass_type->_is_compatible_with($super_meta->$metaclass_type);
  }
  
  sub _fix_metaclass_incompatibility {
      my $self = shift;
      my @supers = map { Class::MOP::Class->initialize($_) } @_;
  
      my $necessary = 0;
      for my $super (@supers) {
          $necessary = 1
              if $self->_can_fix_metaclass_incompatibility($super);
      }
      return unless $necessary;
  
      for my $super (@supers) {
          if (!$self->_class_metaclass_is_compatible($super->name)) {
              $self->_fix_class_metaclass_incompatibility($super);
          }
      }
  
      my %base_metaclass = $self->_base_metaclasses;
      for my $metaclass_type (keys %base_metaclass) {
          for my $super (@supers) {
              if (!$self->_single_metaclass_is_compatible($metaclass_type, $super->name)) {
                  $self->_fix_single_metaclass_incompatibility(
                      $metaclass_type, $super
                  );
              }
          }
      }
  }
  
  sub _can_fix_metaclass_incompatibility {
      my $self = shift;
      my ($super_meta) = @_;
  
      return 1 if $self->_class_metaclass_can_be_made_compatible($super_meta);
  
      my %base_metaclass = $self->_base_metaclasses;
      for my $metaclass_type (keys %base_metaclass) {
          return 1 if $self->_single_metaclass_can_be_made_compatible($super_meta, $metaclass_type);
      }
  
      return;
  }
  
  sub _class_metaclass_can_be_made_compatible {
      my $self = shift;
      my ($super_meta) = @_;
  
      return $self->_can_be_made_compatible_with($super_meta->_real_ref_name);
  }
  
  sub _single_metaclass_can_be_made_compatible {
      my $self = shift;
      my ($super_meta, $metaclass_type) = @_;
  
      my $specific_meta = $self->$metaclass_type;
  
      return unless $super_meta->can($metaclass_type);
      my $super_specific_meta = $super_meta->$metaclass_type;
  
      # for instance, Moose::Meta::Class has a destructor_class, but
      # Class::MOP::Class doesn't - this shouldn't be an error
      return unless defined $super_specific_meta;
  
      # if metaclass is defined in superclass but not here, it's fixable
      # this is a really odd case
      return 1 unless defined $specific_meta;
  
      return 1 if $specific_meta->_can_be_made_compatible_with($super_specific_meta);
  }
  
  sub _fix_class_metaclass_incompatibility {
      my $self = shift;
      my ( $super_meta ) = @_;
  
      if ($self->_class_metaclass_can_be_made_compatible($super_meta)) {
          ($self->is_pristine)
              || confess "Can't fix metaclass incompatibility for "
                       . $self->name
                       . " because it is not pristine.";
  
          my $super_meta_name = $super_meta->_real_ref_name;
  
          $self->_make_compatible_with($super_meta_name);
      }
  }
  
  sub _fix_single_metaclass_incompatibility {
      my $self = shift;
      my ( $metaclass_type, $super_meta ) = @_;
  
      if ($self->_single_metaclass_can_be_made_compatible($super_meta, $metaclass_type)) {
          ($self->is_pristine)
              || confess "Can't fix metaclass incompatibility for "
                       . $self->name
                       . " because it is not pristine.";
  
          my $new_metaclass = $self->$metaclass_type
              ? $self->$metaclass_type->_get_compatible_metaclass($super_meta->$metaclass_type)
              : $super_meta->$metaclass_type;
          $self->{$metaclass_type} = $new_metaclass;
      }
  }
  
  sub _restore_metaobjects_from {
      my $self = shift;
      my ($old_meta) = @_;
  
      $self->_restore_metamethods_from($old_meta);
      $self->_restore_metaattributes_from($old_meta);
  }
  
  sub _remove_generated_metaobjects {
      my $self = shift;
  
      for my $attr (map { $self->get_attribute($_) } $self->get_attribute_list) {
          $attr->remove_accessors;
      }
  }
  
  # creating classes with MOP ...
  
  sub create {
      my $class = shift;
      my @args = @_;
  
      unshift @args, 'package' if @args % 2 == 1;
      my %options = @args;
  
      (ref $options{superclasses} eq 'ARRAY')
          || confess "You must pass an ARRAY ref of superclasses"
              if exists $options{superclasses};
  
      (ref $options{attributes} eq 'ARRAY')
          || confess "You must pass an ARRAY ref of attributes"
              if exists $options{attributes};
  
      (ref $options{methods} eq 'HASH')
          || confess "You must pass a HASH ref of methods"
              if exists $options{methods};
  
      my $package      = delete $options{package};
      my $superclasses = delete $options{superclasses};
      my $attributes   = delete $options{attributes};
      my $methods      = delete $options{methods};
      my $meta_name    = exists $options{meta_name}
                           ? delete $options{meta_name}
                           : 'meta';
  
      my $meta = $class->SUPER::create($package => %options);
  
      $meta->_add_meta_method($meta_name)
          if defined $meta_name;
  
      $meta->superclasses(@{$superclasses})
          if defined $superclasses;
      # NOTE:
      # process attributes first, so that they can
      # install accessors, but locally defined methods
      # can then overwrite them. It is maybe a little odd, but
      # I think this should be the order of things.
      if (defined $attributes) {
          foreach my $attr (@{$attributes}) {
              $meta->add_attribute($attr);
          }
      }
      if (defined $methods) {
          foreach my $method_name (keys %{$methods}) {
              $meta->add_method($method_name, $methods->{$method_name});
          }
      }
      return $meta;
  }
  
  # XXX: something more intelligent here?
  sub _anon_package_prefix { 'Class::MOP::Class::__ANON__::SERIAL::' }
  
  sub create_anon_class { shift->create_anon(@_) }
  sub is_anon_class     { shift->is_anon(@_)     }
  
  sub _anon_cache_key {
      my $class = shift;
      my %options = @_;
      # Makes something like Super::Class|Super::Class::2
      return join '=' => (
          join( '|', sort @{ $options{superclasses} || [] } ),
      );
  }
  
  # Instance Construction & Cloning
  
  sub new_object {
      my $class = shift;
  
      # NOTE:
      # we need to protect the integrity of the
      # Class::MOP::Class singletons here, so we
      # delegate this to &construct_class_instance
      # which will deal with the singletons
      return $class->_construct_class_instance(@_)
          if $class->name->isa('Class::MOP::Class');
      return $class->_construct_instance(@_);
  }
  
  sub _construct_instance {
      my $class = shift;
      my $params = @_ == 1 ? $_[0] : {@_};
      my $meta_instance = $class->get_meta_instance();
      # FIXME:
      # the code below is almost certainly incorrect
      # but this is foreign inheritance, so we might
      # have to kludge it in the end.
      my $instance;
      if (my $instance_class = blessed($params->{__INSTANCE__})) {
          ($instance_class eq $class->name)
              || confess "Objects passed as the __INSTANCE__ parameter must "
                       . "already be blessed into the correct class, but "
                       . "$params->{__INSTANCE__} is not a " . $class->name;
          $instance = $params->{__INSTANCE__};
      }
      elsif (exists $params->{__INSTANCE__}) {
          confess "The __INSTANCE__ parameter must be a blessed reference, not "
                . $params->{__INSTANCE__};
      }
      else {
          $instance = $meta_instance->create_instance();
      }
      foreach my $attr ($class->get_all_attributes()) {
          $attr->initialize_instance_slot($meta_instance, $instance, $params);
      }
      if (Class::MOP::metaclass_is_weak($class->name)) {
          $meta_instance->_set_mop_slot($instance, $class);
      }
      return $instance;
  }
  
  sub _inline_new_object {
      my $self = shift;
  
      return (
          'my $class = shift;',
          '$class = Scalar::Util::blessed($class) || $class;',
          $self->_inline_fallback_constructor('$class'),
          $self->_inline_params('$params', '$class'),
          $self->_inline_generate_instance('$instance', '$class'),
          $self->_inline_slot_initializers,
          $self->_inline_preserve_weak_metaclasses,
          $self->_inline_extra_init,
          'return $instance',
      );
  }
  
  sub _inline_fallback_constructor {
      my $self = shift;
      my ($class) = @_;
      return (
          'return ' . $self->_generate_fallback_constructor($class),
              'if ' . $class . ' ne \'' . $self->name . '\';',
      );
  }
  
  sub _generate_fallback_constructor {
      my $self = shift;
      my ($class) = @_;
      return 'Class::MOP::Class->initialize(' . $class . ')->new_object(@_)',
  }
  
  sub _inline_params {
      my $self = shift;
      my ($params, $class) = @_;
      return (
          'my ' . $params . ' = @_ == 1 ? $_[0] : {@_};',
      );
  }
  
  sub _inline_generate_instance {
      my $self = shift;
      my ($inst, $class) = @_;
      return (
          'my ' . $inst . ' = ' . $self->_inline_create_instance($class) . ';',
      );
  }
  
  sub _inline_create_instance {
      my $self = shift;
  
      return $self->get_meta_instance->inline_create_instance(@_);
  }
  
  sub _inline_slot_initializers {
      my $self = shift;
  
      my $idx = 0;
  
      return map { $self->_inline_slot_initializer($_, $idx++) }
                 sort { $a->name cmp $b->name } $self->get_all_attributes;
  }
  
  sub _inline_slot_initializer {
      my $self  = shift;
      my ($attr, $idx) = @_;
  
      if (defined(my $init_arg = $attr->init_arg)) {
          my @source = (
              'if (exists $params->{\'' . $init_arg . '\'}) {',
                  $self->_inline_init_attr_from_constructor($attr, $idx),
              '}',
          );
          if (my @default = $self->_inline_init_attr_from_default($attr, $idx)) {
              push @source, (
                  'else {',
                      @default,
                  '}',
              );
          }
          return @source;
      }
      elsif (my @default = $self->_inline_init_attr_from_default($attr, $idx)) {
          return (
              '{',
                  @default,
              '}',
          );
      }
      else {
          return ();
      }
  }
  
  sub _inline_init_attr_from_constructor {
      my $self = shift;
      my ($attr, $idx) = @_;
  
      my @initial_value = $attr->_inline_set_value(
          '$instance', '$params->{\'' . $attr->init_arg . '\'}',
      );
  
      push @initial_value, (
          '$attrs->[' . $idx . ']->set_initial_value(',
              '$instance,',
              $attr->_inline_instance_get('$instance'),
          ');',
      ) if $attr->has_initializer;
  
      return @initial_value;
  }
  
  sub _inline_init_attr_from_default {
      my $self = shift;
      my ($attr, $idx) = @_;
  
      my $default = $self->_inline_default_value($attr, $idx);
      return unless $default;
  
      my @initial_value = $attr->_inline_set_value('$instance', $default);
  
      push @initial_value, (
          '$attrs->[' . $idx . ']->set_initial_value(',
              '$instance,',
              $attr->_inline_instance_get('$instance'),
          ');',
      ) if $attr->has_initializer;
  
      return @initial_value;
  }
  
  sub _inline_default_value {
      my $self = shift;
      my ($attr, $index) = @_;
  
      if ($attr->has_default) {
          # NOTE:
          # default values can either be CODE refs
          # in which case we need to call them. Or
          # they can be scalars (strings/numbers)
          # in which case we can just deal with them
          # in the code we eval.
          if ($attr->is_default_a_coderef) {
              return '$defaults->[' . $index . ']->($instance)';
          }
          else {
              return '$defaults->[' . $index . ']';
          }
      }
      elsif ($attr->has_builder) {
          return '$instance->' . $attr->builder;
      }
      else {
          return;
      }
  }
  
  sub _inline_preserve_weak_metaclasses {
      my $self = shift;
      if (Class::MOP::metaclass_is_weak($self->name)) {
          return (
              $self->_inline_set_mop_slot(
                  '$instance', 'Class::MOP::class_of($class)'
              ) . ';'
          );
      }
      else {
          return ();
      }
  }
  
  sub _inline_extra_init { }
  
  sub _eval_environment {
      my $self = shift;
  
      my @attrs = sort { $a->name cmp $b->name } $self->get_all_attributes;
  
      my $defaults = [map { $_->default } @attrs];
  
      return {
          '$defaults' => \$defaults,
      };
  }
  
  
  sub get_meta_instance {
      my $self = shift;
      $self->{'_meta_instance'} ||= $self->_create_meta_instance();
  }
  
  sub _create_meta_instance {
      my $self = shift;
  
      my $instance = $self->instance_metaclass->new(
          associated_metaclass => $self,
          attributes => [ $self->get_all_attributes() ],
      );
  
      $self->add_meta_instance_dependencies()
          if $instance->is_dependent_on_superclasses();
  
      return $instance;
  }
  
  # TODO: this is actually not being used!
  sub _inline_rebless_instance {
      my $self = shift;
  
      return $self->get_meta_instance->inline_rebless_instance_structure(@_);
  }
  
  sub _inline_get_mop_slot {
      my $self = shift;
  
      return $self->get_meta_instance->_inline_get_mop_slot(@_);
  }
  
  sub _inline_set_mop_slot {
      my $self = shift;
  
      return $self->get_meta_instance->_inline_set_mop_slot(@_);
  }
  
  sub _inline_clear_mop_slot {
      my $self = shift;
  
      return $self->get_meta_instance->_inline_clear_mop_slot(@_);
  }
  
  sub clone_object {
      my $class    = shift;
      my $instance = shift;
      (blessed($instance) && $instance->isa($class->name))
          || confess "You must pass an instance of the metaclass (" . (ref $class ? $class->name : $class) . "), not ($instance)";
  
      # NOTE:
      # we need to protect the integrity of the
      # Class::MOP::Class singletons here, they
      # should not be cloned.
      return $instance if $instance->isa('Class::MOP::Class');
      $class->_clone_instance($instance, @_);
  }
  
  sub _clone_instance {
      my ($class, $instance, %params) = @_;
      (blessed($instance))
          || confess "You can only clone instances, ($instance) is not a blessed instance";
      my $meta_instance = $class->get_meta_instance();
      my $clone = $meta_instance->clone_instance($instance);
      foreach my $attr ($class->get_all_attributes()) {
          if ( defined( my $init_arg = $attr->init_arg ) ) {
              if (exists $params{$init_arg}) {
                  $attr->set_value($clone, $params{$init_arg});
              }
          }
      }
      return $clone;
  }
  
  sub _force_rebless_instance {
      my ($self, $instance, %params) = @_;
      my $old_metaclass = Class::MOP::class_of($instance);
  
      $old_metaclass->rebless_instance_away($instance, $self, %params)
          if $old_metaclass;
  
      my $meta_instance = $self->get_meta_instance;
  
      if (Class::MOP::metaclass_is_weak($old_metaclass->name)) {
          $meta_instance->_clear_mop_slot($instance);
      }
  
      # rebless!
      # we use $_[1] here because of t/cmop/rebless_overload.t regressions
      # on 5.8.8
      $meta_instance->rebless_instance_structure($_[1], $self);
  
      $self->_fixup_attributes_after_rebless($instance, $old_metaclass, %params);
  
      if (Class::MOP::metaclass_is_weak($self->name)) {
          $meta_instance->_set_mop_slot($instance, $self);
      }
  }
  
  sub rebless_instance {
      my ($self, $instance, %params) = @_;
      my $old_metaclass = Class::MOP::class_of($instance);
  
      my $old_class = $old_metaclass ? $old_metaclass->name : blessed($instance);
      $self->name->isa($old_class)
          || confess "You may rebless only into a subclass of ($old_class), of which (". $self->name .") isn't.";
  
      $self->_force_rebless_instance($_[1], %params);
  
      return $instance;
  }
  
  sub rebless_instance_back {
      my ( $self, $instance ) = @_;
      my $old_metaclass = Class::MOP::class_of($instance);
  
      my $old_class
          = $old_metaclass ? $old_metaclass->name : blessed($instance);
      $old_class->isa( $self->name )
          || confess
          "You may rebless only into a superclass of ($old_class), of which ("
          . $self->name
          . ") isn't.";
  
      $self->_force_rebless_instance($_[1]);
  
      return $instance;
  }
  
  sub rebless_instance_away {
      # this intentionally does nothing, it is just a hook
  }
  
  sub _fixup_attributes_after_rebless {
      my $self = shift;
      my ($instance, $rebless_from, %params) = @_;
      my $meta_instance = $self->get_meta_instance;
  
      for my $attr ( $rebless_from->get_all_attributes ) {
          next if $self->find_attribute_by_name( $attr->name );
          $meta_instance->deinitialize_slot( $instance, $_ ) for $attr->slots;
      }
  
      foreach my $attr ( $self->get_all_attributes ) {
          if ( $attr->has_value($instance) ) {
              if ( defined( my $init_arg = $attr->init_arg ) ) {
                  $params{$init_arg} = $attr->get_value($instance)
                      unless exists $params{$init_arg};
              }
              else {
                  $attr->set_value($instance, $attr->get_value($instance));
              }
          }
      }
  
      foreach my $attr ($self->get_all_attributes) {
          $attr->initialize_instance_slot($meta_instance, $instance, \%params);
      }
  }
  
  sub _attach_attribute {
      my ($self, $attribute) = @_;
      $attribute->attach_to_class($self);
  }
  
  sub _post_add_attribute {
      my ( $self, $attribute ) = @_;
  
      $self->invalidate_meta_instances;
  
      # invalidate package flag here
      try {
          local $SIG{__DIE__};
          $attribute->install_accessors;
      }
      catch {
          $self->remove_attribute( $attribute->name );
          die $_;
      };
  }
  
  sub remove_attribute {
      my $self = shift;
  
      my $removed_attribute = $self->SUPER::remove_attribute(@_)
          or return;
  
      $self->invalidate_meta_instances;
  
      $removed_attribute->remove_accessors;
      $removed_attribute->detach_from_class;
  
      return$removed_attribute;
  }
  
  sub find_attribute_by_name {
      my ( $self, $attr_name ) = @_;
  
      foreach my $class ( $self->linearized_isa ) {
          # fetch the meta-class ...
          my $meta = Class::MOP::Class->initialize($class);
          return $meta->get_attribute($attr_name)
              if $meta->has_attribute($attr_name);
      }
  
      return;
  }
  
  sub get_all_attributes {
      my $self = shift;
      my %attrs = map { %{ Class::MOP::Class->initialize($_)->_attribute_map } }
          reverse $self->linearized_isa;
      return values %attrs;
  }
  
  # Inheritance
  
  sub superclasses {
      my $self     = shift;
  
      my $isa = $self->get_or_add_package_symbol('@ISA');
  
      if (@_) {
          my @supers = @_;
          @{$isa} = @supers;
  
          # NOTE:
          # on 5.8 and below, we need to call
          # a method to get Perl to detect
          # a cycle in the class hierarchy
          my $class = $self->name;
          $class->isa($class);
  
          # NOTE:
          # we need to check the metaclass
          # compatibility here so that we can
          # be sure that the superclass is
          # not potentially creating an issues
          # we don't know about
  
          $self->_check_metaclass_compatibility();
          $self->_superclasses_updated();
      }
  
      return @{$isa};
  }
  
  sub _superclasses_updated {
      my $self = shift;
      $self->update_meta_instance_dependencies();
      # keep strong references to all our parents, so they don't disappear if
      # they are anon classes and don't have any direct instances
      $self->_superclass_metas(
          map { Class::MOP::class_of($_) } $self->superclasses
      );
  }
  
  sub _superclass_metas {
      my $self = shift;
      $self->{_superclass_metas} = [@_];
  }
  
  sub subclasses {
      my $self = shift;
      my $super_class = $self->name;
  
      return @{ $super_class->mro::get_isarev() };
  }
  
  sub direct_subclasses {
      my $self = shift;
      my $super_class = $self->name;
  
      return grep {
          grep {
              $_ eq $super_class
          } Class::MOP::Class->initialize($_)->superclasses
      } $self->subclasses;
  }
  
  sub linearized_isa {
      return @{ mro::get_linear_isa( (shift)->name ) };
  }
  
  sub class_precedence_list {
      my $self = shift;
      my $name = $self->name;
  
      unless (Class::MOP::IS_RUNNING_ON_5_10()) {
          # NOTE:
          # We need to check for circular inheritance here
          # if we are are not on 5.10, cause 5.8 detects it
          # late. This will do nothing if all is well, and
          # blow up otherwise. Yes, it's an ugly hack, better
          # suggestions are welcome.
          # - SL
          ($name || return)->isa('This is a test for circular inheritance')
      }
  
      # if our mro is c3, we can
      # just grab the linear_isa
      if (mro::get_mro($name) eq 'c3') {
          return @{ mro::get_linear_isa($name) }
      }
      else {
          # NOTE:
          # we can't grab the linear_isa for dfs
          # since it has all the duplicates
          # already removed.
          return (
              $name,
              map {
                  Class::MOP::Class->initialize($_)->class_precedence_list()
              } $self->superclasses()
          );
      }
  }
  
  sub _method_lookup_order {
      return (shift->linearized_isa, 'UNIVERSAL');
  }
  
  ## Methods
  
  {
      my $fetch_and_prepare_method = sub {
          my ($self, $method_name) = @_;
          my $wrapped_metaclass = $self->wrapped_method_metaclass;
          # fetch it locally
          my $method = $self->get_method($method_name);
          # if we dont have local ...
          unless ($method) {
              # try to find the next method
              $method = $self->find_next_method_by_name($method_name);
              # die if it does not exist
              (defined $method)
                  || confess "The method '$method_name' was not found in the inheritance hierarchy for " . $self->name;
              # and now make sure to wrap it
              # even if it is already wrapped
              # because we need a new sub ref
              $method = $wrapped_metaclass->wrap($method,
                  package_name => $self->name,
                  name         => $method_name,
              );
          }
          else {
              # now make sure we wrap it properly
              $method = $wrapped_metaclass->wrap($method,
                  package_name => $self->name,
                  name         => $method_name,
              ) unless $method->isa($wrapped_metaclass);
          }
          $self->add_method($method_name => $method);
          return $method;
      };
  
      sub add_before_method_modifier {
          my ($self, $method_name, $method_modifier) = @_;
          (defined $method_name && length $method_name)
              || confess "You must pass in a method name";
          my $method = $fetch_and_prepare_method->($self, $method_name);
          $method->add_before_modifier(
              subname(':before' => $method_modifier)
          );
      }
  
      sub add_after_method_modifier {
          my ($self, $method_name, $method_modifier) = @_;
          (defined $method_name && length $method_name)
              || confess "You must pass in a method name";
          my $method = $fetch_and_prepare_method->($self, $method_name);
          $method->add_after_modifier(
              subname(':after' => $method_modifier)
          );
      }
  
      sub add_around_method_modifier {
          my ($self, $method_name, $method_modifier) = @_;
          (defined $method_name && length $method_name)
              || confess "You must pass in a method name";
          my $method = $fetch_and_prepare_method->($self, $method_name);
          $method->add_around_modifier(
              subname(':around' => $method_modifier)
          );
      }
  
      # NOTE:
      # the methods above used to be named like this:
      #    ${pkg}::${method}:(before|after|around)
      # but this proved problematic when using one modifier
      # to wrap multiple methods (something which is likely
      # to happen pretty regularly IMO). So instead of naming
      # it like this, I have chosen to just name them purely
      # with their modifier names, like so:
      #    :(before|after|around)
      # The fact is that in a stack trace, it will be fairly
      # evident from the context what method they are attached
      # to, and so don't need the fully qualified name.
  }
  
  sub find_method_by_name {
      my ($self, $method_name) = @_;
      (defined $method_name && length $method_name)
          || confess "You must define a method name to find";
      foreach my $class ($self->_method_lookup_order) {
          my $method = Class::MOP::Class->initialize($class)->get_method($method_name);
          return $method if defined $method;
      }
      return;
  }
  
  sub get_all_methods {
      my $self = shift;
  
      my %methods;
      for my $class ( reverse $self->_method_lookup_order ) {
          my $meta = Class::MOP::Class->initialize($class);
  
          $methods{ $_->name } = $_ for $meta->_get_local_methods;
      }
  
      return values %methods;
  }
  
  sub get_all_method_names {
      my $self = shift;
      map { $_->name } $self->get_all_methods;
  }
  
  sub find_all_methods_by_name {
      my ($self, $method_name) = @_;
      (defined $method_name && length $method_name)
          || confess "You must define a method name to find";
      my @methods;
      foreach my $class ($self->_method_lookup_order) {
          # fetch the meta-class ...
          my $meta = Class::MOP::Class->initialize($class);
          push @methods => {
              name  => $method_name,
              class => $class,
              code  => $meta->get_method($method_name)
          } if $meta->has_method($method_name);
      }
      return @methods;
  }
  
  sub find_next_method_by_name {
      my ($self, $method_name) = @_;
      (defined $method_name && length $method_name)
          || confess "You must define a method name to find";
      my @cpl = ($self->_method_lookup_order);
      shift @cpl; # discard ourselves
      foreach my $class (@cpl) {
          my $method = Class::MOP::Class->initialize($class)->get_method($method_name);
          return $method if defined $method;
      }
      return;
  }
  
  sub update_meta_instance_dependencies {
      my $self = shift;
  
      if ( $self->{meta_instance_dependencies} ) {
          return $self->add_meta_instance_dependencies;
      }
  }
  
  sub add_meta_instance_dependencies {
      my $self = shift;
  
      $self->remove_meta_instance_dependencies;
  
      my @attrs = $self->get_all_attributes();
  
      my %seen;
      my @classes = grep { not $seen{ $_->name }++ }
          map { $_->associated_class } @attrs;
  
      foreach my $class (@classes) {
          $class->add_dependent_meta_instance($self);
      }
  
      $self->{meta_instance_dependencies} = \@classes;
  }
  
  sub remove_meta_instance_dependencies {
      my $self = shift;
  
      if ( my $classes = delete $self->{meta_instance_dependencies} ) {
          foreach my $class (@$classes) {
              $class->remove_dependent_meta_instance($self);
          }
  
          return $classes;
      }
  
      return;
  
  }
  
  sub add_dependent_meta_instance {
      my ( $self, $metaclass ) = @_;
      push @{ $self->{dependent_meta_instances} }, $metaclass;
  }
  
  sub remove_dependent_meta_instance {
      my ( $self, $metaclass ) = @_;
      my $name = $metaclass->name;
      @$_ = grep { $_->name ne $name } @$_
          for $self->{dependent_meta_instances};
  }
  
  sub invalidate_meta_instances {
      my $self = shift;
      $_->invalidate_meta_instance()
          for $self, @{ $self->{dependent_meta_instances} };
  }
  
  sub invalidate_meta_instance {
      my $self = shift;
      undef $self->{_meta_instance};
  }
  
  # check if we can reinitialize
  sub is_pristine {
      my $self = shift;
  
      # if any local attr is defined
      return if $self->get_attribute_list;
  
      # or any non-declared methods
      for my $method ( map { $self->get_method($_) } $self->get_method_list ) {
          return if $method->isa("Class::MOP::Method::Generated");
          # FIXME do we need to enforce this too? return unless $method->isa( $self->method_metaclass );
      }
  
      return 1;
  }
  
  ## Class closing
  
  sub is_mutable   { 1 }
  sub is_immutable { 0 }
  
  sub immutable_options { %{ $_[0]{__immutable}{options} || {} } }
  
  sub _immutable_options {
      my ( $self, @args ) = @_;
  
      return (
          inline_accessors   => 1,
          inline_constructor => 1,
          inline_destructor  => 0,
          debug              => 0,
          immutable_trait    => $self->immutable_trait,
          constructor_name   => $self->constructor_name,
          constructor_class  => $self->constructor_class,
          destructor_class   => $self->destructor_class,
          @args,
      );
  }
  
  sub make_immutable {
      my ( $self, @args ) = @_;
  
      return $self unless $self->is_mutable;
  
      my ($file, $line) = (caller)[1..2];
  
      $self->_initialize_immutable(
          file => $file,
          line => $line,
          $self->_immutable_options(@args),
      );
      $self->_rebless_as_immutable(@args);
  
      return $self;
  }
  
  sub make_mutable {
      my $self = shift;
  
      if ( $self->is_immutable ) {
          my @args = $self->immutable_options;
          $self->_rebless_as_mutable();
          $self->_remove_inlined_code(@args);
          delete $self->{__immutable};
          return $self;
      }
      else {
          return;
      }
  }
  
  sub _rebless_as_immutable {
      my ( $self, @args ) = @_;
  
      $self->{__immutable}{original_class} = ref $self;
  
      bless $self => $self->_immutable_metaclass(@args);
  }
  
  sub _immutable_metaclass {
      my ( $self, %args ) = @_;
  
      if ( my $class = $args{immutable_metaclass} ) {
          return $class;
      }
  
      my $trait = $args{immutable_trait} = $self->immutable_trait
          || confess "no immutable trait specified for $self";
  
      my $meta      = $self->meta;
      my $meta_attr = $meta->find_attribute_by_name("immutable_trait");
  
      my $class_name;
  
      if ( $meta_attr and $trait eq $meta_attr->default ) {
          # if the trait is the same as the default we try and pick a
          # predictable name for the immutable metaclass
          $class_name = 'Class::MOP::Class::Immutable::' . ref($self);
      }
      else {
          $class_name = join '::', 'Class::MOP::Class::Immutable::CustomTrait',
              $trait, 'ForMetaClass', ref($self);
      }
  
      return $class_name
          if is_class_loaded($class_name);
  
      # If the metaclass is a subclass of CMOP::Class which has had
      # metaclass roles applied (via Moose), then we want to make sure
      # that we preserve that anonymous class (see Fey::ORM for an
      # example of where this matters).
      my $meta_name = $meta->_real_ref_name;
  
      my $immutable_meta = $meta_name->create(
          $class_name,
          superclasses => [ ref $self ],
      );
  
      Class::MOP::MiniTrait::apply( $immutable_meta, $trait );
  
      $immutable_meta->make_immutable(
          inline_constructor => 0,
          inline_accessors   => 0,
      );
  
      return $class_name;
  }
  
  sub _remove_inlined_code {
      my $self = shift;
  
      $self->remove_method( $_->name ) for $self->_inlined_methods;
  
      delete $self->{__immutable}{inlined_methods};
  }
  
  sub _inlined_methods { @{ $_[0]{__immutable}{inlined_methods} || [] } }
  
  sub _add_inlined_method {
      my ( $self, $method ) = @_;
  
      push @{ $self->{__immutable}{inlined_methods} ||= [] }, $method;
  }
  
  sub _initialize_immutable {
      my ( $self, %args ) = @_;
  
      $self->{__immutable}{options} = \%args;
      $self->_install_inlined_code(%args);
  }
  
  sub _install_inlined_code {
      my ( $self, %args ) = @_;
  
      # FIXME
      $self->_inline_accessors(%args)   if $args{inline_accessors};
      $self->_inline_constructor(%args) if $args{inline_constructor};
      $self->_inline_destructor(%args)  if $args{inline_destructor};
  }
  
  sub _rebless_as_mutable {
      my $self = shift;
  
      bless $self, $self->_get_mutable_metaclass_name;
  
      return $self;
  }
  
  sub _inline_accessors {
      my $self = shift;
  
      foreach my $attr_name ( $self->get_attribute_list ) {
          $self->get_attribute($attr_name)->install_accessors(1);
      }
  }
  
  sub _inline_constructor {
      my ( $self, %args ) = @_;
  
      my $name = $args{constructor_name};
      # A class may not even have a constructor, and that's okay.
      return unless defined $name;
  
      if ( $self->has_method($name) && !$args{replace_constructor} ) {
          my $class = $self->name;
          warn "Not inlining a constructor for $class since it defines"
              . " its own constructor.\n"
              . "If you are certain you don't need to inline your"
              . " constructor, specify inline_constructor => 0 in your"
              . " call to $class->meta->make_immutable\n";
          return;
      }
  
      my $constructor_class = $args{constructor_class};
  
      load_class($constructor_class);
  
      my $constructor = $constructor_class->new(
          options      => \%args,
          metaclass    => $self,
          is_inline    => 1,
          package_name => $self->name,
          name         => $name,
          definition_context => {
              description => "constructor " . $self->name . "::" . $name,
              file        => $args{file},
              line        => $args{line},
          },
      );
  
      if ( $args{replace_constructor} or $constructor->can_be_inlined ) {
          $self->add_method( $name => $constructor );
          $self->_add_inlined_method($constructor);
      }
  }
  
  sub _inline_destructor {
      my ( $self, %args ) = @_;
  
      ( exists $args{destructor_class} && defined $args{destructor_class} )
          || confess "The 'inline_destructor' option is present, but "
          . "no destructor class was specified";
  
      if ( $self->has_method('DESTROY') && ! $args{replace_destructor} ) {
          my $class = $self->name;
          warn "Not inlining a destructor for $class since it defines"
              . " its own destructor.\n";
          return;
      }
  
      my $destructor_class = $args{destructor_class};
  
      load_class($destructor_class);
  
      return unless $destructor_class->is_needed($self);
  
      my $destructor = $destructor_class->new(
          options      => \%args,
          metaclass    => $self,
          package_name => $self->name,
          name         => 'DESTROY',
          definition_context => {
              description => "destructor " . $self->name . "::DESTROY",
              file        => $args{file},
              line        => $args{line},
          },
      );
  
      if ( $args{replace_destructor} or $destructor->can_be_inlined ) {
          $self->add_method( 'DESTROY' => $destructor );
          $self->_add_inlined_method($destructor);
      }
  }
  
  1;
  
  # ABSTRACT: Class Meta Object
  
  
  
  =pod
  
  =head1 NAME
  
  Class::MOP::Class - Class Meta Object
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 SYNOPSIS
  
    # assuming that class Foo
    # has been defined, you can
  
    # use this for introspection ...
  
    # add a method to Foo ...
    Foo->meta->add_method( 'bar' => sub {...} )
  
    # get a list of all the classes searched
    # the method dispatcher in the correct order
    Foo->meta->class_precedence_list()
  
    # remove a method from Foo
    Foo->meta->remove_method('bar');
  
    # or use this to actually create classes ...
  
    Class::MOP::Class->create(
        'Bar' => (
            version      => '0.01',
            superclasses => ['Foo'],
            attributes   => [
                Class::MOP::Attribute->new('$bar'),
                Class::MOP::Attribute->new('$baz'),
            ],
            methods => {
                calculate_bar => sub {...},
                construct_baz => sub {...}
            }
        )
    );
  
  =head1 DESCRIPTION
  
  The Class Protocol is the largest and most complex part of the
  Class::MOP meta-object protocol. It controls the introspection and
  manipulation of Perl 5 classes, and it can create them as well. The
  best way to understand what this module can do is to read the
  documentation for each of its methods.
  
  =head1 INHERITANCE
  
  C<Class::MOP::Class> is a subclass of L<Class::MOP::Module>.
  
  =head1 METHODS
  
  =head2 Class construction
  
  These methods all create new C<Class::MOP::Class> objects. These
  objects can represent existing classes or they can be used to create
  new classes from scratch.
  
  The metaclass object for a given class is a singleton. If you attempt
  to create a metaclass for the same class twice, you will just get the
  existing object.
  
  =over 4
  
  =item B<< Class::MOP::Class->create($package_name, %options) >>
  
  This method creates a new C<Class::MOP::Class> object with the given
  package name. It accepts a number of options:
  
  =over 8
  
  =item * version
  
  An optional version number for the newly created package.
  
  =item * authority
  
  An optional authority for the newly created package.
  
  =item * superclasses
  
  An optional array reference of superclass names.
  
  =item * methods
  
  An optional hash reference of methods for the class. The keys of the
  hash reference are method names and values are subroutine references.
  
  =item * attributes
  
  An optional array reference of L<Class::MOP::Attribute> objects.
  
  =item * meta_name
  
  Specifies the name to install the C<meta> method for this class under.
  If it is not passed, C<meta> is assumed, and if C<undef> is explicitly
  given, no meta method will be installed.
  
  =item * weaken
  
  If true, the metaclass that is stored in the global cache will be a
  weak reference.
  
  Classes created in this way are destroyed once the metaclass they are
  attached to goes out of scope, and will be removed from Perl's internal
  symbol table.
  
  All instances of a class with a weakened metaclass keep a special
  reference to the metaclass object, which prevents the metaclass from
  going out of scope while any instances exist.
  
  This only works if the instance is based on a hash reference, however.
  
  =back
  
  =item B<< Class::MOP::Class->create_anon_class(%options) >>
  
  This method works just like C<< Class::MOP::Class->create >> but it
  creates an "anonymous" class. In fact, the class does have a name, but
  that name is a unique name generated internally by this module.
  
  It accepts the same C<superclasses>, C<methods>, and C<attributes>
  parameters that C<create> accepts.
  
  Anonymous classes default to C<< weaken => 1 >>, although this can be
  overridden.
  
  =item B<< Class::MOP::Class->initialize($package_name, %options) >>
  
  This method will initialize a C<Class::MOP::Class> object for the
  named package. Unlike C<create>, this method I<will not> create a new
  class.
  
  The purpose of this method is to retrieve a C<Class::MOP::Class>
  object for introspecting an existing class.
  
  If an existing C<Class::MOP::Class> object exists for the named
  package, it will be returned, and any options provided will be
  ignored!
  
  If the object does not yet exist, it will be created.
  
  The valid options that can be passed to this method are
  C<attribute_metaclass>, C<method_metaclass>,
  C<wrapped_method_metaclass>, and C<instance_metaclass>. These are all
  optional, and default to the appropriate class in the C<Class::MOP>
  distribution.
  
  =back
  
  =head2 Object instance construction and cloning
  
  These methods are all related to creating and/or cloning object
  instances.
  
  =over 4
  
  =item B<< $metaclass->clone_object($instance, %params) >>
  
  This method clones an existing object instance. Any parameters you
  provide are will override existing attribute values in the object.
  
  This is a convenience method for cloning an object instance, then
  blessing it into the appropriate package.
  
  You could implement a clone method in your class, using this method:
  
    sub clone {
        my ($self, %params) = @_;
        $self->meta->clone_object($self, %params);
    }
  
  =item B<< $metaclass->rebless_instance($instance, %params) >>
  
  This method changes the class of C<$instance> to the metaclass's class.
  
  You can only rebless an instance into a subclass of its current
  class. If you pass any additional parameters, these will be treated
  like constructor parameters and used to initialize the object's
  attributes. Any existing attributes that are already set will be
  overwritten.
  
  Before reblessing the instance, this method will call
  C<rebless_instance_away> on the instance's current metaclass. This method
  will be passed the instance, the new metaclass, and any parameters
  specified to C<rebless_instance>. By default, C<rebless_instance_away>
  does nothing; it is merely a hook.
  
  =item B<< $metaclass->rebless_instance_back($instance) >>
  
  Does the same thing as C<rebless_instance>, except that you can only
  rebless an instance into one of its superclasses. Any attributes that
  do not exist in the superclass will be deinitialized.
  
  This is a much more dangerous operation than C<rebless_instance>,
  especially when multiple inheritance is involved, so use this carefully!
  
  =item B<< $metaclass->new_object(%params) >>
  
  This method is used to create a new object of the metaclass's
  class. Any parameters you provide are used to initialize the
  instance's attributes. A special C<__INSTANCE__> key can be passed to
  provide an already generated instance, rather than having Class::MOP
  generate it for you. This is mostly useful for using Class::MOP with
  foreign classes which generate instances using their own constructors.
  
  =item B<< $metaclass->instance_metaclass >>
  
  Returns the class name of the instance metaclass. See
  L<Class::MOP::Instance> for more information on the instance
  metaclass.
  
  =item B<< $metaclass->get_meta_instance >>
  
  Returns an instance of the C<instance_metaclass> to be used in the
  construction of a new instance of the class.
  
  =back
  
  =head2 Informational predicates
  
  These are a few predicate methods for asking information about the
  class itself.
  
  =over 4
  
  =item B<< $metaclass->is_anon_class >>
  
  This returns true if the class was created by calling C<<
  Class::MOP::Class->create_anon_class >>.
  
  =item B<< $metaclass->is_mutable >>
  
  This returns true if the class is still mutable.
  
  =item B<< $metaclass->is_immutable >>
  
  This returns true if the class has been made immutable.
  
  =item B<< $metaclass->is_pristine >>
  
  A class is I<not> pristine if it has non-inherited attributes or if it
  has any generated methods.
  
  =back
  
  =head2 Inheritance Relationships
  
  =over 4
  
  =item B<< $metaclass->superclasses(@superclasses) >>
  
  This is a read-write accessor which represents the superclass
  relationships of the metaclass's class.
  
  This is basically sugar around getting and setting C<@ISA>.
  
  =item B<< $metaclass->class_precedence_list >>
  
  This returns a list of all of the class's ancestor classes. The
  classes are returned in method dispatch order.
  
  =item B<< $metaclass->linearized_isa >>
  
  This returns a list based on C<class_precedence_list> but with all
  duplicates removed.
  
  =item B<< $metaclass->subclasses >>
  
  This returns a list of all subclasses for this class, even indirect
  subclasses.
  
  =item B<< $metaclass->direct_subclasses >>
  
  This returns a list of immediate subclasses for this class, which does not
  include indirect subclasses.
  
  =back
  
  =head2 Method introspection and creation
  
  These methods allow you to introspect a class's methods, as well as
  add, remove, or change methods.
  
  Determining what is truly a method in a Perl 5 class requires some
  heuristics (aka guessing).
  
  Methods defined outside the package with a fully qualified name (C<sub
  Package::name { ... }>) will be included. Similarly, methods named
  with a fully qualified name using L<Sub::Name> are also included.
  
  However, we attempt to ignore imported functions.
  
  Ultimately, we are using heuristics to determine what truly is a
  method in a class, and these heuristics may get the wrong answer in
  some edge cases. However, for most "normal" cases the heuristics work
  correctly.
  
  =over 4
  
  =item B<< $metaclass->get_method($method_name) >>
  
  This will return a L<Class::MOP::Method> for the specified
  C<$method_name>. If the class does not have the specified method, it
  returns C<undef>
  
  =item B<< $metaclass->has_method($method_name) >>
  
  Returns a boolean indicating whether or not the class defines the
  named method. It does not include methods inherited from parent
  classes.
  
  =item B<< $metaclass->get_method_list >>
  
  This will return a list of method I<names> for all methods defined in
  this class.
  
  =item B<< $metaclass->add_method($method_name, $method) >>
  
  This method takes a method name and a subroutine reference, and adds
  the method to the class.
  
  The subroutine reference can be a L<Class::MOP::Method>, and you are
  strongly encouraged to pass a meta method object instead of a code
  reference. If you do so, that object gets stored as part of the
  class's method map directly. If not, the meta information will have to
  be recreated later, and may be incorrect.
  
  If you provide a method object, this method will clone that object if
  the object's package name does not match the class name. This lets us
  track the original source of any methods added from other classes
  (notably Moose roles).
  
  =item B<< $metaclass->remove_method($method_name) >>
  
  Remove the named method from the class. This method returns the
  L<Class::MOP::Method> object for the method.
  
  =item B<< $metaclass->method_metaclass >>
  
  Returns the class name of the method metaclass, see
  L<Class::MOP::Method> for more information on the method metaclass.
  
  =item B<< $metaclass->wrapped_method_metaclass >>
  
  Returns the class name of the wrapped method metaclass, see
  L<Class::MOP::Method::Wrapped> for more information on the wrapped
  method metaclass.
  
  =item B<< $metaclass->get_all_methods >>
  
  This will traverse the inheritance hierarchy and return a list of all
  the L<Class::MOP::Method> objects for this class and its parents.
  
  =item B<< $metaclass->find_method_by_name($method_name) >>
  
  This will return a L<Class::MOP::Method> for the specified
  C<$method_name>. If the class does not have the specified method, it
  returns C<undef>
  
  Unlike C<get_method>, this method I<will> look for the named method in
  superclasses.
  
  =item B<< $metaclass->get_all_method_names >>
  
  This will return a list of method I<names> for all of this class's
  methods, including inherited methods.
  
  =item B<< $metaclass->find_all_methods_by_name($method_name) >>
  
  This method looks for the named method in the class and all of its
  parents. It returns every matching method it finds in the inheritance
  tree, so it returns a list of methods.
  
  Each method is returned as a hash reference with three keys. The keys
  are C<name>, C<class>, and C<code>. The C<code> key has a
  L<Class::MOP::Method> object as its value.
  
  The list of methods is distinct.
  
  =item B<< $metaclass->find_next_method_by_name($method_name) >>
  
  This method returns the first method in any superclass matching the
  given name. It is effectively the method that C<SUPER::$method_name>
  would dispatch to.
  
  =back
  
  =head2 Attribute introspection and creation
  
  Because Perl 5 does not have a core concept of attributes in classes,
  we can only return information about attributes which have been added
  via this class's methods. We cannot discover information about
  attributes which are defined in terms of "regular" Perl 5 methods.
  
  =over 4
  
  =item B<< $metaclass->get_attribute($attribute_name) >>
  
  This will return a L<Class::MOP::Attribute> for the specified
  C<$attribute_name>. If the class does not have the specified
  attribute, it returns C<undef>.
  
  NOTE that get_attribute does not search superclasses, for that you
  need to use C<find_attribute_by_name>.
  
  =item B<< $metaclass->has_attribute($attribute_name) >>
  
  Returns a boolean indicating whether or not the class defines the
  named attribute. It does not include attributes inherited from parent
  classes.
  
  =item B<< $metaclass->get_attribute_list >>
  
  This will return a list of attributes I<names> for all attributes
  defined in this class.  Note that this operates on the current class
  only, it does not traverse the inheritance hierarchy.
  
  =item B<< $metaclass->get_all_attributes >>
  
  This will traverse the inheritance hierarchy and return a list of all
  the L<Class::MOP::Attribute> objects for this class and its parents.
  
  =item B<< $metaclass->find_attribute_by_name($attribute_name) >>
  
  This will return a L<Class::MOP::Attribute> for the specified
  C<$attribute_name>. If the class does not have the specified
  attribute, it returns C<undef>.
  
  Unlike C<get_attribute>, this attribute I<will> look for the named
  attribute in superclasses.
  
  =item B<< $metaclass->add_attribute(...) >>
  
  This method accepts either an existing L<Class::MOP::Attribute>
  object or parameters suitable for passing to that class's C<new>
  method.
  
  The attribute provided will be added to the class.
  
  Any accessor methods defined by the attribute will be added to the
  class when the attribute is added.
  
  If an attribute of the same name already exists, the old attribute
  will be removed first.
  
  =item B<< $metaclass->remove_attribute($attribute_name) >>
  
  This will remove the named attribute from the class, and
  L<Class::MOP::Attribute> object.
  
  Removing an attribute also removes any accessor methods defined by the
  attribute.
  
  However, note that removing an attribute will only affect I<future>
  object instances created for this class, not existing instances.
  
  =item B<< $metaclass->attribute_metaclass >>
  
  Returns the class name of the attribute metaclass for this class. By
  default, this is L<Class::MOP::Attribute>.
  
  =back
  
  =head2 Class Immutability
  
  Making a class immutable "freezes" the class definition. You can no
  longer call methods which alter the class, such as adding or removing
  methods or attributes.
  
  Making a class immutable lets us optimize the class by inlining some
  methods, and also allows us to optimize some methods on the metaclass
  object itself.
  
  After immutabilization, the metaclass object will cache most informational
  methods that returns information about methods or attributes. Methods which
  would alter the class, such as C<add_attribute> and C<add_method>, will
  throw an error on an immutable metaclass object.
  
  The immutabilization system in L<Moose> takes much greater advantage
  of the inlining features than Class::MOP itself does.
  
  =over 4
  
  =item B<< $metaclass->make_immutable(%options) >>
  
  This method will create an immutable transformer and use it to make
  the class and its metaclass object immutable, and returns true
  (you should not rely on the details of this value apart from its truth).
  
  This method accepts the following options:
  
  =over 8
  
  =item * inline_accessors
  
  =item * inline_constructor
  
  =item * inline_destructor
  
  These are all booleans indicating whether the specified method(s)
  should be inlined.
  
  By default, accessors and the constructor are inlined, but not the
  destructor.
  
  =item * immutable_trait
  
  The name of a class which will be used as a parent class for the
  metaclass object being made immutable. This "trait" implements the
  post-immutability functionality of the metaclass (but not the
  transformation itself).
  
  This defaults to L<Class::MOP::Class::Immutable::Trait>.
  
  =item * constructor_name
  
  This is the constructor method name. This defaults to "new".
  
  =item * constructor_class
  
  The name of the method metaclass for constructors. It will be used to
  generate the inlined constructor. This defaults to
  "Class::MOP::Method::Constructor".
  
  =item * replace_constructor
  
  This is a boolean indicating whether an existing constructor should be
  replaced when inlining a constructor. This defaults to false.
  
  =item * destructor_class
  
  The name of the method metaclass for destructors. It will be used to
  generate the inlined destructor. This defaults to
  "Class::MOP::Method::Denstructor".
  
  =item * replace_destructor
  
  This is a boolean indicating whether an existing destructor should be
  replaced when inlining a destructor. This defaults to false.
  
  =back
  
  =item B<< $metaclass->immutable_options >>
  
  Returns a hash of the options used when making the class immutable, including
  both defaults and anything supplied by the user in the call to C<<
  $metaclass->make_immutable >>. This is useful if you need to temporarily make
  a class mutable and then restore immutability as it was before.
  
  =item B<< $metaclass->make_mutable >>
  
  Calling this method reverse the immutabilization transformation.
  
  =back
  
  =head2 Method Modifiers
  
  Method modifiers are hooks which allow a method to be wrapped with
  I<before>, I<after> and I<around> method modifiers. Every time a
  method is called, its modifiers are also called.
  
  A class can modify its own methods, as well as methods defined in
  parent classes.
  
  =head3 How method modifiers work?
  
  Method modifiers work by wrapping the original method and then
  replacing it in the class's symbol table. The wrappers will handle
  calling all the modifiers in the appropriate order and preserving the
  calling context for the original method.
  
  The return values of C<before> and C<after> modifiers are
  ignored. This is because their purpose is B<not> to filter the input
  and output of the primary method (this is done with an I<around>
  modifier).
  
  This may seem like an odd restriction to some, but doing this allows
  for simple code to be added at the beginning or end of a method call
  without altering the function of the wrapped method or placing any
  extra responsibility on the code of the modifier.
  
  Of course if you have more complex needs, you can use the C<around>
  modifier which allows you to change both the parameters passed to the
  wrapped method, as well as its return value.
  
  Before and around modifiers are called in last-defined-first-called
  order, while after modifiers are called in first-defined-first-called
  order. So the call tree might looks something like this:
  
    before 2
     before 1
      around 2
       around 1
        primary
       around 1
      around 2
     after 1
    after 2
  
  =head3 What is the performance impact?
  
  Of course there is a performance cost associated with method
  modifiers, but we have made every effort to make that cost directly
  proportional to the number of modifier features you use.
  
  The wrapping method does its best to B<only> do as much work as it
  absolutely needs to. In order to do this we have moved some of the
  performance costs to set-up time, where they are easier to amortize.
  
  All this said, our benchmarks have indicated the following:
  
    simple wrapper with no modifiers             100% slower
    simple wrapper with simple before modifier   400% slower
    simple wrapper with simple after modifier    450% slower
    simple wrapper with simple around modifier   500-550% slower
    simple wrapper with all 3 modifiers          1100% slower
  
  These numbers may seem daunting, but you must remember, every feature
  comes with some cost. To put things in perspective, just doing a
  simple C<AUTOLOAD> which does nothing but extract the name of the
  method called and return it costs about 400% over a normal method
  call.
  
  =over 4
  
  =item B<< $metaclass->add_before_method_modifier($method_name, $code) >>
  
  This wraps the specified method with the supplied subroutine
  reference. The modifier will be called as a method itself, and will
  receive the same arguments as are passed to the method.
  
  When the modifier exits, the wrapped method will be called.
  
  The return value of the modifier will be ignored.
  
  =item B<< $metaclass->add_after_method_modifier($method_name, $code) >>
  
  This wraps the specified method with the supplied subroutine
  reference. The modifier will be called as a method itself, and will
  receive the same arguments as are passed to the method.
  
  When the wrapped methods exits, the modifier will be called.
  
  The return value of the modifier will be ignored.
  
  =item B<< $metaclass->add_around_method_modifier($method_name, $code) >>
  
  This wraps the specified method with the supplied subroutine
  reference.
  
  The first argument passed to the modifier will be a subroutine
  reference to the wrapped method. The second argument is the object,
  and after that come any arguments passed when the method is called.
  
  The around modifier can choose to call the original method, as well as
  what arguments to pass if it does so.
  
  The return value of the modifier is what will be seen by the caller.
  
  =back
  
  =head2 Introspection
  
  =over 4
  
  =item B<< Class::MOP::Class->meta >>
  
  This will return a L<Class::MOP::Class> instance for this class.
  
  It should also be noted that L<Class::MOP> will actually bootstrap
  this module by installing a number of attribute meta-objects into its
  metaclass.
  
  =back
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_CLASS_MOP_CLASS

$fatpacked{"i686-linux/Class/MOP/Class/Immutable/Trait.pm"} = <<'I686-LINUX_CLASS_MOP_CLASS_IMMUTABLE_TRAIT';
  package Class::MOP::Class::Immutable::Trait;
  BEGIN {
    $Class::MOP::Class::Immutable::Trait::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Class::MOP::Class::Immutable::Trait::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use MRO::Compat;
  
  use Carp 'confess';
  use Scalar::Util 'blessed', 'weaken';
  
  # the original class of the metaclass instance
  sub _get_mutable_metaclass_name { $_[0]{__immutable}{original_class} }
  
  sub is_mutable   { 0 }
  sub is_immutable { 1 }
  
  sub _immutable_metaclass { ref $_[1] }
  
  sub _immutable_read_only {
      my $name = shift;
      confess "The '$name' method is read-only when called on an immutable instance";
  }
  
  sub _immutable_cannot_call {
      my $name = shift;
      Carp::confess "The '$name' method cannot be called on an immutable instance";
  }
  
  for my $name (qw/superclasses/) {
      no strict 'refs';
      *{__PACKAGE__."::$name"} = sub {
          my $orig = shift;
          my $self = shift;
          _immutable_read_only($name) if @_;
          $self->$orig;
      };
  }
  
  for my $name (qw/add_method alias_method remove_method add_attribute remove_attribute remove_package_symbol add_package_symbol/) {
      no strict 'refs';
      *{__PACKAGE__."::$name"} = sub { _immutable_cannot_call($name) };
  }
  
  sub class_precedence_list {
      my $orig = shift;
      my $self = shift;
      @{ $self->{__immutable}{class_precedence_list}
              ||= [ $self->$orig ] };
  }
  
  sub linearized_isa {
      my $orig = shift;
      my $self = shift;
      @{ $self->{__immutable}{linearized_isa} ||= [ $self->$orig ] };
  }
  
  sub get_all_methods {
      my $orig = shift;
      my $self = shift;
      @{ $self->{__immutable}{get_all_methods} ||= [ $self->$orig ] };
  }
  
  sub get_all_method_names {
      my $orig = shift;
      my $self = shift;
      @{ $self->{__immutable}{get_all_method_names} ||= [ $self->$orig ] };
  }
  
  sub get_all_attributes {
      my $orig = shift;
      my $self = shift;
      @{ $self->{__immutable}{get_all_attributes} ||= [ $self->$orig ] };
  }
  
  sub get_meta_instance {
      my $orig = shift;
      my $self = shift;
      $self->{__immutable}{get_meta_instance} ||= $self->$orig;
  }
  
  sub _method_map {
      my $orig = shift;
      my $self = shift;
      $self->{__immutable}{_method_map} ||= $self->$orig;
  }
  
  1;
  
  # ABSTRACT: Implements immutability for metaclass objects
  
  
  
  =pod
  
  =head1 NAME
  
  Class::MOP::Class::Immutable::Trait - Implements immutability for metaclass objects
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This class provides a pseudo-trait that is applied to immutable metaclass
  objects. In reality, it is simply a parent class.
  
  It implements caching and read-only-ness for various metaclass methods.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
  
I686-LINUX_CLASS_MOP_CLASS_IMMUTABLE_TRAIT

$fatpacked{"i686-linux/Class/MOP/Deprecated.pm"} = <<'I686-LINUX_CLASS_MOP_DEPRECATED';
  package Class::MOP::Deprecated;
  BEGIN {
    $Class::MOP::Deprecated::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Class::MOP::Deprecated::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Package::DeprecationManager -deprecations => {
  };
  
  1;
  
  # ABSTRACT: Manages deprecation warnings for Class::MOP
  
  
  
  =pod
  
  =head1 NAME
  
  Class::MOP::Deprecated - Manages deprecation warnings for Class::MOP
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
      use Class::MOP::Deprecated -api_version => $version;
  
  =head1 FUNCTIONS
  
  This module manages deprecation warnings for features that have been
  deprecated in Class::MOP.
  
  If you specify C<< -api_version => $version >>, you can use deprecated features
  without warnings. Note that this special treatment is limited to the package
  that loads C<Class::MOP::Deprecated>.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_CLASS_MOP_DEPRECATED

$fatpacked{"i686-linux/Class/MOP/Instance.pm"} = <<'I686-LINUX_CLASS_MOP_INSTANCE';
  
  package Class::MOP::Instance;
  BEGIN {
    $Class::MOP::Instance::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Class::MOP::Instance::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Scalar::Util 'isweak', 'weaken', 'blessed';
  
  use base 'Class::MOP::Object';
  
  # make this not a valid method name, to avoid (most) attribute conflicts
  my $RESERVED_MOP_SLOT = '<<MOP>>';
  
  sub BUILDARGS {
      my ($class, @args) = @_;
  
      if ( @args == 1 ) {
          unshift @args, "associated_metaclass";
      } elsif ( @args >= 2 && blessed($args[0]) && $args[0]->isa("Class::MOP::Class") ) {
          # compat mode
          my ( $meta, @attrs ) = @args;
          @args = ( associated_metaclass => $meta, attributes => \@attrs );
      }
  
      my %options = @args;
      # FIXME lazy_build
      $options{slots} ||= [ map { $_->slots } @{ $options{attributes} || [] } ];
      $options{slot_hash} = { map { $_ => undef } @{ $options{slots} } }; # FIXME lazy_build
  
      return \%options;
  }
  
  sub new {
      my $class = shift;
      my $options = $class->BUILDARGS(@_);
  
      # FIXME replace with a proper constructor
      my $instance = $class->_new(%$options);
  
      # FIXME weak_ref => 1,
      weaken($instance->{'associated_metaclass'});
  
      return $instance;
  }
  
  sub _new {
      my $class = shift;
      return Class::MOP::Class->initialize($class)->new_object(@_)
        if $class ne __PACKAGE__;
  
      my $params = @_ == 1 ? $_[0] : {@_};
      return bless {
          # NOTE:
          # I am not sure that it makes
          # sense to pass in the meta
          # The ideal would be to just
          # pass in the class name, but
          # that is placing too much of
          # an assumption on bless(),
          # which is *probably* a safe
          # assumption,.. but you can
          # never tell <:)
          'associated_metaclass' => $params->{associated_metaclass},
          'attributes'           => $params->{attributes},
          'slots'                => $params->{slots},
          'slot_hash'            => $params->{slot_hash},
      } => $class;
  }
  
  sub _class_name { $_[0]->{_class_name} ||= $_[0]->associated_metaclass->name }
  
  sub create_instance {
      my $self = shift;
      bless {}, $self->_class_name;
  }
  
  sub clone_instance {
      my ($self, $instance) = @_;
  
      my $clone = $self->create_instance;
      for my $attr ($self->get_all_attributes) {
          next unless $attr->has_value($instance);
          for my $slot ($attr->slots) {
              my $val = $self->get_slot_value($instance, $slot);
              $self->set_slot_value($clone, $slot, $val);
              $self->weaken_slot_value($clone, $slot)
                  if $self->slot_value_is_weak($instance, $slot);
          }
      }
  
      $self->_set_mop_slot($clone, $self->_get_mop_slot($instance))
          if $self->_has_mop_slot($instance);
  
      return $clone;
  }
  
  # operations on meta instance
  
  sub get_all_slots {
      my $self = shift;
      return @{$self->{'slots'}};
  }
  
  sub get_all_attributes {
      my $self = shift;
      return @{$self->{attributes}};
  }
  
  sub is_valid_slot {
      my ($self, $slot_name) = @_;
      exists $self->{'slot_hash'}->{$slot_name};
  }
  
  # operations on created instances
  
  sub get_slot_value {
      my ($self, $instance, $slot_name) = @_;
      $instance->{$slot_name};
  }
  
  sub set_slot_value {
      my ($self, $instance, $slot_name, $value) = @_;
      $instance->{$slot_name} = $value;
  }
  
  sub initialize_slot {
      my ($self, $instance, $slot_name) = @_;
      return;
  }
  
  sub deinitialize_slot {
      my ( $self, $instance, $slot_name ) = @_;
      delete $instance->{$slot_name};
  }
  
  sub initialize_all_slots {
      my ($self, $instance) = @_;
      foreach my $slot_name ($self->get_all_slots) {
          $self->initialize_slot($instance, $slot_name);
      }
  }
  
  sub deinitialize_all_slots {
      my ($self, $instance) = @_;
      foreach my $slot_name ($self->get_all_slots) {
          $self->deinitialize_slot($instance, $slot_name);
      }
  }
  
  sub is_slot_initialized {
      my ($self, $instance, $slot_name, $value) = @_;
      exists $instance->{$slot_name};
  }
  
  sub weaken_slot_value {
      my ($self, $instance, $slot_name) = @_;
      weaken $instance->{$slot_name};
  }
  
  sub slot_value_is_weak {
      my ($self, $instance, $slot_name) = @_;
      isweak $instance->{$slot_name};
  }
  
  sub strengthen_slot_value {
      my ($self, $instance, $slot_name) = @_;
      $self->set_slot_value($instance, $slot_name, $self->get_slot_value($instance, $slot_name));
  }
  
  sub rebless_instance_structure {
      my ($self, $instance, $metaclass) = @_;
  
      # we use $_[1] here because of t/cmop/rebless_overload.t regressions
      # on 5.8.8
      bless $_[1], $metaclass->name;
  }
  
  sub is_dependent_on_superclasses {
      return; # for meta instances that require updates on inherited slot changes
  }
  
  sub _get_mop_slot {
      my ($self, $instance) = @_;
      $self->get_slot_value($instance, $RESERVED_MOP_SLOT);
  }
  
  sub _has_mop_slot {
      my ($self, $instance) = @_;
      $self->is_slot_initialized($instance, $RESERVED_MOP_SLOT);
  }
  
  sub _set_mop_slot {
      my ($self, $instance, $value) = @_;
      $self->set_slot_value($instance, $RESERVED_MOP_SLOT, $value);
  }
  
  sub _clear_mop_slot {
      my ($self, $instance) = @_;
      $self->deinitialize_slot($instance, $RESERVED_MOP_SLOT);
  }
  
  # inlinable operation snippets
  
  sub is_inlinable { 1 }
  
  sub inline_create_instance {
      my ($self, $class_variable) = @_;
      'bless {} => ' . $class_variable;
  }
  
  sub inline_slot_access {
      my ($self, $instance, $slot_name) = @_;
      sprintf q[%s->{"%s"}], $instance, quotemeta($slot_name);
  }
  
  sub inline_get_is_lvalue { 1 }
  
  sub inline_get_slot_value {
      my ($self, $instance, $slot_name) = @_;
      $self->inline_slot_access($instance, $slot_name);
  }
  
  sub inline_set_slot_value {
      my ($self, $instance, $slot_name, $value) = @_;
      $self->inline_slot_access($instance, $slot_name) . " = $value",
  }
  
  sub inline_initialize_slot {
      my ($self, $instance, $slot_name) = @_;
      return '';
  }
  
  sub inline_deinitialize_slot {
      my ($self, $instance, $slot_name) = @_;
      "delete " . $self->inline_slot_access($instance, $slot_name);
  }
  sub inline_is_slot_initialized {
      my ($self, $instance, $slot_name) = @_;
      "exists " . $self->inline_slot_access($instance, $slot_name);
  }
  
  sub inline_weaken_slot_value {
      my ($self, $instance, $slot_name) = @_;
      sprintf "Scalar::Util::weaken( %s )", $self->inline_slot_access($instance, $slot_name);
  }
  
  sub inline_strengthen_slot_value {
      my ($self, $instance, $slot_name) = @_;
      $self->inline_set_slot_value($instance, $slot_name, $self->inline_slot_access($instance, $slot_name));
  }
  
  sub inline_rebless_instance_structure {
      my ($self, $instance, $class_variable) = @_;
      "bless $instance => $class_variable";
  }
  
  sub _inline_get_mop_slot {
      my ($self, $instance) = @_;
      $self->inline_get_slot_value($instance, $RESERVED_MOP_SLOT);
  }
  
  sub _inline_set_mop_slot {
      my ($self, $instance, $value) = @_;
      $self->inline_set_slot_value($instance, $RESERVED_MOP_SLOT, $value);
  }
  
  sub _inline_clear_mop_slot {
      my ($self, $instance) = @_;
      $self->inline_deinitialize_slot($instance, $RESERVED_MOP_SLOT);
  }
  
  1;
  
  # ABSTRACT: Instance Meta Object
  
  
  
  =pod
  
  =head1 NAME
  
  Class::MOP::Instance - Instance Meta Object
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  The Instance Protocol controls the creation of object instances, and
  the storage of attribute values in those instances.
  
  Using this API directly in your own code violates encapsulation, and
  we recommend that you use the appropriate APIs in L<Class::MOP::Class>
  and L<Class::MOP::Attribute> instead. Those APIs in turn call the
  methods in this class as appropriate.
  
  This class also participates in generating inlined code by providing
  snippets of code to access an object instance.
  
  =head1 METHODS
  
  =head2 Object construction
  
  =over 4
  
  =item B<< Class::MOP::Instance->new(%options) >>
  
  This method creates a new meta-instance object.
  
  It accepts the following keys in C<%options>:
  
  =over 8
  
  =item * associated_metaclass
  
  The L<Class::MOP::Class> object for which instances will be created.
  
  =item * attributes
  
  An array reference of L<Class::MOP::Attribute> objects. These are the
  attributes which can be stored in each instance.
  
  =back
  
  =back
  
  =head2 Creating and altering instances
  
  =over 4
  
  =item B<< $metainstance->create_instance >>
  
  This method returns a reference blessed into the associated
  metaclass's class.
  
  The default is to use a hash reference. Subclasses can override this.
  
  =item B<< $metainstance->clone_instance($instance) >>
  
  Given an instance, this method creates a new object by making
  I<shallow> clone of the original.
  
  =back
  
  =head2 Introspection
  
  =over 4
  
  =item B<< $metainstance->associated_metaclass >>
  
  This returns the L<Class::MOP::Class> object associated with the
  meta-instance object.
  
  =item B<< $metainstance->get_all_slots >>
  
  This returns a list of slot names stored in object instances. In
  almost all cases, slot names correspond directly attribute names.
  
  =item B<< $metainstance->is_valid_slot($slot_name) >>
  
  This will return true if C<$slot_name> is a valid slot name.
  
  =item B<< $metainstance->get_all_attributes >>
  
  This returns a list of attributes corresponding to the attributes
  passed to the constructor.
  
  =back
  
  =head2 Operations on Instance Structures
  
  It's important to understand that the meta-instance object is a
  different entity from the actual instances it creates. For this
  reason, any operations on the C<$instance_structure> always require
  that the object instance be passed to the method.
  
  =over 4
  
  =item B<< $metainstance->get_slot_value($instance_structure, $slot_name) >>
  
  =item B<< $metainstance->set_slot_value($instance_structure, $slot_name, $value) >>
  
  =item B<< $metainstance->initialize_slot($instance_structure, $slot_name) >>
  
  =item B<< $metainstance->deinitialize_slot($instance_structure, $slot_name) >>
  
  =item B<< $metainstance->initialize_all_slots($instance_structure) >>
  
  =item B<< $metainstance->deinitialize_all_slots($instance_structure) >>
  
  =item B<< $metainstance->is_slot_initialized($instance_structure, $slot_name) >>
  
  =item B<< $metainstance->weaken_slot_value($instance_structure, $slot_name) >>
  
  =item B<< $metainstance->slot_value_is_weak($instance_structure, $slot_name) >>
  
  =item B<< $metainstance->strengthen_slot_value($instance_structure, $slot_name) >>
  
  =item B<< $metainstance->rebless_instance_structure($instance_structure, $new_metaclass) >>
  
  The exact details of what each method does should be fairly obvious
  from the method name.
  
  =back
  
  =head2 Inlinable Instance Operations
  
  =over 4
  
  =item B<< $metainstance->is_inlinable >>
  
  This is a boolean that indicates whether or not slot access operations
  can be inlined. By default it is true, but subclasses can override
  this.
  
  =item B<< $metainstance->inline_create_instance($class_variable) >>
  
  This method expects a string that, I<when inlined>, will become a
  class name. This would literally be something like C<'$class'>, not an
  actual class name.
  
  It returns a snippet of code that creates a new object for the
  class. This is something like C< bless {}, $class_name >.
  
  =item B<< $metainstance->inline_get_is_lvalue >>
  
  Returns whether or not C<inline_get_slot_value> is a valid lvalue. This can be
  used to do extra optimizations when generating inlined methods.
  
  =item B<< $metainstance->inline_slot_access($instance_variable, $slot_name) >>
  
  =item B<< $metainstance->inline_get_slot_value($instance_variable, $slot_name) >>
  
  =item B<< $metainstance->inline_set_slot_value($instance_variable, $slot_name, $value) >>
  
  =item B<< $metainstance->inline_initialize_slot($instance_variable, $slot_name) >>
  
  =item B<< $metainstance->inline_deinitialize_slot($instance_variable, $slot_name) >>
  
  =item B<< $metainstance->inline_is_slot_initialized($instance_variable, $slot_name) >>
  
  =item B<< $metainstance->inline_weaken_slot_value($instance_variable, $slot_name) >>
  
  =item B<< $metainstance->inline_strengthen_slot_value($instance_variable, $slot_name) >>
  
  These methods all expect two arguments. The first is the name of a
  variable, than when inlined, will represent the object
  instance. Typically this will be a literal string like C<'$_[0]'>.
  
  The second argument is a slot name.
  
  The method returns a snippet of code that, when inlined, performs some
  operation on the instance.
  
  =item B<< $metainstance->inline_rebless_instance_structure($instance_variable, $class_variable) >>
  
  This takes the name of a variable that will, when inlined, represent the object
  instance, and the name of a variable that will represent the class to rebless
  into, and returns code to rebless an instance into a class.
  
  =back
  
  =head2 Introspection
  
  =over 4
  
  =item B<< Class::MOP::Instance->meta >>
  
  This will return a L<Class::MOP::Class> instance for this class.
  
  It should also be noted that L<Class::MOP> will actually bootstrap
  this module by installing a number of attribute meta-objects into its
  metaclass.
  
  =back
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
  
I686-LINUX_CLASS_MOP_INSTANCE

$fatpacked{"i686-linux/Class/MOP/Method.pm"} = <<'I686-LINUX_CLASS_MOP_METHOD';
  
  package Class::MOP::Method;
  BEGIN {
    $Class::MOP::Method::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Class::MOP::Method::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Carp         'confess';
  use Scalar::Util 'weaken', 'reftype', 'blessed';
  
  use base 'Class::MOP::Object';
  
  # NOTE:
  # if poked in the right way,
  # they should act like CODE refs.
  use overload '&{}' => sub { $_[0]->body }, fallback => 1;
  
  # construction
  
  sub wrap {
      my ( $class, @args ) = @_;
  
      unshift @args, 'body' if @args % 2 == 1;
  
      my %params = @args;
      my $code = $params{body};
  
      if (blessed($code) && $code->isa(__PACKAGE__)) {
          my $method = $code->clone;
          delete $params{body};
          Class::MOP::class_of($class)->rebless_instance($method, %params);
          return $method;
      }
      elsif (!ref $code || 'CODE' ne reftype($code)) {
          confess "You must supply a CODE reference to bless, not (" . ($code || 'undef') . ")";
      }
  
      ($params{package_name} && $params{name})
          || confess "You must supply the package_name and name parameters";
  
      my $self = $class->_new(\%params);
  
      weaken($self->{associated_metaclass}) if $self->{associated_metaclass};
  
      return $self;
  }
  
  sub _new {
      my $class = shift;
  
      return Class::MOP::Class->initialize($class)->new_object(@_)
          if $class ne __PACKAGE__;
  
      my $params = @_ == 1 ? $_[0] : {@_};
  
      return bless {
          'body'                 => $params->{body},
          'associated_metaclass' => $params->{associated_metaclass},
          'package_name'         => $params->{package_name},
          'name'                 => $params->{name},
          'original_method'      => $params->{original_method},
      } => $class;
  }
  
  ## accessors
  
  sub associated_metaclass { shift->{'associated_metaclass'} }
  
  sub attach_to_class {
      my ( $self, $class ) = @_;
      $self->{associated_metaclass} = $class;
      weaken($self->{associated_metaclass});
  }
  
  sub detach_from_class {
      my $self = shift;
      delete $self->{associated_metaclass};
  }
  
  sub fully_qualified_name {
      my $self = shift;
      $self->package_name . '::' . $self->name;
  }
  
  sub original_method { (shift)->{'original_method'} }
  
  sub _set_original_method { $_[0]->{'original_method'} = $_[1] }
  
  # It's possible that this could cause a loop if there is a circular
  # reference in here. That shouldn't ever happen in normal
  # circumstances, since original method only gets set when clone is
  # called. We _could_ check for such a loop, but it'd involve some sort
  # of package-lexical variable, and wouldn't be terribly subclassable.
  sub original_package_name {
      my $self = shift;
  
      $self->original_method
          ? $self->original_method->original_package_name
          : $self->package_name;
  }
  
  sub original_name {
      my $self = shift;
  
      $self->original_method
          ? $self->original_method->original_name
          : $self->name;
  }
  
  sub original_fully_qualified_name {
      my $self = shift;
  
      $self->original_method
          ? $self->original_method->original_fully_qualified_name
          : $self->fully_qualified_name;
  }
  
  sub execute {
      my $self = shift;
      $self->body->(@_);
  }
  
  # We used to go through use Class::MOP::Class->clone_instance to do this, but
  # this was awfully slow. This method may be called a number of times when
  # classes are loaded (especially during Moose role application), so it is
  # worth optimizing. - DR
  sub clone {
      my $self = shift;
  
      my $clone = bless { %{$self}, @_ }, blessed($self);
  
      $clone->_set_original_method($self);
  
      return $clone;
  }
  
  1;
  
  # ABSTRACT: Method Meta Object
  
  
  
  =pod
  
  =head1 NAME
  
  Class::MOP::Method - Method Meta Object
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  The Method Protocol is very small, since methods in Perl 5 are just
  subroutines in a specific package. We provide a very basic
  introspection interface.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Class::MOP::Method->wrap($code, %options) >>
  
  This is the constructor. It accepts a method body in the form of
  either a code reference or a L<Class::MOP::Method> instance, followed
  by a hash of options.
  
  The options are:
  
  =over 8
  
  =item * name
  
  The method name (without a package name). This is required if C<$code>
  is a coderef.
  
  =item * package_name
  
  The package name for the method. This is required if C<$code> is a
  coderef.
  
  =item * associated_metaclass
  
  An optional L<Class::MOP::Class> object. This is the metaclass for the
  method's class.
  
  =back
  
  =item B<< $metamethod->clone(%params) >>
  
  This makes a shallow clone of the method object. In particular,
  subroutine reference itself is shared between all clones of a given
  method.
  
  When a method is cloned, the original method object will be available
  by calling C<original_method> on the clone.
  
  =item B<< $metamethod->body >>
  
  This returns a reference to the method's subroutine.
  
  =item B<< $metamethod->name >>
  
  This returns the method's name
  
  =item B<< $metamethod->package_name >>
  
  This returns the method's package name.
  
  =item B<< $metamethod->fully_qualified_name >>
  
  This returns the method's fully qualified name (package name and
  method name).
  
  =item B<< $metamethod->associated_metaclass >>
  
  This returns the L<Class::MOP::Class> object for the method, if one
  exists.
  
  =item B<< $metamethod->original_method >>
  
  If this method object was created as a clone of some other method
  object, this returns the object that was cloned.
  
  =item B<< $metamethod->original_name >>
  
  This returns the method's original name, wherever it was first
  defined.
  
  If this method is a clone of a clone (of a clone, etc.), this method
  returns the name from the I<first> method in the chain of clones.
  
  =item B<< $metamethod->original_package_name >>
  
  This returns the method's original package name, wherever it was first
  defined.
  
  If this method is a clone of a clone (of a clone, etc.), this method
  returns the package name from the I<first> method in the chain of
  clones.
  
  =item B<< $metamethod->original_fully_qualified_name >>
  
  This returns the method's original fully qualified name, wherever it
  was first defined.
  
  If this method is a clone of a clone (of a clone, etc.), this method
  returns the fully qualified name from the I<first> method in the chain
  of clones.
  
  =item B<< $metamethod->is_stub >>
  
  Returns true if the method is just a stub:
  
    sub foo;
  
  =item B<< $metamethod->attach_to_class($metaclass) >>
  
  Given a L<Class::MOP::Class> object, this method sets the associated
  metaclass for the method. This will overwrite any existing associated
  metaclass.
  
  =item B<< $metamethod->detach_from_class >>
  
  Removes any associated metaclass object for the method.
  
  =item B<< $metamethod->execute(...) >>
  
  This executes the method. Any arguments provided will be passed on to
  the method itself.
  
  =item B<< Class::MOP::Method->meta >>
  
  This will return a L<Class::MOP::Class> instance for this class.
  
  It should also be noted that L<Class::MOP> will actually bootstrap
  this module by installing a number of attribute meta-objects into its
  metaclass.
  
  =back
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
  
I686-LINUX_CLASS_MOP_METHOD

$fatpacked{"i686-linux/Class/MOP/Method/Accessor.pm"} = <<'I686-LINUX_CLASS_MOP_METHOD_ACCESSOR';
  
  package Class::MOP::Method::Accessor;
  BEGIN {
    $Class::MOP::Method::Accessor::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Class::MOP::Method::Accessor::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Carp         'confess';
  use Scalar::Util 'blessed', 'weaken';
  use Try::Tiny;
  
  use base 'Class::MOP::Method::Generated';
  
  sub new {
      my $class   = shift;
      my %options = @_;
  
      (exists $options{attribute})
          || confess "You must supply an attribute to construct with";
  
      (exists $options{accessor_type})
          || confess "You must supply an accessor_type to construct with";
  
      (blessed($options{attribute}) && $options{attribute}->isa('Class::MOP::Attribute'))
          || confess "You must supply an attribute which is a 'Class::MOP::Attribute' instance";
  
      ($options{package_name} && $options{name})
          || confess "You must supply the package_name and name parameters $Class::MOP::Method::UPGRADE_ERROR_TEXT";
  
      my $self = $class->_new(\%options);
  
      # we don't want this creating
      # a cycle in the code, if not
      # needed
      weaken($self->{'attribute'});
  
      $self->_initialize_body;
  
      return $self;
  }
  
  sub _new {
      my $class = shift;
  
      return Class::MOP::Class->initialize($class)->new_object(@_)
          if $class ne __PACKAGE__;
  
      my $params = @_ == 1 ? $_[0] : {@_};
  
      return bless {
          # inherited from Class::MOP::Method
          body                 => $params->{body},
          associated_metaclass => $params->{associated_metaclass},
          package_name         => $params->{package_name},
          name                 => $params->{name},
          original_method      => $params->{original_method},
  
          # inherit from Class::MOP::Generated
          is_inline            => $params->{is_inline} || 0,
          definition_context   => $params->{definition_context},
  
          # defined in this class
          attribute            => $params->{attribute},
          accessor_type        => $params->{accessor_type},
      } => $class;
  }
  
  ## accessors
  
  sub associated_attribute { (shift)->{'attribute'}     }
  sub accessor_type        { (shift)->{'accessor_type'} }
  
  ## factory
  
  sub _initialize_body {
      my $self = shift;
  
      my $method_name = join "_" => (
          '_generate',
          $self->accessor_type,
          'method',
          ($self->is_inline ? 'inline' : ())
      );
  
      $self->{'body'} = $self->$method_name();
  }
  
  ## generators
  
  sub _generate_accessor_method {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      return sub {
          if (@_ >= 2) {
              $attr->set_value($_[0], $_[1]);
          }
          $attr->get_value($_[0]);
      };
  }
  
  sub _generate_accessor_method_inline {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      return try {
          $self->_compile_code([
              'sub {',
                  'if (@_ > 1) {',
                      $attr->_inline_set_value('$_[0]', '$_[1]'),
                  '}',
                  $attr->_inline_get_value('$_[0]'),
              '}',
          ]);
      }
      catch {
          confess "Could not generate inline accessor because : $_";
      };
  }
  
  sub _generate_reader_method {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      return sub {
          confess "Cannot assign a value to a read-only accessor"
              if @_ > 1;
          $attr->get_value($_[0]);
      };
  }
  
  sub _generate_reader_method_inline {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      return try {
          $self->_compile_code([
              'sub {',
                  'if (@_ > 1) {',
                      # XXX: this is a hack, but our error stuff is terrible
                      $self->_inline_throw_error(
                          '"Cannot assign a value to a read-only accessor"',
                          'data => \@_'
                      ) . ';',
                  '}',
                  $attr->_inline_get_value('$_[0]'),
              '}',
          ]);
      }
      catch {
          confess "Could not generate inline reader because : $_";
      };
  }
  
  sub _inline_throw_error {
      my $self = shift;
      return 'Carp::confess ' . $_[0];
  }
  
  sub _generate_writer_method {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      return sub {
          $attr->set_value($_[0], $_[1]);
      };
  }
  
  sub _generate_writer_method_inline {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      return try {
          $self->_compile_code([
              'sub {',
                  $attr->_inline_set_value('$_[0]', '$_[1]'),
              '}',
          ]);
      }
      catch {
          confess "Could not generate inline writer because : $_";
      };
  }
  
  sub _generate_predicate_method {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      return sub {
          $attr->has_value($_[0])
      };
  }
  
  sub _generate_predicate_method_inline {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      return try {
          $self->_compile_code([
              'sub {',
                  $attr->_inline_has_value('$_[0]'),
              '}',
          ]);
      }
      catch {
          confess "Could not generate inline predicate because : $_";
      };
  }
  
  sub _generate_clearer_method {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      return sub {
          $attr->clear_value($_[0])
      };
  }
  
  sub _generate_clearer_method_inline {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      return try {
          $self->_compile_code([
              'sub {',
                  $attr->_inline_clear_value('$_[0]'),
              '}',
          ]);
      }
      catch {
          confess "Could not generate inline clearer because : $_";
      };
  }
  
  1;
  
  # ABSTRACT: Method Meta Object for accessors
  
  
  
  =pod
  
  =head1 NAME
  
  Class::MOP::Method::Accessor - Method Meta Object for accessors
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 SYNOPSIS
  
      use Class::MOP::Method::Accessor;
  
      my $reader = Class::MOP::Method::Accessor->new(
          attribute     => $attribute,
          is_inline     => 1,
          accessor_type => 'reader',
      );
  
      $reader->body->execute($instance); # call the reader method
  
  =head1 DESCRIPTION
  
  This is a subclass of C<Class::MOP::Method> which is used by
  C<Class::MOP::Attribute> to generate accessor code. It handles
  generation of readers, writers, predicates and clearers. For each type
  of method, it can either create a subroutine reference, or actually
  inline code by generating a string and C<eval>'ing it.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Class::MOP::Method::Accessor->new(%options) >>
  
  This returns a new C<Class::MOP::Method::Accessor> based on the
  C<%options> provided.
  
  =over 4
  
  =item * attribute
  
  This is the C<Class::MOP::Attribute> for which accessors are being
  generated. This option is required.
  
  =item * accessor_type
  
  This is a string which should be one of "reader", "writer",
  "accessor", "predicate", or "clearer". This is the type of method
  being generated. This option is required.
  
  =item * is_inline
  
  This indicates whether or not the accessor should be inlined. This
  defaults to false.
  
  =item * name
  
  The method name (without a package name). This is required.
  
  =item * package_name
  
  The package name for the method. This is required.
  
  =back
  
  =item B<< $metamethod->accessor_type >>
  
  Returns the accessor type which was passed to C<new>.
  
  =item B<< $metamethod->is_inline >>
  
  Returns a boolean indicating whether or not the accessor is inlined.
  
  =item B<< $metamethod->associated_attribute >>
  
  This returns the L<Class::MOP::Attribute> object which was passed to
  C<new>.
  
  =item B<< $metamethod->body >>
  
  The method itself is I<generated> when the accessor object is
  constructed.
  
  =back
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
  
I686-LINUX_CLASS_MOP_METHOD_ACCESSOR

$fatpacked{"i686-linux/Class/MOP/Method/Constructor.pm"} = <<'I686-LINUX_CLASS_MOP_METHOD_CONSTRUCTOR';
  
  package Class::MOP::Method::Constructor;
  BEGIN {
    $Class::MOP::Method::Constructor::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Class::MOP::Method::Constructor::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Carp         'confess';
  use Scalar::Util 'blessed', 'weaken';
  use Try::Tiny;
  
  use base 'Class::MOP::Method::Inlined';
  
  sub new {
      my $class   = shift;
      my %options = @_;
  
      (blessed $options{metaclass} && $options{metaclass}->isa('Class::MOP::Class'))
          || confess "You must pass a metaclass instance if you want to inline"
              if $options{is_inline};
  
      ($options{package_name} && $options{name})
          || confess "You must supply the package_name and name parameters $Class::MOP::Method::UPGRADE_ERROR_TEXT";
  
      my $self = $class->_new(\%options);
  
      # we don't want this creating
      # a cycle in the code, if not
      # needed
      weaken($self->{'associated_metaclass'});
  
      $self->_initialize_body;
  
      return $self;
  }
  
  sub _new {
      my $class = shift;
  
      return Class::MOP::Class->initialize($class)->new_object(@_)
          if $class ne __PACKAGE__;
  
      my $params = @_ == 1 ? $_[0] : {@_};
  
      return bless {
          # inherited from Class::MOP::Method
          body                 => $params->{body},
          # associated_metaclass => $params->{associated_metaclass}, # overriden
          package_name         => $params->{package_name},
          name                 => $params->{name},
          original_method      => $params->{original_method},
  
          # inherited from Class::MOP::Generated
          is_inline            => $params->{is_inline} || 0,
          definition_context   => $params->{definition_context},
  
          # inherited from Class::MOP::Inlined
          _expected_method_class => $params->{_expected_method_class},
  
          # defined in this subclass
          options              => $params->{options} || {},
          associated_metaclass => $params->{metaclass},
      }, $class;
  }
  
  ## accessors
  
  sub options              { (shift)->{'options'}              }
  sub associated_metaclass { (shift)->{'associated_metaclass'} }
  
  ## method
  
  sub _initialize_body {
      my $self        = shift;
      my $method_name = '_generate_constructor_method';
  
      $method_name .= '_inline' if $self->is_inline;
  
      $self->{'body'} = $self->$method_name;
  }
  
  sub _eval_environment {
      my $self = shift;
      return $self->associated_metaclass->_eval_environment;
  }
  
  sub _generate_constructor_method {
      return sub { Class::MOP::Class->initialize(shift)->new_object(@_) }
  }
  
  sub _generate_constructor_method_inline {
      my $self = shift;
  
      my $meta = $self->associated_metaclass;
  
      my @source = (
          'sub {',
              $meta->_inline_new_object,
          '}',
      );
  
      warn join("\n", @source) if $self->options->{debug};
  
      my $code = try {
          $self->_compile_code(\@source);
      }
      catch {
          my $source = join("\n", @source);
          confess "Could not eval the constructor :\n\n$source\n\nbecause :\n\n$_";
      };
  
      return $code;
  }
  
  1;
  
  # ABSTRACT: Method Meta Object for constructors
  
  
  
  =pod
  
  =head1 NAME
  
  Class::MOP::Method::Constructor - Method Meta Object for constructors
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 SYNOPSIS
  
    use Class::MOP::Method::Constructor;
  
    my $constructor = Class::MOP::Method::Constructor->new(
        metaclass => $metaclass,
        options   => {
            debug => 1, # this is all for now
        },
    );
  
    # calling the constructor ...
    $constructor->body->execute($metaclass->name, %params);
  
  =head1 DESCRIPTION
  
  This is a subclass of C<Class::MOP::Method> which generates
  constructor methods.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Class::MOP::Method::Constructor->new(%options) >>
  
  This creates a new constructor object. It accepts a hash reference of
  options.
  
  =over 8
  
  =item * metaclass
  
  This should be a L<Class::MOP::Class> object. It is required.
  
  =item * name
  
  The method name (without a package name). This is required.
  
  =item * package_name
  
  The package name for the method. This is required.
  
  =item * is_inline
  
  This indicates whether or not the constructor should be inlined. This
  defaults to false.
  
  =back
  
  =item B<< $metamethod->is_inline >>
  
  Returns a boolean indicating whether or not the constructor is
  inlined.
  
  =item B<< $metamethod->associated_metaclass >>
  
  This returns the L<Class::MOP::Class> object for the method.
  
  =back
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
  
I686-LINUX_CLASS_MOP_METHOD_CONSTRUCTOR

$fatpacked{"i686-linux/Class/MOP/Method/Generated.pm"} = <<'I686-LINUX_CLASS_MOP_METHOD_GENERATED';
  
  package Class::MOP::Method::Generated;
  BEGIN {
    $Class::MOP::Method::Generated::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Class::MOP::Method::Generated::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Carp 'confess';
  use Eval::Closure;
  
  use base 'Class::MOP::Method';
  
  ## accessors
  
  sub new {
      confess __PACKAGE__ . " is an abstract base class, you must provide a constructor.";
  }
  
  sub _initialize_body {
      confess "No body to initialize, " . __PACKAGE__ . " is an abstract base class";
  }
  
  sub _generate_description {
      my ( $self, $context ) = @_;
      $context ||= $self->definition_context;
  
      my $desc = "generated method";
      my $origin = "unknown origin";
  
      if (defined $context) {
          if (defined $context->{description}) {
              $desc = $context->{description};
          }
  
          if (defined $context->{file} || defined $context->{line}) {
              $origin = "defined at "
                      . (defined $context->{file}
                          ? $context->{file} : "<unknown file>")
                      . " line "
                      . (defined $context->{line}
                          ? $context->{line} : "<unknown line>");
          }
      }
  
      return "$desc ($origin)";
  }
  
  sub _compile_code {
      my ( $self, @args ) = @_;
      unshift @args, 'source' if @args % 2;
      my %args = @args;
  
      my $context = delete $args{context};
      my $environment = $self->can('_eval_environment')
          ? $self->_eval_environment
          : {};
  
      return eval_closure(
          environment => $environment,
          description => $self->_generate_description($context),
          %args,
      );
  }
  
  1;
  
  # ABSTRACT: Abstract base class for generated methods
  
  
  
  =pod
  
  =head1 NAME
  
  Class::MOP::Method::Generated - Abstract base class for generated methods
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This is a C<Class::MOP::Method> subclass which is subclassed by
  C<Class::MOP::Method::Accessor> and
  C<Class::MOP::Method::Constructor>.
  
  It is not intended to be used directly.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
  
I686-LINUX_CLASS_MOP_METHOD_GENERATED

$fatpacked{"i686-linux/Class/MOP/Method/Inlined.pm"} = <<'I686-LINUX_CLASS_MOP_METHOD_INLINED';
  package Class::MOP::Method::Inlined;
  BEGIN {
    $Class::MOP::Method::Inlined::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Class::MOP::Method::Inlined::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Carp         'confess';
  use Scalar::Util 'blessed', 'weaken', 'looks_like_number', 'refaddr';
  
  use base 'Class::MOP::Method::Generated';
  
  sub _uninlined_body {
      my $self = shift;
  
      my $super_method
          = $self->associated_metaclass->find_next_method_by_name( $self->name )
          or return;
  
      if ( $super_method->isa(__PACKAGE__) ) {
          return $super_method->_uninlined_body;
      }
      else {
          return $super_method->body;
      }
  }
  
  sub can_be_inlined {
      my $self      = shift;
      my $metaclass = $self->associated_metaclass;
      my $class     = $metaclass->name;
  
      # If we don't find an inherited method, this is a rather weird
      # case where we have no method in the inheritance chain even
      # though we're expecting one to be there
      my $inherited_method
          = $metaclass->find_next_method_by_name( $self->name );
  
      if (   $inherited_method
          && $inherited_method->isa('Class::MOP::Method::Wrapped') ) {
          warn "Not inlining '"
              . $self->name
              . "' for $class since it "
              . "has method modifiers which would be lost if it were inlined\n";
  
          return 0;
      }
  
      my $expected_class = $self->_expected_method_class
          or return 1;
  
      # if we are shadowing a method we first verify that it is
      # compatible with the definition we are replacing it with
      my $expected_method = $expected_class->can( $self->name );
  
      if ( ! $expected_method ) {
          warn "Not inlining '"
              . $self->name
              . "' for $class since ${expected_class}::"
              . $self->name
              . " is not defined\n";
  
          return 0;
      }
  
      my $actual_method = $class->can( $self->name )
          or return 1;
  
      # the method is what we wanted (probably Moose::Object::new)
      return 1
          if refaddr($expected_method) == refaddr($actual_method);
  
      # otherwise we have to check that the actual method is an inlined
      # version of what we're expecting
      if ( $inherited_method->isa(__PACKAGE__) ) {
          if ( $inherited_method->_uninlined_body
               && refaddr( $inherited_method->_uninlined_body )
               == refaddr($expected_method) ) {
              return 1;
          }
      }
      elsif ( refaddr( $inherited_method->body )
              == refaddr($expected_method) ) {
          return 1;
      }
  
      my $warning
          = "Not inlining '"
          . $self->name
          . "' for $class since it is not"
          . " inheriting the default ${expected_class}::"
          . $self->name . "\n";
  
      if ( $self->isa("Class::MOP::Method::Constructor") ) {
  
          # FIXME kludge, refactor warning generation to a method
          $warning
              .= "If you are certain you don't need to inline your"
              . " constructor, specify inline_constructor => 0 in your"
              . " call to $class->meta->make_immutable\n";
      }
  
      warn $warning;
  
      return 0;
  }
  
  1;
  
  # ABSTRACT: Method base class for methods which have been inlined
  
  
  
  =pod
  
  =head1 NAME
  
  Class::MOP::Method::Inlined - Method base class for methods which have been inlined
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This is a L<Class::MOP::Method::Generated> subclass for methods which
  can be inlined.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< $metamethod->can_be_inlined >>
  
  This method returns true if the method in question can be inlined in
  the associated metaclass.
  
  If it cannot be inlined, it spits out a warning and returns false.
  
  =back
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
  
I686-LINUX_CLASS_MOP_METHOD_INLINED

$fatpacked{"i686-linux/Class/MOP/Method/Meta.pm"} = <<'I686-LINUX_CLASS_MOP_METHOD_META';
  
  package Class::MOP::Method::Meta;
  BEGIN {
    $Class::MOP::Method::Meta::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Class::MOP::Method::Meta::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Carp         'confess';
  use Scalar::Util 'blessed';
  
  use constant DEBUG_NO_META => $ENV{DEBUG_NO_META} ? 1 : 0;
  
  use base 'Class::MOP::Method';
  
  sub _is_caller_mop_internal {
      my $self = shift;
      my ($caller) = @_;
      return $caller =~ /^(?:Class::MOP|metaclass)(?:::|$)/;
  }
  
  sub _generate_meta_method {
      my $method_self = shift;
      my $metaclass   = shift;
      sub {
          # this will be compiled out if the env var wasn't set
          if (DEBUG_NO_META) {
              confess "'meta' method called by MOP internals"
                  # it's okay to call meta methods on metaclasses, since we
                  # explicitly ask for them
                  if !$_[0]->isa('Class::MOP::Object')
                  && !$_[0]->isa('Class::MOP::Mixin')
                  # it's okay if the test itself calls ->meta, we only care about
                  # if the mop internals call ->meta
                  && $method_self->_is_caller_mop_internal(scalar caller);
          }
          # we must re-initialize so that it
          # works as expected in subclasses,
          # since metaclass instances are
          # singletons, this is not really a
          # big deal anyway.
          $metaclass->initialize(blessed($_[0]) || $_[0])
      };
  }
  
  sub wrap {
      my ($class, @args) = @_;
  
      unshift @args, 'body' if @args % 2 == 1;
      my %params = @args;
      confess "Overriding the body of meta methods is not allowed"
          if $params{body};
  
      my $metaclass_class = $params{associated_metaclass}->meta;
      $params{body} = $class->_generate_meta_method($metaclass_class);
      return $class->SUPER::wrap(%params);
  }
  
  sub _make_compatible_with {
      my $self = shift;
      my ($other) = @_;
  
      # XXX: this is pretty gross. the issue here is that CMOP::Method::Meta
      # objects are subclasses of CMOP::Method, but when we get to moose, they'll
      # need to be compatible with Moose::Meta::Method, which isn't possible. the
      # right solution here is to make ::Meta into a role that gets applied to
      # whatever the method_metaclass happens to be and get rid of
      # _meta_method_metaclass entirely, but that's not going to happen until
      # we ditch cmop and get roles into the bootstrapping, so. i'm not
      # maintaining the previous behavior of turning them into instances of the
      # new method_metaclass because that's equally broken, and at least this way
      # any issues will at least be detectable and potentially fixable. -doy
      return $self unless $other->_is_compatible_with($self->_real_ref_name);
  
      return $self->SUPER::_make_compatible_with(@_);
  }
  
  1;
  
  # ABSTRACT: Method Meta Object for C<meta> methods
  
  
  
  =pod
  
  =head1 NAME
  
  Class::MOP::Method::Meta - Method Meta Object for C<meta> methods
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This is a L<Class::MOP::Method> subclass which represents C<meta>
  methods installed into classes by Class::MOP.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Class::MOP::Method::Wrapped->wrap($metamethod, %options) >>
  
  This is the constructor. It accepts a L<Class::MOP::Method> object and
  a hash of options. The options accepted are identical to the ones
  accepted by L<Class::MOP::Method>, except that C<body> cannot be passed
  (it will be generated automatically).
  
  =back
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
  
I686-LINUX_CLASS_MOP_METHOD_META

$fatpacked{"i686-linux/Class/MOP/Method/Wrapped.pm"} = <<'I686-LINUX_CLASS_MOP_METHOD_WRAPPED';
  
  package Class::MOP::Method::Wrapped;
  BEGIN {
    $Class::MOP::Method::Wrapped::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Class::MOP::Method::Wrapped::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Carp         'confess';
  use Scalar::Util 'blessed';
  
  use base 'Class::MOP::Method';
  
  # NOTE:
  # this ugly beast is the result of trying
  # to micro optimize this as much as possible
  # while not completely loosing maintainability.
  # At this point it's "fast enough", after all
  # you can't get something for nothing :)
  my $_build_wrapped_method = sub {
      my $modifier_table = shift;
      my ($before, $after, $around) = (
          $modifier_table->{before},
          $modifier_table->{after},
          $modifier_table->{around},
      );
      if (@$before && @$after) {
          $modifier_table->{cache} = sub {
              for my $c (@$before) { $c->(@_) };
              my @rval;
              ((defined wantarray) ?
                  ((wantarray) ?
                      (@rval = $around->{cache}->(@_))
                      :
                      ($rval[0] = $around->{cache}->(@_)))
                  :
                  $around->{cache}->(@_));
              for my $c (@$after) { $c->(@_) };
              return unless defined wantarray;
              return wantarray ? @rval : $rval[0];
          }
      }
      elsif (@$before && !@$after) {
          $modifier_table->{cache} = sub {
              for my $c (@$before) { $c->(@_) };
              return $around->{cache}->(@_);
          }
      }
      elsif (@$after && !@$before) {
          $modifier_table->{cache} = sub {
              my @rval;
              ((defined wantarray) ?
                  ((wantarray) ?
                      (@rval = $around->{cache}->(@_))
                      :
                      ($rval[0] = $around->{cache}->(@_)))
                  :
                  $around->{cache}->(@_));
              for my $c (@$after) { $c->(@_) };
              return unless defined wantarray;
              return wantarray ? @rval : $rval[0];
          }
      }
      else {
          $modifier_table->{cache} = $around->{cache};
      }
  };
  
  sub wrap {
      my ( $class, $code, %params ) = @_;
  
      (blessed($code) && $code->isa('Class::MOP::Method'))
          || confess "Can only wrap blessed CODE";
  
      my $modifier_table = {
          cache  => undef,
          orig   => $code->body,
          before => [],
          after  => [],
          around => {
              cache   => $code->body,
              methods => [],
          },
      };
      $_build_wrapped_method->($modifier_table);
      return $class->SUPER::wrap(
          sub { $modifier_table->{cache}->(@_) },
          # get these from the original
          # unless explicitly overriden
          package_name   => $params{package_name} || $code->package_name,
          name           => $params{name}         || $code->name,
          original_method => $code,
  
          modifier_table => $modifier_table,
      );
  }
  
  sub _new {
      my $class = shift;
      return Class::MOP::Class->initialize($class)->new_object(@_)
          if $class ne __PACKAGE__;
  
      my $params = @_ == 1 ? $_[0] : {@_};
  
      return bless {
          # inherited from Class::MOP::Method
          'body'                 => $params->{body},
          'associated_metaclass' => $params->{associated_metaclass},
          'package_name'         => $params->{package_name},
          'name'                 => $params->{name},
          'original_method'      => $params->{original_method},
  
          # defined in this class
          'modifier_table'       => $params->{modifier_table}
      } => $class;
  }
  
  sub get_original_method {
      my $code = shift;
      $code->original_method;
  }
  
  sub add_before_modifier {
      my $code     = shift;
      my $modifier = shift;
      unshift @{$code->{'modifier_table'}->{before}} => $modifier;
      $_build_wrapped_method->($code->{'modifier_table'});
  }
  
  sub before_modifiers {
      my $code = shift;
      return @{$code->{'modifier_table'}->{before}};
  }
  
  sub add_after_modifier {
      my $code     = shift;
      my $modifier = shift;
      push @{$code->{'modifier_table'}->{after}} => $modifier;
      $_build_wrapped_method->($code->{'modifier_table'});
  }
  
  sub after_modifiers {
      my $code = shift;
      return @{$code->{'modifier_table'}->{after}};
  }
  
  {
      # NOTE:
      # this is another possible candidate for
      # optimization as well. There is an overhead
      # associated with the currying that, if
      # eliminated might make around modifiers
      # more manageable.
      my $compile_around_method = sub {{
          my $f1 = pop;
          return $f1 unless @_;
          my $f2 = pop;
          push @_, sub { $f2->( $f1, @_ ) };
          redo;
      }};
  
      sub add_around_modifier {
          my $code     = shift;
          my $modifier = shift;
          unshift @{$code->{'modifier_table'}->{around}->{methods}} => $modifier;
          $code->{'modifier_table'}->{around}->{cache} = $compile_around_method->(
              @{$code->{'modifier_table'}->{around}->{methods}},
              $code->{'modifier_table'}->{orig}
          );
          $_build_wrapped_method->($code->{'modifier_table'});
      }
  }
  
  sub around_modifiers {
      my $code = shift;
      return @{$code->{'modifier_table'}->{around}->{methods}};
  }
  
  sub _make_compatible_with {
      my $self = shift;
      my ($other) = @_;
  
      # XXX: this is pretty gross. the issue here is that CMOP::Method::Wrapped
      # objects are subclasses of CMOP::Method, but when we get to moose, they'll
      # need to be compatible with Moose::Meta::Method, which isn't possible. the
      # right solution here is to make ::Wrapped into a role that gets applied to
      # whatever the method_metaclass happens to be and get rid of
      # wrapped_method_metaclass entirely, but that's not going to happen until
      # we ditch cmop and get roles into the bootstrapping, so. i'm not
      # maintaining the previous behavior of turning them into instances of the
      # new method_metaclass because that's equally broken, and at least this way
      # any issues will at least be detectable and potentially fixable. -doy
      return $self unless $other->_is_compatible_with($self->_real_ref_name);
  
      return $self->SUPER::_make_compatible_with(@_);
  }
  
  1;
  
  # ABSTRACT: Method Meta Object for methods with before/after/around modifiers
  
  
  
  =pod
  
  =head1 NAME
  
  Class::MOP::Method::Wrapped - Method Meta Object for methods with before/after/around modifiers
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This is a L<Class::MOP::Method> subclass which implements before,
  after, and around method modifiers.
  
  =head1 METHODS
  
  =head2 Construction
  
  =over 4
  
  =item B<< Class::MOP::Method::Wrapped->wrap($metamethod, %options) >>
  
  This is the constructor. It accepts a L<Class::MOP::Method> object and
  a hash of options.
  
  The options are:
  
  =over 8
  
  =item * name
  
  The method name (without a package name). This will be taken from the
  provided L<Class::MOP::Method> object if it is not provided.
  
  =item * package_name
  
  The package name for the method. This will be taken from the provided
  L<Class::MOP::Method> object if it is not provided.
  
  =item * associated_metaclass
  
  An optional L<Class::MOP::Class> object. This is the metaclass for the
  method's class.
  
  =back
  
  =item B<< $metamethod->get_original_method >>
  
  This returns the L<Class::MOP::Method> object that was passed to the
  constructor.
  
  =item B<< $metamethod->add_before_modifier($code) >>
  
  =item B<< $metamethod->add_after_modifier($code) >>
  
  =item B<< $metamethod->add_around_modifier($code) >>
  
  These methods all take a subroutine reference and apply it as a
  modifier to the original method.
  
  =item B<< $metamethod->before_modifiers >>
  
  =item B<< $metamethod->after_modifiers >>
  
  =item B<< $metamethod->around_modifiers >>
  
  These methods all return a list of subroutine references which are
  acting as the specified type of modifier.
  
  =back
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
  
I686-LINUX_CLASS_MOP_METHOD_WRAPPED

$fatpacked{"i686-linux/Class/MOP/MiniTrait.pm"} = <<'I686-LINUX_CLASS_MOP_MINITRAIT';
  package Class::MOP::MiniTrait;
  BEGIN {
    $Class::MOP::MiniTrait::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Class::MOP::MiniTrait::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Class::Load qw(load_class);
  
  sub apply {
      my ( $to_class, $trait ) = @_;
  
      for ( grep { !ref } $to_class, $trait ) {
          load_class($_);
          $_ = Class::MOP::Class->initialize($_);
      }
  
      for my $meth ( grep { $_->package_name ne 'UNIVERSAL' } $trait->get_all_methods ) {
          my $meth_name = $meth->name;
  
          if ( $to_class->find_method_by_name($meth_name) ) {
              $to_class->add_around_method_modifier( $meth_name, $meth->body );
          }
          else {
              $to_class->add_method( $meth_name, $meth->clone );
          }
      }
  }
  
  # We can't load this with use, since it may be loaded and used from Class::MOP
  # (via CMOP::Class, etc). However, if for some reason this module is loaded
  # _without_ first loading Class::MOP we need to require Class::MOP so we can
  # use it and CMOP::Class.
  require Class::MOP;
  
  1;
  
  # ABSTRACT: Extremely limited trait application
  
  
  
  =pod
  
  =head1 NAME
  
  Class::MOP::MiniTrait - Extremely limited trait application
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This package provides a single function, C<apply>, which does a half-assed job
  of applying a trait to a class. It exists solely for use inside Class::MOP and
  L<Moose> core classes.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
  
I686-LINUX_CLASS_MOP_MINITRAIT

$fatpacked{"i686-linux/Class/MOP/Mixin.pm"} = <<'I686-LINUX_CLASS_MOP_MIXIN';
  package Class::MOP::Mixin;
  BEGIN {
    $Class::MOP::Mixin::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Class::MOP::Mixin::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Scalar::Util 'blessed';
  
  sub meta {
      require Class::MOP::Class;
      Class::MOP::Class->initialize( blessed( $_[0] ) || $_[0] );
  }
  
  1;
  
  # ABSTRACT: Base class for mixin classes
  
  
  
  =pod
  
  =head1 NAME
  
  Class::MOP::Mixin - Base class for mixin classes
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This class provides a single method shared by all mixins
  
  =head1 METHODS
  
  This class provides a few methods which are useful in all metaclasses.
  
  =over 4
  
  =item B<< Class::MOP::Mixin->meta >>
  
  This returns a L<Class::MOP::Class> object for the mixin class.
  
  =back
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_CLASS_MOP_MIXIN

$fatpacked{"i686-linux/Class/MOP/Mixin/AttributeCore.pm"} = <<'I686-LINUX_CLASS_MOP_MIXIN_ATTRIBUTECORE';
  package Class::MOP::Mixin::AttributeCore;
  BEGIN {
    $Class::MOP::Mixin::AttributeCore::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Class::MOP::Mixin::AttributeCore::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Scalar::Util 'blessed';
  
  use base 'Class::MOP::Mixin';
  
  sub has_accessor        { defined $_[0]->{'accessor'} }
  sub has_reader          { defined $_[0]->{'reader'} }
  sub has_writer          { defined $_[0]->{'writer'} }
  sub has_predicate       { defined $_[0]->{'predicate'} }
  sub has_clearer         { defined $_[0]->{'clearer'} }
  sub has_builder         { defined $_[0]->{'builder'} }
  sub has_init_arg        { defined $_[0]->{'init_arg'} }
  sub has_default         { exists  $_[0]->{'default'} }
  sub has_initializer     { defined $_[0]->{'initializer'} }
  sub has_insertion_order { defined $_[0]->{'insertion_order'} }
  
  sub _set_insertion_order { $_[0]->{'insertion_order'} = $_[1] }
  
  sub has_read_method  { $_[0]->has_reader || $_[0]->has_accessor }
  sub has_write_method { $_[0]->has_writer || $_[0]->has_accessor }
  
  sub is_default_a_coderef {
      # Uber hack because it is called from CMOP::Attribute constructor as
      # $class->is_default_a_coderef(\%options)
      my ($value) = ref $_[0] ? $_[0]->{'default'} : $_[1]->{'default'};
  
      return unless ref($value);
  
      return ref($value) eq 'CODE'
          || ( blessed($value) && $value->isa('Class::MOP::Method') );
  }
  
  sub default {
      my ( $self, $instance ) = @_;
      if ( defined $instance && $self->is_default_a_coderef ) {
          # if the default is a CODE ref, then we pass in the instance and
          # default can return a value based on that instance. Somewhat crude,
          # but works.
          return $self->{'default'}->($instance);
      }
      $self->{'default'};
  }
  
  1;
  
  # ABSTRACT: Core attributes shared by attribute metaclasses
  
  
  
  =pod
  
  =head1 NAME
  
  Class::MOP::Mixin::AttributeCore - Core attributes shared by attribute metaclasses
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This class implements the core attributes (aka properties) shared by all
  attributes. See the L<Class::MOP::Attribute> documentation for API details.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_CLASS_MOP_MIXIN_ATTRIBUTECORE

$fatpacked{"i686-linux/Class/MOP/Mixin/HasAttributes.pm"} = <<'I686-LINUX_CLASS_MOP_MIXIN_HASATTRIBUTES';
  package Class::MOP::Mixin::HasAttributes;
  BEGIN {
    $Class::MOP::Mixin::HasAttributes::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Class::MOP::Mixin::HasAttributes::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Carp         'confess';
  use Scalar::Util 'blessed';
  
  use base 'Class::MOP::Mixin';
  
  sub add_attribute {
      my $self = shift;
  
      my $attribute
          = blessed( $_[0] ) ? $_[0] : $self->attribute_metaclass->new(@_);
  
      ( $attribute->isa('Class::MOP::Mixin::AttributeCore') )
          || confess
          "Your attribute must be an instance of Class::MOP::Mixin::AttributeCore (or a subclass)";
  
      $self->_attach_attribute($attribute);
  
      my $attr_name = $attribute->name;
  
      $self->remove_attribute($attr_name)
          if $self->has_attribute($attr_name);
  
      my $order = ( scalar keys %{ $self->_attribute_map } );
      $attribute->_set_insertion_order($order);
  
      $self->_attribute_map->{$attr_name} = $attribute;
  
      # This method is called to allow for installing accessors. Ideally, we'd
      # use method overriding, but then the subclass would be responsible for
      # making the attribute, which would end up with lots of code
      # duplication. Even more ideally, we'd use augment/inner, but this is
      # Class::MOP!
      $self->_post_add_attribute($attribute)
          if $self->can('_post_add_attribute');
  
      return $attribute;
  }
  
  sub has_attribute {
      my ( $self, $attribute_name ) = @_;
  
      ( defined $attribute_name )
          || confess "You must define an attribute name";
  
      exists $self->_attribute_map->{$attribute_name};
  }
  
  sub get_attribute {
      my ( $self, $attribute_name ) = @_;
  
      ( defined $attribute_name )
          || confess "You must define an attribute name";
  
      return $self->_attribute_map->{$attribute_name};
  }
  
  sub remove_attribute {
      my ( $self, $attribute_name ) = @_;
  
      ( defined $attribute_name )
          || confess "You must define an attribute name";
  
      my $removed_attribute = $self->_attribute_map->{$attribute_name};
      return unless defined $removed_attribute;
  
      delete $self->_attribute_map->{$attribute_name};
  
      return $removed_attribute;
  }
  
  sub get_attribute_list {
      my $self = shift;
      keys %{ $self->_attribute_map };
  }
  
  sub _restore_metaattributes_from {
      my $self = shift;
      my ($old_meta) = @_;
  
      for my $attr (sort { $a->insertion_order <=> $b->insertion_order }
                         map { $old_meta->get_attribute($_) }
                             $old_meta->get_attribute_list) {
          $attr->_make_compatible_with($self->attribute_metaclass);
          $self->add_attribute($attr);
      }
  }
  
  1;
  
  # ABSTRACT: Methods for metaclasses which have attributes
  
  
  
  =pod
  
  =head1 NAME
  
  Class::MOP::Mixin::HasAttributes - Methods for metaclasses which have attributes
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This class implements methods for metaclasses which have attributes
  (L<Class::MOP::Class> and L<Moose::Meta::Role>). See L<Class::MOP::Class> for
  API details.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_CLASS_MOP_MIXIN_HASATTRIBUTES

$fatpacked{"i686-linux/Class/MOP/Mixin/HasMethods.pm"} = <<'I686-LINUX_CLASS_MOP_MIXIN_HASMETHODS';
  package Class::MOP::Mixin::HasMethods;
  BEGIN {
    $Class::MOP::Mixin::HasMethods::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Class::MOP::Mixin::HasMethods::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Class::MOP::Method::Meta;
  
  use Scalar::Util 'blessed';
  use Carp         'confess';
  use Sub::Name    'subname';
  
  use base 'Class::MOP::Mixin';
  
  sub _meta_method_class { 'Class::MOP::Method::Meta' }
  
  sub _add_meta_method {
      my $self = shift;
      my ($name) = @_;
      my $existing_method = $self->can('find_method_by_name')
                                ? $self->find_method_by_name($name)
                                : $self->get_method($name);
      return if $existing_method
             && $existing_method->isa($self->_meta_method_class);
      $self->add_method(
          $name => $self->_meta_method_class->wrap(
              name                 => $name,
              package_name         => $self->name,
              associated_metaclass => $self,
          )
      );
  }
  
  sub wrap_method_body {
      my ( $self, %args ) = @_;
  
      ( 'CODE' eq ref $args{body} )
          || confess "Your code block must be a CODE reference";
  
      $self->method_metaclass->wrap(
          package_name => $self->name,
          %args,
      );
  }
  
  sub add_method {
      my ( $self, $method_name, $method ) = @_;
      ( defined $method_name && length $method_name )
          || confess "You must define a method name";
  
      my $package_name = $self->name;
  
      my $body;
      if ( blessed($method) ) {
          $body = $method->body;
          if ( $method->package_name ne $package_name ) {
              $method = $method->clone(
                  package_name => $package_name,
                  name         => $method_name,
              );
          }
  
          $method->attach_to_class($self);
      }
      else {
          # If a raw code reference is supplied, its method object is not created.
          # The method object won't be created until required.
          $body = $method;
      }
  
      $self->_method_map->{$method_name} = $method;
  
      my ($current_package, $current_name) = Class::MOP::get_code_info($body);
  
      subname($package_name . '::' . $method_name, $body)
          unless defined $current_name && $current_name !~ /^__ANON__/;
  
      $self->add_package_symbol("&$method_name", $body);
  
      # we added the method to the method map too, so it's still valid
      $self->update_package_cache_flag;
  }
  
  sub _code_is_mine {
      my ( $self, $code ) = @_;
  
      my ( $code_package, $code_name ) = Class::MOP::get_code_info($code);
  
      return ( $code_package && $code_package eq $self->name )
          || ( $code_package eq 'constant' && $code_name eq '__ANON__' );
  }
  
  sub has_method {
      my ( $self, $method_name ) = @_;
  
      ( defined $method_name && length $method_name )
          || confess "You must define a method name";
  
      my $method = $self->_get_maybe_raw_method($method_name)
          or return;
  
      return defined($self->_method_map->{$method_name} = $method);
  }
  
  sub get_method {
      my ( $self, $method_name ) = @_;
  
      ( defined $method_name && length $method_name )
          || confess "You must define a method name";
  
      my $method = $self->_get_maybe_raw_method($method_name)
          or return;
  
      return $method if blessed $method;
  
      return $self->_method_map->{$method_name} = $self->wrap_method_body(
          body                 => $method,
          name                 => $method_name,
          associated_metaclass => $self,
      );
  }
  
  sub _get_maybe_raw_method {
      my ( $self, $method_name ) = @_;
  
      my $map_entry = $self->_method_map->{$method_name};
      return $map_entry if defined $map_entry;
  
      my $code = $self->get_package_symbol("&$method_name");
  
      return unless $code && $self->_code_is_mine($code);
  
      return $code;
  }
  
  sub remove_method {
      my ( $self, $method_name ) = @_;
  
      ( defined $method_name && length $method_name )
          || confess "You must define a method name";
  
      my $removed_method = delete $self->_method_map->{$method_name};
  
      $self->remove_package_symbol("&$method_name");
  
      $removed_method->detach_from_class
          if blessed($removed_method);
  
      # still valid, since we just removed the method from the map
      $self->update_package_cache_flag;
  
      return $removed_method;
  }
  
  sub get_method_list {
      my $self = shift;
  
      return keys %{ $self->_full_method_map };
  }
  
  sub _get_local_methods {
      my $self = shift;
  
      return values %{ $self->_full_method_map };
  }
  
  sub _restore_metamethods_from {
      my $self = shift;
      my ($old_meta) = @_;
  
      for my $method ($old_meta->_get_local_methods) {
          $method->_make_compatible_with($self->method_metaclass);
          $self->add_method($method->name => $method);
      }
  }
  
  sub reset_package_cache_flag  { (shift)->{'_package_cache_flag'} = undef }
  sub update_package_cache_flag {
      my $self = shift;
      # NOTE:
      # we can manually update the cache number
      # since we are actually adding the method
      # to our cache as well. This avoids us
      # having to regenerate the method_map.
      # - SL
      $self->{'_package_cache_flag'} = Class::MOP::check_package_cache_flag($self->name);
  }
  
  sub _full_method_map {
      my $self = shift;
  
      my $pkg_gen = Class::MOP::check_package_cache_flag($self->name);
  
      if (($self->{_package_cache_flag_full} || -1) != $pkg_gen) {
          # forcibly reify all method map entries
          $self->get_method($_)
              for $self->list_all_package_symbols('CODE');
          $self->{_package_cache_flag_full} = $pkg_gen;
      }
  
      return $self->_method_map;
  }
  
  1;
  
  # ABSTRACT: Methods for metaclasses which have methods
  
  
  
  =pod
  
  =head1 NAME
  
  Class::MOP::Mixin::HasMethods - Methods for metaclasses which have methods
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This class implements methods for metaclasses which have methods
  (L<Class::MOP::Package> and L<Moose::Meta::Role>). See L<Class::MOP::Package>
  for API details.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_CLASS_MOP_MIXIN_HASMETHODS

$fatpacked{"i686-linux/Class/MOP/Module.pm"} = <<'I686-LINUX_CLASS_MOP_MODULE';
  
  package Class::MOP::Module;
  BEGIN {
    $Class::MOP::Module::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Class::MOP::Module::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Carp         'confess';
  use Scalar::Util 'blessed';
  
  use base 'Class::MOP::Package';
  
  sub _new {
      my $class = shift;
      return Class::MOP::Class->initialize($class)->new_object(@_)
          if $class ne __PACKAGE__;
  
      my $params = @_ == 1 ? $_[0] : {@_};
      return bless {
          # Need to quote package to avoid a problem with PPI mis-parsing this
          # as a package statement.
  
          # from Class::MOP::Package
          'package' => $params->{package},
          namespace => \undef,
  
          # attributes
          version   => \undef,
          authority => \undef
      } => $class;
  }
  
  sub version {
      my $self = shift;
      ${$self->get_or_add_package_symbol('$VERSION')};
  }
  
  sub authority {
      my $self = shift;
      ${$self->get_or_add_package_symbol('$AUTHORITY')};
  }
  
  sub identifier {
      my $self = shift;
      join '-' => (
          $self->name,
          ($self->version   || ()),
          ($self->authority || ()),
      );
  }
  
  sub create {
      my $class = shift;
      my @args = @_;
  
      unshift @args, 'package' if @args % 2 == 1;
      my %options = @args;
  
      my $package   = delete $options{package};
      my $version   = delete $options{version};
      my $authority = delete $options{authority};
  
      my $meta = $class->SUPER::create($package => %options);
  
      $meta->_instantiate_module($version, $authority);
  
      return $meta;
  }
  
  sub _anon_package_prefix { 'Class::MOP::Module::__ANON__::SERIAL::' }
  sub _anon_cache_key      { confess "Modules are not cacheable" }
  
  
  sub _instantiate_module {
      my($self, $version, $authority) = @_;
      my $package_name = $self->name;
  
      $self->add_package_symbol('$VERSION' => $version)
          if defined $version;
      $self->add_package_symbol('$AUTHORITY' => $authority)
          if defined $authority;
  
      return;
  }
  
  1;
  
  # ABSTRACT: Module Meta Object
  
  
  
  =pod
  
  =head1 NAME
  
  Class::MOP::Module - Module Meta Object
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  A module is essentially a L<Class::MOP::Package> with metadata, in our
  case the version and authority.
  
  =head1 INHERITANCE
  
  B<Class::MOP::Module> is a subclass of L<Class::MOP::Package>.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Class::MOP::Module->create($package, %options) >>
  
  Overrides C<create> from L<Class::MOP::Package> to provide these additional
  options:
  
  =over 4
  
  =item C<version>
  
  A version number, to be installed in the C<$VERSION> package global variable.
  
  =item C<authority>
  
  An authority, to be installed in the C<$AUTHORITY> package global variable.
  
  =back
  
  =item B<< $metamodule->version >>
  
  This is a read-only attribute which returns the C<$VERSION> of the
  package, if one exists.
  
  =item B<< $metamodule->authority >>
  
  This is a read-only attribute which returns the C<$AUTHORITY> of the
  package, if one exists.
  
  =item B<< $metamodule->identifier >>
  
  This constructs a string which combines the name, version and
  authority.
  
  =item B<< Class::MOP::Module->meta >>
  
  This will return a L<Class::MOP::Class> instance for this class.
  
  =back
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_CLASS_MOP_MODULE

$fatpacked{"i686-linux/Class/MOP/Object.pm"} = <<'I686-LINUX_CLASS_MOP_OBJECT';
  
  package Class::MOP::Object;
  BEGIN {
    $Class::MOP::Object::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Class::MOP::Object::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Carp qw(confess);
  use Scalar::Util 'blessed';
  
  # introspection
  
  sub meta {
      require Class::MOP::Class;
      Class::MOP::Class->initialize(blessed($_[0]) || $_[0]);
  }
  
  sub _new {
      Class::MOP::class_of(shift)->new_object(@_);
  }
  
  # RANT:
  # Cmon, how many times have you written
  # the following code while debugging:
  #
  #  use Data::Dumper;
  #  warn Dumper $obj;
  #
  # It can get seriously annoying, so why
  # not just do this ...
  sub dump {
      my $self = shift;
      require Data::Dumper;
      local $Data::Dumper::Maxdepth = shift || 1;
      Data::Dumper::Dumper $self;
  }
  
  sub _real_ref_name {
      my $self = shift;
      return blessed($self);
  }
  
  sub _is_compatible_with {
      my $self = shift;
      my ($other_name) = @_;
  
      return $self->isa($other_name);
  }
  
  sub _can_be_made_compatible_with {
      my $self = shift;
      return !$self->_is_compatible_with(@_)
          && defined($self->_get_compatible_metaclass(@_));
  }
  
  sub _make_compatible_with {
      my $self = shift;
      my ($other_name) = @_;
  
      my $new_metaclass = $self->_get_compatible_metaclass($other_name);
  
      confess "Can't make $self compatible with metaclass $other_name"
          unless defined $new_metaclass;
  
      # can't use rebless_instance here, because it might not be an actual
      # subclass in the case of, e.g. moose role reconciliation
      $new_metaclass->meta->_force_rebless_instance($self)
          if blessed($self) ne $new_metaclass;
  
      return $self;
  }
  
  sub _get_compatible_metaclass {
      my $self = shift;
      my ($other_name) = @_;
  
      return $self->_get_compatible_metaclass_by_subclassing($other_name);
  }
  
  sub _get_compatible_metaclass_by_subclassing {
      my $self = shift;
      my ($other_name) = @_;
      my $meta_name = blessed($self) ? $self->_real_ref_name : $self;
  
      if ($meta_name->isa($other_name)) {
          return $meta_name;
      }
      elsif ($other_name->isa($meta_name)) {
          return $other_name;
      }
  
      return;
  }
  
  1;
  
  # ABSTRACT: Base class for metaclasses
  
  
  
  =pod
  
  =head1 NAME
  
  Class::MOP::Object - Base class for metaclasses
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This class is a very minimal base class for metaclasses.
  
  =head1 METHODS
  
  This class provides a few methods which are useful in all metaclasses.
  
  =over 4
  
  =item B<< Class::MOP::???->meta >>
  
  This returns a L<Class::MOP::Class> object.
  
  =item B<< $metaobject->dump($max_depth) >>
  
  This method uses L<Data::Dumper> to dump the object. You can pass an
  optional maximum depth, which will set C<$Data::Dumper::Maxdepth>. The
  default maximum depth is 1.
  
  =back
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_CLASS_MOP_OBJECT

$fatpacked{"i686-linux/Class/MOP/Package.pm"} = <<'I686-LINUX_CLASS_MOP_PACKAGE';
  
  package Class::MOP::Package;
  BEGIN {
    $Class::MOP::Package::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Class::MOP::Package::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Scalar::Util 'blessed', 'reftype', 'weaken';
  use Carp         'confess';
  use Devel::GlobalDestruction 'in_global_destruction';
  use Package::Stash;
  
  use base 'Class::MOP::Object';
  
  # creation ...
  
  sub initialize {
      my ( $class, @args ) = @_;
  
      unshift @args, "package" if @args % 2;
  
      my %options = @args;
      my $package_name = delete $options{package};
  
  
      # we hand-construct the class until we can bootstrap it
      if ( my $meta = Class::MOP::get_metaclass_by_name($package_name) ) {
          return $meta;
      } else {
          my $meta = ( ref $class || $class )->_new({
              'package'   => $package_name,
              %options,
          });
          Class::MOP::store_metaclass_by_name($package_name, $meta);
  
          Class::MOP::weaken_metaclass($package_name) if $options{weaken};
  
  
          return $meta;
      }
  }
  
  sub reinitialize {
      my ( $class, @args ) = @_;
  
      unshift @args, "package" if @args % 2;
  
      my %options = @args;
      my $package_name = delete $options{package};
  
      (defined $package_name && $package_name
        && (!blessed $package_name || $package_name->isa('Class::MOP::Package')))
          || confess "You must pass a package name or an existing Class::MOP::Package instance";
  
      $package_name = $package_name->name
          if blessed $package_name;
  
      Class::MOP::remove_metaclass_by_name($package_name);
  
      $class->initialize($package_name, %options); # call with first arg form for compat
  }
  
  sub create {
      my $class = shift;
      my @args = @_;
  
      return $class->initialize(@args);
  }
  
  ## ANON packages
  
  {
      # NOTE:
      # this should be sufficient, if you have a
      # use case where it is not, write a test and
      # I will change it.
      my $ANON_SERIAL = 0;
  
      my %ANON_PACKAGE_CACHE;
  
      # NOTE:
      # we need a sufficiently annoying prefix
      # this should suffice for now, this is
      # used in a couple of places below, so
      # need to put it up here for now.
      sub _anon_package_prefix { 'Class::MOP::Package::__ANON__::SERIAL::' }
  
      sub is_anon {
          my $self = shift;
          no warnings 'uninitialized';
          my $prefix = $self->_anon_package_prefix;
          $self->name =~ /^\Q$prefix/;
      }
  
      sub create_anon {
          my ($class, %options) = @_;
  
          my $cache_ok = delete $options{cache};
          $options{weaken} = !$cache_ok unless exists $options{weaken};
  
          my $cache_key;
          if ($cache_ok) {
              $cache_key = $class->_anon_cache_key(%options);
              undef $cache_ok if !defined($cache_key);
          }
  
          if ($cache_ok) {
              if (defined $ANON_PACKAGE_CACHE{$cache_key}) {
                  return $ANON_PACKAGE_CACHE{$cache_key};
              }
          }
  
          my $package_name = $class->_anon_package_prefix . ++$ANON_SERIAL;
  
          my $meta = $class->create($package_name, %options);
  
          if ($cache_ok) {
              $ANON_PACKAGE_CACHE{$cache_key} = $meta;
              weaken($ANON_PACKAGE_CACHE{$cache_key});
          }
  
          return $meta;
      }
  
      sub _anon_cache_key { confess "Packages are not cacheable" }
  
      sub DESTROY {
          my $self = shift;
  
          return if in_global_destruction(); # it'll happen soon anyway and this just makes things more complicated
  
          $self->_free_anon
              if $self->is_anon;
      }
  
      sub _free_anon {
          my $self = shift;
          my $name = $self->name;
  
          # Moose does a weird thing where it replaces the metaclass for
          # class when fixing metaclass incompatibility. In that case,
          # we don't want to clean out the namespace now. We can detect
          # that because Moose will explicitly update the singleton
          # cache in Class::MOP using store_metaclass_by_name, which
          # means that the new metaclass will already exist in the cache
          # by this point.
          # The other options here are that $current_meta can be undef if
          # remove_metaclass_by_name is called explicitly (since the hash
          # entry is removed first, and then this destructor is called),
          # or that $current_meta can be the same as $self, which happens
          # when the metaclass goes out of scope (since the weak reference
          # in the metaclass cache won't be freed until after this
          # destructor runs).
          my $current_meta = Class::MOP::get_metaclass_by_name($name);
          return if defined($current_meta) && $current_meta ne $self;
  
          my ($first_fragments, $last_fragment) = ($name =~ /^(.*)::(.*)$/);
  
          no strict 'refs';
          @{$name . '::ISA'} = ();
          %{$name . '::'}    = ();
          delete ${$first_fragments . '::'}{$last_fragment . '::'};
  
          Class::MOP::remove_metaclass_by_name($name);
      }
  
  }
  
  sub _new {
      my $class = shift;
  
      return Class::MOP::Class->initialize($class)->new_object(@_)
          if $class ne __PACKAGE__;
  
      my $params = @_ == 1 ? $_[0] : {@_};
  
      return bless {
          # Need to quote package to avoid a problem with PPI mis-parsing this
          # as a package statement.
          'package' => $params->{package},
  
          # NOTE:
          # because of issues with the Perl API
          # to the typeglob in some versions, we
          # need to just always grab a new
          # reference to the hash in the accessor.
          # Ideally we could just store a ref and
          # it would Just Work, but oh well :\
  
          namespace => \undef,
  
      } => $class;
  }
  
  # Attributes
  
  # NOTE:
  # all these attribute readers will be bootstrapped
  # away in the Class::MOP bootstrap section
  
  sub _package_stash {
      $_[0]->{_package_stash} ||= Package::Stash->new($_[0]->name)
  }
  sub namespace {
      $_[0]->_package_stash->namespace
  }
  
  # Class attributes
  
  # ... these functions have to touch the symbol table itself,.. yuk
  
  sub add_package_symbol {
      my $self = shift;
      $self->_package_stash->add_symbol(@_);
  }
  
  sub remove_package_glob {
      my $self = shift;
      $self->_package_stash->remove_glob(@_);
  }
  
  # ... these functions deal with stuff on the namespace level
  
  sub has_package_symbol {
      my $self = shift;
      $self->_package_stash->has_symbol(@_);
  }
  
  sub get_package_symbol {
      my $self = shift;
      $self->_package_stash->get_symbol(@_);
  }
  
  sub get_or_add_package_symbol {
      my $self = shift;
      $self->_package_stash->get_or_add_symbol(@_);
  }
  
  sub remove_package_symbol {
      my $self = shift;
      $self->_package_stash->remove_symbol(@_);
  }
  
  sub list_all_package_symbols {
      my $self = shift;
      $self->_package_stash->list_all_symbols(@_);
  }
  
  sub get_all_package_symbols {
      my $self = shift;
      $self->_package_stash->get_all_symbols(@_);
  }
  
  1;
  
  # ABSTRACT: Package Meta Object
  
  
  
  =pod
  
  =head1 NAME
  
  Class::MOP::Package - Package Meta Object
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  The Package Protocol provides an abstraction of a Perl 5 package. A
  package is basically namespace, and this module provides methods for
  looking at and changing that namespace's symbol table.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Class::MOP::Package->initialize($package_name, %options) >>
  
  This method creates a new C<Class::MOP::Package> instance which
  represents specified package. If an existing metaclass object exists
  for the package, that will be returned instead. No options are valid at the
  package level.
  
  =item B<< Class::MOP::Package->reinitialize($package, %options) >>
  
  This method forcibly removes any existing metaclass for the package
  before calling C<initialize>. In contrast to C<initialize>, you may
  also pass an existing C<Class::MOP::Package> instance instead of just
  a package name as C<$package>.
  
  Do not call this unless you know what you are doing.
  
  =item B<< Class::MOP::Package->create($package, %options) >>
  
  Creates a new C<Class::MOP::Package> instance which represents the specified
  package, and also does some initialization of that package. Currently, this
  just does the same thing as C<initialize>, but is overridden in subclasses,
  such as C<Class::MOP::Class>.
  
  =item B<< Class::MOP::Package->create_anon(%options) >>
  
  Creates a new anonymous package. Valid keys for C<%options> are:
  
  =over 4
  
  =item C<weaken>
  
  If this is true (the default), the instance stored in C<Class::MOP>'s metaclass
  cache will be weakened, so that the anonymous package will be garbage collected
  when the returned instance goes out of scope.
  
  =back
  
  =item B<< $metapackage->is_anon >>
  
  Returns true if the package is an anonymous package.
  
  =item B<< $metapackage->name >>
  
  This is returns the package's name, as passed to the constructor.
  
  =item B<< $metapackage->namespace >>
  
  This returns a hash reference to the package's symbol table. The keys
  are symbol names and the values are typeglob references.
  
  =item B<< $metapackage->add_package_symbol($variable_name, $initial_value) >>
  
  This method accepts a variable name and an optional initial value. The
  C<$variable_name> must contain a leading sigil.
  
  This method creates the variable in the package's symbol table, and
  sets it to the initial value if one was provided.
  
  =item B<< $metapackage->get_package_symbol($variable_name) >>
  
  Given a variable name, this method returns the variable as a reference
  or undef if it does not exist. The C<$variable_name> must contain a
  leading sigil.
  
  =item B<< $metapackage->get_or_add_package_symbol($variable_name) >>
  
  Given a variable name, this method returns the variable as a reference.
  If it does not exist, a default value will be generated if possible. The
  C<$variable_name> must contain a leading sigil.
  
  =item B<< $metapackage->has_package_symbol($variable_name) >>
  
  Returns true if there is a package variable defined for
  C<$variable_name>. The C<$variable_name> must contain a leading sigil.
  
  =item B<< $metapackage->remove_package_symbol($variable_name) >>
  
  This will remove the package variable specified C<$variable_name>. The
  C<$variable_name> must contain a leading sigil.
  
  =item B<< $metapackage->remove_package_glob($glob_name) >>
  
  Given the name of a glob, this will remove that glob from the
  package's symbol table. Glob names do not include a sigil. Removing
  the glob removes all variables and subroutines with the specified
  name.
  
  =item B<< $metapackage->list_all_package_symbols($type_filter) >>
  
  This will list all the glob names associated with the current
  package. These names do not have leading sigils.
  
  You can provide an optional type filter, which should be one of
  'SCALAR', 'ARRAY', 'HASH', or 'CODE'.
  
  =item B<< $metapackage->get_all_package_symbols($type_filter) >>
  
  This works much like C<list_all_package_symbols>, but it returns a
  hash reference. The keys are glob names and the values are references
  to the value for that name.
  
  =item B<< Class::MOP::Package->meta >>
  
  This will return a L<Class::MOP::Class> instance for this class.
  
  =back
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_CLASS_MOP_PACKAGE

$fatpacked{"i686-linux/List/MoreUtils.pm"} = <<'I686-LINUX_LIST_MOREUTILS';
  package List::MoreUtils;
  
  use 5.00503;
  use strict;
  use Exporter   ();
  use DynaLoader ();
  
  use vars qw{ $VERSION @ISA @EXPORT_OK %EXPORT_TAGS };
  BEGIN {
      $VERSION   = '0.33';
      # $VERSION   = eval $VERSION;
      @ISA       = qw{ Exporter DynaLoader };
      @EXPORT_OK = qw{
          any all none notall true false
          firstidx first_index lastidx last_index
          insert_after insert_after_string
          apply indexes
          after after_incl before before_incl
          firstval first_value lastval last_value
          each_array each_arrayref
          pairwise natatime
          mesh zip uniq distinct
          minmax part
      };
      %EXPORT_TAGS = (
          all => \@EXPORT_OK,
      );
  
      # Load the XS at compile-time so that redefinition warnings will be
      # thrown correctly if the XS versions of part or indexes loaded
      eval {
          # PERL_DL_NONLAZY must be false, or any errors in loading will just
          # cause the perl code to be tested
          local $ENV{PERL_DL_NONLAZY} = 0 if $ENV{PERL_DL_NONLAZY};
  
          bootstrap List::MoreUtils $VERSION;
          1;
  
      } unless $ENV{LIST_MOREUTILS_PP};
  }
  
  eval <<'END_PERL' unless defined &any;
  
  # Use pure scalar boolean return values for compatibility with XS
  use constant YES => ! 0;
  use constant NO  => ! 1;
  
  sub any (&@) {
      my $f = shift;
      foreach ( @_ ) {
          return YES if $f->();
      }
      return NO;
  }
  
  sub all (&@) {
      my $f = shift;
      foreach ( @_ ) {
          return NO unless $f->();
      }
      return YES;
  }
  
  sub none (&@) {
      my $f = shift;
      foreach ( @_ ) {
          return NO if $f->();
      }
      return YES;
  }
  
  sub notall (&@) {
      my $f = shift;
      foreach ( @_ ) {
          return YES unless $f->();
      }
      return NO;
  }
  
  sub true (&@) {
      my $f     = shift;
      my $count = 0;
      foreach ( @_ ) {
          $count++ if $f->();
      }
      return $count;
  }
  
  sub false (&@) {
      my $f     = shift;
      my $count = 0;
      foreach ( @_ ) {
          $count++ unless $f->();
      }
      return $count;
  }
  
  sub firstidx (&@) {
      my $f = shift;
      foreach my $i ( 0 .. $#_ ) {
          local *_ = \$_[$i];
          return $i if $f->();
      }
      return -1;
  }
  
  sub lastidx (&@) {
      my $f = shift;
      foreach my $i ( reverse 0 .. $#_ ) {
          local *_ = \$_[$i];
          return $i if $f->();
      }
      return -1;
  }
  
  sub insert_after (&$\@) {
      my ($f, $val, $list) = @_;
      my $c = -1;
      local *_;
      foreach my $i ( 0 .. $#$list ) {
          $_ = $list->[$i];
          $c = $i, last if $f->();
      }
      @$list = (
          @{$list}[ 0 .. $c ],
          $val,
          @{$list}[ $c + 1 .. $#$list ],
      ) and return 1 if $c != -1;
      return 0;
  }
  
  sub insert_after_string ($$\@) {
      my ($string, $val, $list) = @_;
      my $c = -1;
      foreach my $i ( 0 .. $#$list ) {
          local $^W = 0;
          $c = $i, last if $string eq $list->[$i];
      }
      @$list = (
          @{$list}[ 0 .. $c ],
          $val,
          @{$list}[ $c + 1 .. $#$list ],
      ) and return 1 if $c != -1;
      return 0;
  }
  
  sub apply (&@) {
      my $action = shift;
      &$action foreach my @values = @_;
      wantarray ? @values : $values[-1];
  }
  
  sub after (&@) {
      my $test = shift;
      my $started;
      my $lag;
      grep $started ||= do {
          my $x = $lag;
          $lag = $test->();
          $x
      }, @_;
  }
  
  sub after_incl (&@) {
      my $test = shift;
      my $started;
      grep $started ||= $test->(), @_;
  }
  
  sub before (&@) {
      my $test = shift;
      my $more = 1;
      grep $more &&= ! $test->(), @_;
  }
  
  sub before_incl (&@) {
      my $test = shift;
      my $more = 1;
      my $lag  = 1;
      grep $more &&= do {
          my $x = $lag;
          $lag = ! $test->();
          $x
      }, @_;
  }
  
  sub indexes (&@) {
      my $test = shift;
      grep {
          local *_ = \$_[$_];
          $test->()
      } 0 .. $#_;
  }
  
  sub lastval (&@) {
      my $test = shift;
      my $ix;
      for ( $ix = $#_; $ix >= 0; $ix-- ) {
          local *_ = \$_[$ix];
          my $testval = $test->();
  
          # Simulate $_ as alias
          $_[$ix] = $_;
          return $_ if $testval;
      }
      return undef;
  }
  
  sub firstval (&@) {
      my $test = shift;
      foreach ( @_ ) {
          return $_ if $test->();
      }
      return undef;
  }
  
  sub pairwise (&\@\@) {
      my $op = shift;
  
      # Symbols for caller's input arrays
      use vars qw{ @A @B };
      local ( *A, *B ) = @_;
  
      # Localise $a, $b
      my ( $caller_a, $caller_b ) = do {
          my $pkg = caller();
          no strict 'refs';
          \*{$pkg.'::a'}, \*{$pkg.'::b'};
      };
  
      # Loop iteration limit
      my $limit = $#A > $#B? $#A : $#B;
  
      # This map expression is also the return value
      local( *$caller_a, *$caller_b );
      map {
          # Assign to $a, $b as refs to caller's array elements
          ( *$caller_a, *$caller_b ) = \( $A[$_], $B[$_] );
  
          # Perform the transformation
          $op->();
      }  0 .. $limit;
  }
  
  sub each_array (\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@) {
      return each_arrayref(@_);
  }
  
  sub each_arrayref {
      my @list  = @_; # The list of references to the arrays
      my $index = 0;  # Which one the caller will get next
      my $max   = 0;  # Number of elements in longest array
  
      # Get the length of the longest input array
      foreach ( @list ) {
          unless ( ref $_ eq 'ARRAY' ) {
              require Carp;
              Carp::croak("each_arrayref: argument is not an array reference\n");
          }
          $max = @$_ if @$_ > $max;
      }
  
      # Return the iterator as a closure wrt the above variables.
      return sub {
          if ( @_ ) {
              my $method = shift;
              unless ( $method eq 'index' ) {
                  require Carp;
                  Carp::croak("each_array: unknown argument '$method' passed to iterator.");
              }
  
              # Return current (last fetched) index
              return undef if $index == 0  ||  $index > $max;
              return $index - 1;
          }
  
          # No more elements to return
          return if $index >= $max;
          my $i = $index++;
  
          # Return ith elements
          return map $_->[$i], @list; 
      }
  }
  
  sub natatime ($@) {
      my $n    = shift;
      my @list = @_;
      return sub {
          return splice @list, 0, $n;
      }
  }
  
  sub mesh (\@\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@) {
      my $max = -1;
      $max < $#$_ && ( $max = $#$_ ) foreach @_;
      map {
          my $ix = $_;
          map $_->[$ix], @_;
      } 0 .. $max; 
  }
  
  sub uniq (@) {
      my %seen = ();
      grep { not $seen{$_}++ } @_;
  }
  
  sub minmax (@) {
      return unless @_;
      my $min = my $max = $_[0];
  
      for ( my $i = 1; $i < @_; $i += 2 ) {
          if ( $_[$i-1] <= $_[$i] ) {
              $min = $_[$i-1] if $min > $_[$i-1];
              $max = $_[$i]   if $max < $_[$i];
          } else {
              $min = $_[$i]   if $min > $_[$i];
              $max = $_[$i-1] if $max < $_[$i-1];
          }
      }
  
      if ( @_ & 1 ) {
          my $i = $#_;
          if ($_[$i-1] <= $_[$i]) {
              $min = $_[$i-1] if $min > $_[$i-1];
              $max = $_[$i]   if $max < $_[$i];
          } else {
              $min = $_[$i]   if $min > $_[$i];
              $max = $_[$i-1] if $max < $_[$i-1];
          }
      }
  
      return ($min, $max);
  }
  
  sub part (&@) {
      my ($code, @list) = @_;
      my @parts;
      push @{ $parts[ $code->($_) ] }, $_  foreach @list;
      return @parts;
  }
  
  sub _XScompiled {
      return 0;
  }
  
  END_PERL
  die $@ if $@;
  
  # Function aliases
  *first_index = \&firstidx;
  *last_index  = \&lastidx;
  *first_value = \&firstval;
  *last_value  = \&lastval;
  *zip         = \&mesh;
  *distinct    = \&uniq;
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  List::MoreUtils - Provide the stuff missing in List::Util
  
  =head1 SYNOPSIS
  
      use List::MoreUtils qw{
          any all none notall true false
          firstidx first_index lastidx last_index
          insert_after insert_after_string
          apply indexes
          after after_incl before before_incl
          firstval first_value lastval last_value
          each_array each_arrayref
          pairwise natatime
          mesh zip uniq distinct minmax part
      };
  
  =head1 DESCRIPTION
  
  B<List::MoreUtils> provides some trivial but commonly needed functionality on
  lists which is not going to go into L<List::Util>.
  
  All of the below functions are implementable in only a couple of lines of Perl
  code. Using the functions from this module however should give slightly better
  performance as everything is implemented in C. The pure-Perl implementation of
  these functions only serves as a fallback in case the C portions of this module
  couldn't be compiled on this machine.
  
  =over 4
  
  =item any BLOCK LIST
  
  Returns a true value if any item in LIST meets the criterion given through
  BLOCK. Sets C<$_> for each item in LIST in turn:
  
      print "At least one value undefined"
          if any { ! defined($_) } @list;
  
  Returns false otherwise, or if LIST is empty.
  
  =item all BLOCK LIST
  
  Returns a true value if all items in LIST meet the criterion given through
  BLOCK, or if LIST is empty. Sets C<$_> for each item in LIST in turn:
  
      print "All items defined"
          if all { defined($_) } @list;
  
  Returns false otherwise.
  
  =item none BLOCK LIST
  
  Logically the negation of C<any>. Returns a true value if no item in LIST meets
  the criterion given through BLOCK, or if LIST is empty. Sets C<$_> for each item
  in LIST in turn:
  
      print "No value defined"
          if none { defined($_) } @list;
  
  Returns false otherwise.
  
  =item notall BLOCK LIST
  
  Logically the negation of C<all>. Returns a true value if not all items in LIST
  meet the criterion given through BLOCK. Sets C<$_> for each item in LIST in
  turn:
  
      print "Not all values defined"
          if notall { defined($_) } @list;
  
  Returns false otherwise, or if LIST is empty.
  
  =item true BLOCK LIST
  
  Counts the number of elements in LIST for which the criterion in BLOCK is true.
  Sets C<$_> for  each item in LIST in turn:
  
      printf "%i item(s) are defined", true { defined($_) } @list;
  
  =item false BLOCK LIST
  
  Counts the number of elements in LIST for which the criterion in BLOCK is false.
  Sets C<$_> for each item in LIST in turn:
  
      printf "%i item(s) are not defined", false { defined($_) } @list;
  
  =item firstidx BLOCK LIST
  
  =item first_index BLOCK LIST
  
  Returns the index of the first element in LIST for which the criterion in BLOCK
  is true. Sets C<$_> for each item in LIST in turn:
  
      my @list = (1, 4, 3, 2, 4, 6);
      printf "item with index %i in list is 4", firstidx { $_ == 4 } @list;
      __END__
      item with index 1 in list is 4
      
  Returns C<-1> if no such item could be found.
  
  C<first_index> is an alias for C<firstidx>.
  
  =item lastidx BLOCK LIST
  
  =item last_index BLOCK LIST
  
  Returns the index of the last element in LIST for which the criterion in BLOCK
  is true. Sets C<$_> for each item in LIST in turn:
  
      my @list = (1, 4, 3, 2, 4, 6);
      printf "item with index %i in list is 4", lastidx { $_ == 4 } @list;
      __END__
      item with index 4 in list is 4
  
  Returns C<-1> if no such item could be found.
  
  C<last_index> is an alias for C<lastidx>.
  
  =item insert_after BLOCK VALUE LIST
  
  Inserts VALUE after the first item in LIST for which the criterion in BLOCK is
  true. Sets C<$_> for each item in LIST in turn.
  
      my @list = qw/This is a list/;
      insert_after { $_ eq "a" } "longer" => @list;
      print "@list";
      __END__
      This is a longer list
  
  =item insert_after_string STRING VALUE LIST
  
  Inserts VALUE after the first item in LIST which is equal to STRING. 
  
      my @list = qw/This is a list/;
      insert_after_string "a", "longer" => @list;
      print "@list";
      __END__
      This is a longer list
  
  =item apply BLOCK LIST
  
  Applies BLOCK to each item in LIST and returns a list of the values after BLOCK
  has been applied. In scalar context, the last element is returned.  This
  function is similar to C<map> but will not modify the elements of the input
  list:
  
      my @list = (1 .. 4);
      my @mult = apply { $_ *= 2 } @list;
      print "\@list = @list\n";
      print "\@mult = @mult\n";
      __END__
      @list = 1 2 3 4
      @mult = 2 4 6 8
  
  Think of it as syntactic sugar for
  
      for (my @mult = @list) { $_ *= 2 }
  
  =item before BLOCK LIST
  
  Returns a list of values of LIST upto (and not including) the point where BLOCK
  returns a true value. Sets C<$_> for each element in LIST in turn.
  
  =item before_incl BLOCK LIST
  
  Same as C<before> but also includes the element for which BLOCK is true.
  
  =item after BLOCK LIST
  
  Returns a list of the values of LIST after (and not including) the point
  where BLOCK returns a true value. Sets C<$_> for each element in LIST in turn.
  
      @x = after { $_ % 5 == 0 } (1..9);    # returns 6, 7, 8, 9
  
  =item after_incl BLOCK LIST
  
  Same as C<after> but also inclues the element for which BLOCK is true.
  
  =item indexes BLOCK LIST
  
  Evaluates BLOCK for each element in LIST (assigned to C<$_>) and returns a list
  of the indices of those elements for which BLOCK returned a true value. This is
  just like C<grep> only that it returns indices instead of values:
  
      @x = indexes { $_ % 2 == 0 } (1..10);   # returns 1, 3, 5, 7, 9
  
  =item firstval BLOCK LIST
  
  =item first_value BLOCK LIST
  
  Returns the first element in LIST for which BLOCK evaluates to true. Each
  element of LIST is set to C<$_> in turn. Returns C<undef> if no such element
  has been found.
  
  C<first_val> is an alias for C<firstval>.
  
  =item lastval BLOCK LIST
  
  =item last_value BLOCK LIST
  
  Returns the last value in LIST for which BLOCK evaluates to true. Each element
  of LIST is set to C<$_> in turn. Returns C<undef> if no such element has been
  found.
  
  C<last_val> is an alias for C<lastval>.
  
  =item pairwise BLOCK ARRAY1 ARRAY2
  
  Evaluates BLOCK for each pair of elements in ARRAY1 and ARRAY2 and returns a
  new list consisting of BLOCK's return values. The two elements are set to C<$a>
  and C<$b>.  Note that those two are aliases to the original value so changing
  them will modify the input arrays.
  
      @a = (1 .. 5);
      @b = (11 .. 15);
      @x = pairwise { $a + $b } @a, @b;	# returns 12, 14, 16, 18, 20
  
      # mesh with pairwise
      @a = qw/a b c/;
      @b = qw/1 2 3/;
      @x = pairwise { ($a, $b) } @a, @b;	# returns a, 1, b, 2, c, 3
  
  =item each_array ARRAY1 ARRAY2 ...
  
  Creates an array iterator to return the elements of the list of arrays ARRAY1,
  ARRAY2 throughout ARRAYn in turn.  That is, the first time it is called, it
  returns the first element of each array.  The next time, it returns the second
  elements.  And so on, until all elements are exhausted.
  
  This is useful for looping over more than one array at once:
  
      my $ea = each_array(@a, @b, @c);
      while ( my ($a, $b, $c) = $ea->() )   { .... }
  
  The iterator returns the empty list when it reached the end of all arrays.
  
  If the iterator is passed an argument of 'C<index>', then it retuns
  the index of the last fetched set of values, as a scalar.
  
  =item each_arrayref LIST
  
  Like each_array, but the arguments are references to arrays, not the
  plain arrays.
  
  =item natatime EXPR, LIST
  
  Creates an array iterator, for looping over an array in chunks of
  C<$n> items at a time.  (n at a time, get it?).  An example is
  probably a better explanation than I could give in words.
  
  Example:
  
      my @x = ('a' .. 'g');
      my $it = natatime 3, @x;
      while (my @vals = $it->())
      {
          print "@vals\n";
      }
  
  This prints
  
      a b c
      d e f
      g
  
  =item mesh ARRAY1 ARRAY2 [ ARRAY3 ... ]
  
  =item zip ARRAY1 ARRAY2 [ ARRAY3 ... ]
  
  Returns a list consisting of the first elements of each array, then
  the second, then the third, etc, until all arrays are exhausted.
  
  Examples:
  
      @x = qw/a b c d/;
      @y = qw/1 2 3 4/;
      @z = mesh @x, @y;	    # returns a, 1, b, 2, c, 3, d, 4
  
      @a = ('x');
      @b = ('1', '2');
      @c = qw/zip zap zot/;
      @d = mesh @a, @b, @c;   # x, 1, zip, undef, 2, zap, undef, undef, zot
  
  C<zip> is an alias for C<mesh>.
  
  =item uniq LIST
  
  =item distinct LIST
  
  Returns a new list by stripping duplicate values in LIST. The order of
  elements in the returned list is the same as in LIST. In scalar context,
  returns the number of unique elements in LIST.
  
      my @x = uniq 1, 1, 2, 2, 3, 5, 3, 4; # returns 1 2 3 5 4
      my $x = uniq 1, 1, 2, 2, 3, 5, 3, 4; # returns 5
  
  =item minmax LIST
  
  Calculates the minimum and maximum of LIST and returns a two element list with
  the first element being the minimum and the second the maximum. Returns the
  empty list if LIST was empty.
  
  The C<minmax> algorithm differs from a naive iteration over the list where each
  element is compared to two values being the so far calculated min and max value
  in that it only requires 3n/2 - 2 comparisons. Thus it is the most efficient
  possible algorithm.
  
  However, the Perl implementation of it has some overhead simply due to the fact
  that there are more lines of Perl code involved. Therefore, LIST needs to be
  fairly big in order for C<minmax> to win over a naive implementation. This
  limitation does not apply to the XS version.
  
  =item part BLOCK LIST
  
  Partitions LIST based on the return value of BLOCK which denotes into which
  partition the current value is put.
  
  Returns a list of the partitions thusly created. Each partition created is a
  reference to an array.
  
      my $i = 0;
      my @part = part { $i++ % 2 } 1 .. 8;   # returns [1, 3, 5, 7], [2, 4, 6, 8]
  
  You can have a sparse list of partitions as well where non-set partitions will
  be undef:
  
      my @part = part { 2 } 1 .. 10;	    # returns undef, undef, [ 1 .. 10 ]
  
  Be careful with negative values, though:
  
      my @part = part { -1 } 1 .. 10;
      __END__
      Modification of non-creatable array value attempted, subscript -1 ...
  
  Negative values are only ok when they refer to a partition previously created:
  
      my @idx  = ( 0, 1, -1 );
      my $i    = 0;
      my @part = part { $idx[$++ % 3] } 1 .. 8; # [1, 4, 7], [2, 3, 5, 6, 8]
  
  =back
  
  =head1 EXPORTS
  
  Nothing by default. To import all of this module's symbols, do the conventional
  
      use List::MoreUtils ':all';
  
  It may make more sense though to only import the stuff your program actually
  needs:
  
      use List::MoreUtils qw{ any firstidx };
  
  =head1 ENVIRONMENT
  
  When C<LIST_MOREUTILS_PP> is set, the module will always use the pure-Perl
  implementation and not the XS one. This environment variable is really just
  there for the test-suite to force testing the Perl implementation, and possibly
  for reporting of bugs. I don't see any reason to use it in a production
  environment.
  
  =head1 BUGS
  
  There is a problem with a bug in 5.6.x perls. It is a syntax error to write
  things like:
  
      my @x = apply { s/foo/bar/ } qw{ foo bar baz };
  
  It has to be written as either
  
      my @x = apply { s/foo/bar/ } 'foo', 'bar', 'baz';
  
  or
  
      my @x = apply { s/foo/bar/ } my @dummy = qw/foo bar baz/;
  
  Perl 5.5.x and Perl 5.8.x don't suffer from this limitation.
  
  If you have a functionality that you could imagine being in this module, please
  drop me a line. This module's policy will be less strict than L<List::Util>'s
  when it comes to additions as it isn't a core module.
  
  When you report bugs, it would be nice if you could additionally give me the
  output of your program with the environment variable C<LIST_MOREUTILS_PP> set
  to a true value. That way I know where to look for the problem (in XS,
  pure-Perl or possibly both).
  
  =head1 SUPPORT
  
  Bugs should always be submitted via the CPAN bug tracker.
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=List-MoreUtils>
  
  =head1 THANKS
  
  Credits go to a number of people: Steve Purkis for giving me namespace advice
  and James Keenan and Terrence Branno for their effort of keeping the CPAN
  tidier by making L<List::Utils> obsolete. 
  
  Brian McCauley suggested the inclusion of apply() and provided the pure-Perl
  implementation for it.
  
  Eric J. Roode asked me to add all functions from his module C<List::MoreUtil>
  into this one. With minor modifications, the pure-Perl implementations of those
  are by him.
  
  The bunch of people who almost immediately pointed out the many problems with
  the glitchy 0.07 release (Slaven Rezic, Ron Savage, CPAN testers).
  
  A particularly nasty memory leak was spotted by Thomas A. Lowery.
  
  Lars Thegler made me aware of problems with older Perl versions.
  
  Anno Siegel de-orphaned each_arrayref().
  
  David Filmer made me aware of a problem in each_arrayref that could ultimately
  lead to a segfault.
  
  Ricardo Signes suggested the inclusion of part() and provided the
  Perl-implementation.
  
  Robin Huston kindly fixed a bug in perl's MULTICALL API to make the
  XS-implementation of part() work.
  
  =head1 TODO
  
  A pile of requests from other people is still pending further processing in
  my mailbox. This includes:
  
  =over 4
  
  =item * List::Util export pass-through
  
  Allow B<List::MoreUtils> to pass-through the regular L<List::Util>
  functions to end users only need to C<use> the one module.
  
  =item * uniq_by(&@)
  
  Use code-reference to extract a key based on which the uniqueness is
  determined. Suggested by Aaron Crane.
  
  =item * delete_index
  
  =item * random_item
  
  =item * random_item_delete_index
  
  =item * list_diff_hash
  
  =item * list_diff_inboth
  
  =item * list_diff_infirst
  
  =item * list_diff_insecond
  
  These were all suggested by Dan Muey.
  
  =item * listify
  
  Always return a flat list when either a simple scalar value was passed or an
  array-reference. Suggested by Mark Summersault.
  
  =back
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Tassilo von Parseval E<lt>tassilo.von.parseval@rwth-aachen.deE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Some parts copyright 2011 Aaron Crane.
  
  Copyright 2004 - 2010 by Tassilo von Parseval
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.8.4 or,
  at your option, any later version of Perl 5 you may have available.
  
  =cut
I686-LINUX_LIST_MOREUTILS

$fatpacked{"i686-linux/Moose.pm"} = <<'I686-LINUX_MOOSE';
  package Moose;
  BEGIN {
    $Moose::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::VERSION = '2.0401';
  }
  use strict;
  use warnings;
  
  use 5.008;
  
  use Scalar::Util 'blessed';
  use Carp         'confess';
  use Class::Load  'is_class_loaded';
  
  
  use Moose::Deprecated;
  use Moose::Exporter;
  
  use Class::MOP;
  
  BEGIN {
      die "Class::MOP version $Moose::VERSION required--this is version $Class::MOP::VERSION"
          if $Moose::VERSION && $Class::MOP::VERSION ne $Moose::VERSION;
  }
  
  use Moose::Meta::Class;
  use Moose::Meta::TypeConstraint;
  use Moose::Meta::TypeCoercion;
  use Moose::Meta::Attribute;
  use Moose::Meta::Instance;
  
  use Moose::Object;
  
  use Moose::Meta::Role;
  use Moose::Meta::Role::Composite;
  use Moose::Meta::Role::Application;
  use Moose::Meta::Role::Application::RoleSummation;
  use Moose::Meta::Role::Application::ToClass;
  use Moose::Meta::Role::Application::ToRole;
  use Moose::Meta::Role::Application::ToInstance;
  
  use Moose::Util::TypeConstraints;
  use Moose::Util ();
  
  use Moose::Meta::Attribute::Native;
  
  sub throw_error {
      # FIXME This
      shift;
      goto \&confess
  }
  
  sub extends {
      my $meta = shift;
  
      Moose->throw_error("Must derive at least one class") unless @_;
  
      # this checks the metaclass to make sure
      # it is correct, sometimes it can get out
      # of sync when the classes are being built
      $meta->superclasses(@_);
  }
  
  sub with {
      Moose::Util::apply_all_roles(shift, @_);
  }
  
  sub has {
      my $meta = shift;
      my $name = shift;
  
      Moose->throw_error('Usage: has \'name\' => ( key => value, ... )')
          if @_ % 2 == 1;
  
      my %options = ( definition_context => Moose::Util::_caller_info(), @_ );
      my $attrs = ( ref($name) eq 'ARRAY' ) ? $name : [ ($name) ];
      $meta->add_attribute( $_, %options ) for @$attrs;
  }
  
  sub before {
      Moose::Util::add_method_modifier(shift, 'before', \@_);
  }
  
  sub after {
      Moose::Util::add_method_modifier(shift, 'after', \@_);
  }
  
  sub around {
      Moose::Util::add_method_modifier(shift, 'around', \@_);
  }
  
  our $SUPER_PACKAGE;
  our $SUPER_BODY;
  our @SUPER_ARGS;
  
  sub super {
      # This check avoids a recursion loop - see
      # t/bugs/super_recursion.t
      return if defined $SUPER_PACKAGE && $SUPER_PACKAGE ne caller();
      return unless $SUPER_BODY; $SUPER_BODY->(@SUPER_ARGS);
  }
  
  sub override {
      my $meta = shift;
      my ( $name, $method ) = @_;
      $meta->add_override_method_modifier( $name => $method );
  }
  
  sub inner {
      my $pkg = caller();
      our ( %INNER_BODY, %INNER_ARGS );
  
      if ( my $body = $INNER_BODY{$pkg} ) {
          my @args = @{ $INNER_ARGS{$pkg} };
          local $INNER_ARGS{$pkg};
          local $INNER_BODY{$pkg};
          return $body->(@args);
      } else {
          return;
      }
  }
  
  sub augment {
      my $meta = shift;
      my ( $name, $method ) = @_;
      $meta->add_augment_method_modifier( $name => $method );
  }
  
  Moose::Exporter->setup_import_methods(
      with_meta => [
          qw( extends with has before after around override augment )
      ],
      as_is => [
          qw( super inner ),
          \&Carp::confess,
          \&Scalar::Util::blessed,
      ],
  );
  
  sub init_meta {
      shift;
      my %args = @_;
  
      my $class = $args{for_class}
          or Moose->throw_error("Cannot call init_meta without specifying a for_class");
      my $base_class = $args{base_class} || 'Moose::Object';
      my $metaclass  = $args{metaclass}  || 'Moose::Meta::Class';
      my $meta_name  = exists $args{meta_name} ? $args{meta_name} : 'meta';
  
      Moose->throw_error("The Metaclass $metaclass must be loaded. (Perhaps you forgot to 'use $metaclass'?)")
          unless is_class_loaded($metaclass);
  
      Moose->throw_error("The Metaclass $metaclass must be a subclass of Moose::Meta::Class.")
          unless $metaclass->isa('Moose::Meta::Class');
  
      # make a subtype for each Moose class
      class_type($class)
          unless find_type_constraint($class);
  
      my $meta;
  
      if ( $meta = Class::MOP::get_metaclass_by_name($class) ) {
          unless ( $meta->isa("Moose::Meta::Class") ) {
              my $error_message = "$class already has a metaclass, but it does not inherit $metaclass ($meta).";
              if ( $meta->isa('Moose::Meta::Role') ) {
                  Moose->throw_error($error_message . ' You cannot make the same thing a role and a class. Remove either Moose or Moose::Role.');
              } else {
                  Moose->throw_error($error_message);
              }
          }
      } else {
          # no metaclass
  
          # now we check whether our ancestors have metaclass, and if so borrow that
          my ( undef, @isa ) = @{ mro::get_linear_isa($class) };
  
          foreach my $ancestor ( @isa ) {
              my $ancestor_meta = Class::MOP::get_metaclass_by_name($ancestor) || next;
  
              my $ancestor_meta_class = $ancestor_meta->_real_ref_name;
  
              # if we have an ancestor metaclass that inherits $metaclass, we use
              # that. This is like _fix_metaclass_incompatibility, but we can do it now.
  
              # the case of having an ancestry is not very common, but arises in
              # e.g. Reaction
              unless ( $metaclass->isa( $ancestor_meta_class ) ) {
                  if ( $ancestor_meta_class->isa($metaclass) ) {
                      $metaclass = $ancestor_meta_class;
                  }
              }
          }
  
          $meta = $metaclass->initialize($class);
      }
  
      if (defined $meta_name) {
          # also check for inherited non moose 'meta' method?
          my $existing = $meta->get_method($meta_name);
          if ($existing && !$existing->isa('Class::MOP::Method::Meta')) {
              Carp::cluck "Moose is overwriting an existing method named "
                        . "$meta_name in class $class with a method "
                        . "which returns the class's metaclass. If this is "
                        . "actually what you want, you should remove the "
                        . "existing method, otherwise, you should rename or "
                        . "disable this generated method using the "
                        . "'-meta_name' option to 'use Moose'.";
          }
          $meta->_add_meta_method($meta_name);
      }
  
      # make sure they inherit from Moose::Object
      $meta->superclasses($base_class)
        unless $meta->superclasses();
  
      return $meta;
  }
  
  # This may be used in some older MooseX extensions.
  sub _get_caller {
      goto &Moose::Exporter::_get_caller;
  }
  
  ## make 'em all immutable
  
  $_->make_immutable(
      inline_constructor => 1,
      constructor_name   => "_new",
      # these are Class::MOP accessors, so they need inlining
      inline_accessors => 1
      ) for grep { $_->is_mutable }
      map { $_->meta }
      qw(
      Moose::Meta::Attribute
      Moose::Meta::Class
      Moose::Meta::Instance
  
      Moose::Meta::TypeCoercion
      Moose::Meta::TypeCoercion::Union
  
      Moose::Meta::Method
      Moose::Meta::Method::Constructor
      Moose::Meta::Method::Destructor
      Moose::Meta::Method::Overridden
      Moose::Meta::Method::Augmented
  
      Moose::Meta::Role
      Moose::Meta::Role::Attribute
      Moose::Meta::Role::Method
      Moose::Meta::Role::Method::Required
      Moose::Meta::Role::Method::Conflicting
  
      Moose::Meta::Role::Composite
  
      Moose::Meta::Role::Application
      Moose::Meta::Role::Application::RoleSummation
      Moose::Meta::Role::Application::ToClass
      Moose::Meta::Role::Application::ToRole
      Moose::Meta::Role::Application::ToInstance
  );
  
  $_->make_immutable(
      inline_constructor => 0,
      constructor_name   => undef,
      # these are Class::MOP accessors, so they need inlining
      inline_accessors => 1
      ) for grep { $_->is_mutable }
      map { $_->meta }
      qw(
      Moose::Meta::Method::Accessor
      Moose::Meta::Method::Delegation
      Moose::Meta::Mixin::AttributeCore
  );
  
  1;
  
  # ABSTRACT: A postmodern object system for Perl 5
  
  
  
  =pod
  
  =head1 NAME
  
  Moose - A postmodern object system for Perl 5
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 SYNOPSIS
  
    package Point;
    use Moose; # automatically turns on strict and warnings
  
    has 'x' => (is => 'rw', isa => 'Int');
    has 'y' => (is => 'rw', isa => 'Int');
  
    sub clear {
        my $self = shift;
        $self->x(0);
        $self->y(0);
    }
  
    package Point3D;
    use Moose;
  
    extends 'Point';
  
    has 'z' => (is => 'rw', isa => 'Int');
  
    after 'clear' => sub {
        my $self = shift;
        $self->z(0);
    };
  
  =head1 DESCRIPTION
  
  Moose is an extension of the Perl 5 object system.
  
  The main goal of Moose is to make Perl 5 Object Oriented programming
  easier, more consistent, and less tedious. With Moose you can think
  more about what you want to do and less about the mechanics of OOP.
  
  Additionally, Moose is built on top of L<Class::MOP>, which is a
  metaclass system for Perl 5. This means that Moose not only makes
  building normal Perl 5 objects better, but it provides the power of
  metaclass programming as well.
  
  =head2 New to Moose?
  
  If you're new to Moose, the best place to start is the
  L<Moose::Manual> docs, followed by the L<Moose::Cookbook>. The intro
  will show you what Moose is, and how it makes Perl 5 OO better.
  
  The cookbook recipes on Moose basics will get you up to speed with
  many of Moose's features quickly. Once you have an idea of what Moose
  can do, you can use the API documentation to get more detail on
  features which interest you.
  
  =head2 Moose Extensions
  
  The C<MooseX::> namespace is the official place to find Moose extensions.
  These extensions can be found on the CPAN.  The easiest way to find them
  is to search for them (L<http://search.cpan.org/search?query=MooseX::>),
  or to examine L<Task::Moose> which aims to keep an up-to-date, easily
  installable list of Moose extensions.
  
  =head1 TRANSLATIONS
  
  Much of the Moose documentation has been translated into other languages.
  
  =over 4
  
  =item Japanese
  
  Japanese docs can be found at
  L<http://perldoc.perlassociation.org/pod/Moose-Doc-JA/index.html>. The
  source POD files can be found in GitHub:
  L<http://github.com/jpa/Moose-Doc-JA>
  
  =back
  
  =head1 BUILDING CLASSES WITH MOOSE
  
  Moose makes every attempt to provide as much convenience as possible during
  class construction/definition, but still stay out of your way if you want it
  to. Here are a few items to note when building classes with Moose.
  
  When you C<use Moose>, Moose will set the class's parent class to
  L<Moose::Object>, I<unless> the class using Moose already has a parent
  class. In addition, specifying a parent with C<extends> will change the parent
  class.
  
  Moose will also manage all attributes (including inherited ones) that are
  defined with C<has>. And (assuming you call C<new>, which is inherited from
  L<Moose::Object>) this includes properly initializing all instance slots,
  setting defaults where appropriate, and performing any type constraint checking
  or coercion.
  
  =head1 PROVIDED METHODS
  
  Moose provides a number of methods to all your classes, mostly through the
  inheritance of L<Moose::Object>. There is however, one exception.
  
  =over 4
  
  =item B<meta>
  
  This is a method which provides access to the current class's metaclass.
  
  =back
  
  =head1 EXPORTED FUNCTIONS
  
  Moose will export a number of functions into the class's namespace which
  may then be used to set up the class. These functions all work directly
  on the current class.
  
  =over 4
  
  =item B<extends (@superclasses)>
  
  This function will set the superclass(es) for the current class.
  
  This approach is recommended instead of C<use base>, because C<use base>
  actually C<push>es onto the class's C<@ISA>, whereas C<extends> will
  replace it. This is important to ensure that classes which do not have
  superclasses still properly inherit from L<Moose::Object>.
  
  Each superclass can be followed by a hash reference with options. Currently,
  only L<-version|Class::MOP/Class Loading Options> is recognized:
  
      extends 'My::Parent'      => { -version => 0.01 },
              'My::OtherParent' => { -version => 0.03 };
  
  An exception will be thrown if the version requirements are not
  satisfied.
  
  =item B<with (@roles)>
  
  This will apply a given set of C<@roles> to the local class.
  
  Like with C<extends>, each specified role can be followed by a hash
  reference with a L<-version|Class::MOP/Class Loading Options> option:
  
      with 'My::Role'      => { -version => 0.32 },
           'My::Otherrole' => { -version => 0.23 };
  
  The specified version requirements must be satisfied, otherwise an
  exception will be thrown.
  
  If your role takes options or arguments, they can be passed along in the
  hash reference as well.
  
  =item B<has $name|@$names =E<gt> %options>
  
  This will install an attribute of a given C<$name> into the current class. If
  the first parameter is an array reference, it will create an attribute for
  every C<$name> in the list. The C<%options> will be passed to the constructor
  for L<Moose::Meta::Attribute> (which inherits from L<Class::MOP::Attribute>),
  so the full documentation for the valid options can be found there. These are
  the most commonly used options:
  
  =over 4
  
  =item I<is =E<gt> 'rw'|'ro'>
  
  The I<is> option accepts either I<rw> (for read/write) or I<ro> (for read
  only). These will create either a read/write accessor or a read-only
  accessor respectively, using the same name as the C<$name> of the attribute.
  
  If you need more control over how your accessors are named, you can
  use the L<reader|Class::MOP::Attribute/reader>,
  L<writer|Class::MOP::Attribute/writer> and
  L<accessor|Class::MOP::Attribute/accessor> options inherited from
  L<Class::MOP::Attribute>, however if you use those, you won't need the
  I<is> option.
  
  =item I<isa =E<gt> $type_name>
  
  The I<isa> option uses Moose's type constraint facilities to set up runtime
  type checking for this attribute. Moose will perform the checks during class
  construction, and within any accessors. The C<$type_name> argument must be a
  string. The string may be either a class name or a type defined using
  Moose's type definition features. (Refer to L<Moose::Util::TypeConstraints>
  for information on how to define a new type, and how to retrieve type meta-data).
  
  =item I<coerce =E<gt> (1|0)>
  
  This will attempt to use coercion with the supplied type constraint to change
  the value passed into any accessors or constructors. You B<must> supply a type
  constraint, and that type constraint B<must> define a coercion. See
  L<Moose::Cookbook::Basics::Recipe5> for an example.
  
  =item I<does =E<gt> $role_name>
  
  This will accept the name of a role which the value stored in this attribute
  is expected to have consumed.
  
  =item I<required =E<gt> (1|0)>
  
  This marks the attribute as being required. This means a value must be
  supplied during class construction, I<or> the attribute must be lazy
  and have either a default or a builder. Note that c<required> does not
  say anything about the attribute's value, which can be C<undef>.
  
  =item I<weak_ref =E<gt> (1|0)>
  
  This will tell the class to store the value of this attribute as a weakened
  reference. If an attribute is a weakened reference, it B<cannot> also be
  coerced. Note that when a weak ref expires, the attribute's value becomes
  undefined, and is still considered to be set for purposes of predicate,
  default, etc.
  
  =item I<lazy =E<gt> (1|0)>
  
  This will tell the class to not create this slot until absolutely necessary.
  If an attribute is marked as lazy it B<must> have a default or builder
  supplied.
  
  =item I<trigger =E<gt> $code>
  
  The I<trigger> option is a CODE reference which will be called after
  the value of the attribute is set. The CODE ref is passed the
  instance itself, the updated value, and the original value if the
  attribute was already set.
  
  You B<can> have a trigger on a read-only attribute.
  
  B<NOTE:> Triggers will only fire when you B<assign> to the attribute,
  either in the constructor, or using the writer. Default and built values will
  B<not> cause the trigger to be fired.
  
  =item I<handles =E<gt> ARRAY | HASH | REGEXP | ROLE | ROLETYPE | DUCKTYPE | CODE>
  
  The I<handles> option provides Moose classes with automated delegation features.
  This is a pretty complex and powerful option. It accepts many different option
  formats, each with its own benefits and drawbacks.
  
  B<NOTE:> The class being delegated to does not need to be a Moose based class,
  which is why this feature is especially useful when wrapping non-Moose classes.
  
  All I<handles> option formats share the following traits:
  
  You cannot override a locally defined method with a delegated method; an
  exception will be thrown if you try. That is to say, if you define C<foo> in
  your class, you cannot override it with a delegated C<foo>. This is almost never
  something you would want to do, and if it is, you should do it by hand and not
  use Moose.
  
  You cannot override any of the methods found in Moose::Object, or the C<BUILD>
  and C<DEMOLISH> methods. These will not throw an exception, but will silently
  move on to the next method in the list. My reasoning for this is that you would
  almost never want to do this, since it usually breaks your class. As with
  overriding locally defined methods, if you do want to do this, you should do it
  manually, not with Moose.
  
  You do not I<need> to have a reader (or accessor) for the attribute in order
  to delegate to it. Moose will create a means of accessing the value for you,
  however this will be several times B<less> efficient then if you had given
  the attribute a reader (or accessor) to use.
  
  Below is the documentation for each option format:
  
  =over 4
  
  =item C<ARRAY>
  
  This is the most common usage for I<handles>. You basically pass a list of
  method names to be delegated, and Moose will install a delegation method
  for each one.
  
  =item C<HASH>
  
  This is the second most common usage for I<handles>. Instead of a list of
  method names, you pass a HASH ref where each key is the method name you
  want installed locally, and its value is the name of the original method
  in the class being delegated to.
  
  This can be very useful for recursive classes like trees. Here is a
  quick example (soon to be expanded into a Moose::Cookbook recipe):
  
    package Tree;
    use Moose;
  
    has 'node' => (is => 'rw', isa => 'Any');
  
    has 'children' => (
        is      => 'ro',
        isa     => 'ArrayRef',
        default => sub { [] }
    );
  
    has 'parent' => (
        is          => 'rw',
        isa         => 'Tree',
        weak_ref    => 1,
        handles     => {
            parent_node => 'node',
            siblings    => 'children',
        }
    );
  
  In this example, the Tree package gets C<parent_node> and C<siblings> methods,
  which delegate to the C<node> and C<children> methods (respectively) of the Tree
  instance stored in the C<parent> slot.
  
  You may also use an array reference to curry arguments to the original method.
  
    has 'thing' => (
        ...
        handles => { set_foo => [ set => 'foo' ] },
    );
  
    # $self->set_foo(...) calls $self->thing->set('foo', ...)
  
  The first element of the array reference is the original method name, and the
  rest is a list of curried arguments.
  
  =item C<REGEXP>
  
  The regexp option works very similar to the ARRAY option, except that it builds
  the list of methods for you. It starts by collecting all possible methods of the
  class being delegated to, then filters that list using the regexp supplied here.
  
  B<NOTE:> An I<isa> option is required when using the regexp option format. This
  is so that we can determine (at compile time) the method list from the class.
  Without an I<isa> this is just not possible.
  
  =item C<ROLE> or C<ROLETYPE>
  
  With the role option, you specify the name of a role or a
  L<role type|Moose::Meta::TypeConstraint::Role> whose "interface" then becomes
  the list of methods to handle. The "interface" can be defined as; the methods
  of the role and any required methods of the role. It should be noted that this
  does B<not> include any method modifiers or generated attribute methods (which
  is consistent with role composition).
  
  =item C<DUCKTYPE>
  
  With the duck type option, you pass a duck type object whose "interface" then
  becomes the list of methods to handle. The "interface" can be defined as the
  list of methods passed to C<duck_type> to create a duck type object. For more
  information on C<duck_type> please check
  L<Moose::Util::TypeConstraints>.
  
  =item C<CODE>
  
  This is the option to use when you really want to do something funky. You should
  only use it if you really know what you are doing, as it involves manual
  metaclass twiddling.
  
  This takes a code reference, which should expect two arguments. The first is the
  attribute meta-object this I<handles> is attached to. The second is the
  metaclass of the class being delegated to. It expects you to return a hash (not
  a HASH ref) of the methods you want mapped.
  
  =back
  
  =item I<traits =E<gt> [ @role_names ]>
  
  This tells Moose to take the list of C<@role_names> and apply them to the
  attribute meta-object. Custom attribute metaclass traits are useful for
  extending the capabilities of the I<has> keyword: they are the simplest way to
  extend the MOP, but they are still a fairly advanced topic and too much to
  cover here.
  
  See L<Metaclass and Trait Name Resolution> for details on how a trait name is
  resolved to a role name.
  
  Also see L<Moose::Cookbook::Meta::Recipe3> for a metaclass trait
  example.
  
  =item I<builder> => Str
  
  The value of this key is the name of the method that will be called to
  obtain the value used to initialize the attribute. See the L<builder
  option docs in Class::MOP::Attribute|Class::MOP::Attribute/builder>
  and/or L<Moose::Cookbook::Basics::Recipe8> for more information.
  
  =item I<default> => SCALAR | CODE
  
  The value of this key is the default value which will initialize the attribute.
  
  NOTE: If the value is a simple scalar (string or number), then it can
  be just passed as is.  However, if you wish to initialize it with a
  HASH or ARRAY ref, then you need to wrap that inside a CODE reference.
  See the L<default option docs in
  Class::MOP::Attribute|Class::MOP::Attribute/default> for more
  information.
  
  =item I<clearer> => Str
  
  Creates a method allowing you to clear the value. See the L<clearer option
  docs in Class::MOP::Attribute|Class::MOP::Attribute/clearer> for more
  information.
  
  =item I<predicate> => Str
  
  Creates a method to perform a basic test to see if a value has been set in the
  attribute. See the L<predicate option docs in
  Class::MOP::Attribute|Class::MOP::Attribute/predicate> for more information.
  
  Note that the predicate will return true even for a C<weak_ref> attribute
  whose value has expired.
  
  =item I<documentation> => $string
  
  An arbitrary string that can be retrieved later by calling C<<
  $attr->documentation >>.
  
  =back
  
  =item B<has +$name =E<gt> %options>
  
  This is variation on the normal attribute creator C<has> which allows you to
  clone and extend an attribute from a superclass or from a role. Here is an
  example of the superclass usage:
  
    package Foo;
    use Moose;
  
    has 'message' => (
        is      => 'rw',
        isa     => 'Str',
        default => 'Hello, I am a Foo'
    );
  
    package My::Foo;
    use Moose;
  
    extends 'Foo';
  
    has '+message' => (default => 'Hello I am My::Foo');
  
  What is happening here is that B<My::Foo> is cloning the C<message> attribute
  from its parent class B<Foo>, retaining the C<is =E<gt> 'rw'> and C<isa =E<gt>
  'Str'> characteristics, but changing the value in C<default>.
  
  Here is another example, but within the context of a role:
  
    package Foo::Role;
    use Moose::Role;
  
    has 'message' => (
        is      => 'rw',
        isa     => 'Str',
        default => 'Hello, I am a Foo'
    );
  
    package My::Foo;
    use Moose;
  
    with 'Foo::Role';
  
    has '+message' => (default => 'Hello I am My::Foo');
  
  In this case, we are basically taking the attribute which the role supplied
  and altering it within the bounds of this feature.
  
  Note that you can only extend an attribute from either a superclass or a role,
  you cannot extend an attribute in a role that composes over an attribute from
  another role.
  
  Aside from where the attributes come from (one from superclass, the other
  from a role), this feature works exactly the same. This feature is restricted
  somewhat, so as to try and force at least I<some> sanity into it. Most options work the same, but there are some exceptions:
  
  =over 4
  
  =item I<reader>
  
  =item I<writer>
  
  =item I<accessor>
  
  =item I<clearer>
  
  =item I<predicate>
  
  These options can be added, but cannot override a superclass definition.
  
  =item I<traits>
  
  You are allowed to B<add> additional traits to the C<traits> definition.
  These traits will be composed into the attribute, but preexisting traits
  B<are not> overridden, or removed.
  
  =back
  
  =item B<before $name|@names|\@names|qr/.../ =E<gt> sub { ... }>
  
  =item B<after $name|@names|\@names|qr/.../ =E<gt> sub { ... }>
  
  =item B<around $name|@names|\@names|qr/.../ =E<gt> sub { ... }>
  
  These three items are syntactic sugar for the before, after, and around method
  modifier features that L<Class::MOP> provides. More information on these may be
  found in L<Moose::Manual::MethodModifiers> and the
  L<Class::MOP::Class documentation|Class::MOP::Class/"Method Modifiers">.
  
  =item B<override ($name, &sub)>
  
  An C<override> method is a way of explicitly saying "I am overriding this
  method from my superclass". You can call C<super> within this method, and
  it will work as expected. The same thing I<can> be accomplished with a normal
  method call and the C<SUPER::> pseudo-package; it is really your choice.
  
  =item B<super>
  
  The keyword C<super> is a no-op when called outside of an C<override> method. In
  the context of an C<override> method, it will call the next most appropriate
  superclass method with the same arguments as the original method.
  
  =item B<augment ($name, &sub)>
  
  An C<augment> method, is a way of explicitly saying "I am augmenting this
  method from my superclass". Once again, the details of how C<inner> and
  C<augment> work is best described in the L<Moose::Cookbook::Basics::Recipe6>.
  
  =item B<inner>
  
  The keyword C<inner>, much like C<super>, is a no-op outside of the context of
  an C<augment> method. You can think of C<inner> as being the inverse of
  C<super>; the details of how C<inner> and C<augment> work is best described in
  the L<Moose::Cookbook::Basics::Recipe6>.
  
  =item B<blessed>
  
  This is the C<Scalar::Util::blessed> function. It is highly recommended that
  this is used instead of C<ref> anywhere you need to test for an object's class
  name.
  
  =item B<confess>
  
  This is the C<Carp::confess> function, and exported here for historical
  reasons.
  
  =back
  
  =head1 METACLASS
  
  When you use Moose, you can specify traits which will be applied to your
  metaclass:
  
      use Moose -traits => 'My::Trait';
  
  This is very similar to the attribute traits feature. When you do
  this, your class's C<meta> object will have the specified traits
  applied to it. See L<Metaclass and Trait Name Resolution> for more
  details.
  
  =head2 Metaclass and Trait Name Resolution
  
  By default, when given a trait name, Moose simply tries to load a
  class of the same name. If such a class does not exist, it then looks
  for for a class matching
  B<Moose::Meta::$type::Custom::Trait::$trait_name>. The C<$type>
  variable here will be one of B<Attribute> or B<Class>, depending on
  what the trait is being applied to.
  
  If a class with this long name exists, Moose checks to see if it has
  the method C<register_implementation>. This method is expected to
  return the I<real> class name of the trait. If there is no
  C<register_implementation> method, it will fall back to using
  B<Moose::Meta::$type::Custom::Trait::$trait> as the trait name.
  
  The lookup method for metaclasses is the same, except that it looks
  for a class matching B<Moose::Meta::$type::Custom::$metaclass_name>.
  
  If all this is confusing, take a look at
  L<Moose::Cookbook::Meta::Recipe3>, which demonstrates how to create an
  attribute trait.
  
  =head1 UNIMPORTING FUNCTIONS
  
  =head2 B<unimport>
  
  Moose offers a way to remove the keywords it exports, through the C<unimport>
  method. You simply have to say C<no Moose> at the bottom of your code for this
  to work. Here is an example:
  
      package Person;
      use Moose;
  
      has 'first_name' => (is => 'rw', isa => 'Str');
      has 'last_name'  => (is => 'rw', isa => 'Str');
  
      sub full_name {
          my $self = shift;
          $self->first_name . ' ' . $self->last_name
      }
  
      no Moose; # keywords are removed from the Person package
  
  =head1 EXTENDING AND EMBEDDING MOOSE
  
  To learn more about extending Moose, we recommend checking out the
  "Extending" recipes in the L<Moose::Cookbook>, starting with
  L<Moose::Cookbook::Extending::Recipe1>, which provides an overview of
  all the different ways you might extend Moose. L<Moose::Exporter> and
  L<Moose::Util::MetaRole> are the modules which provide the majority of the
  extension functionality, so reading their documentation should also be helpful.
  
  =head2 The MooseX:: namespace
  
  Generally if you're writing an extension I<for> Moose itself you'll want
  to put your extension in the C<MooseX::> namespace. This namespace is
  specifically for extensions that make Moose better or different in some
  fundamental way. It is traditionally B<not> for a package that just happens
  to use Moose. This namespace follows from the examples of the C<LWPx::>
  and C<DBIx::> namespaces that perform the same function for C<LWP> and C<DBI>
  respectively.
  
  =head1 METACLASS COMPATIBILITY AND MOOSE
  
  Metaclass compatibility is a thorny subject. You should start by
  reading the "About Metaclass compatibility" section in the
  C<Class::MOP> docs.
  
  Moose will attempt to resolve a few cases of metaclass incompatibility
  when you set the superclasses for a class, in addition to the cases that
  C<Class::MOP> handles.
  
  Moose tries to determine if the metaclasses only "differ by roles". This
  means that the parent and child's metaclass share a common ancestor in
  their respective hierarchies, and that the subclasses under the common
  ancestor are only different because of role applications. This case is
  actually fairly common when you mix and match various C<MooseX::*>
  modules, many of which apply roles to the metaclass.
  
  If the parent and child do differ by roles, Moose replaces the
  metaclass in the child with a newly created metaclass. This metaclass
  is a subclass of the parent's metaclass which does all of the roles that
  the child's metaclass did before being replaced. Effectively, this
  means the new metaclass does all of the roles done by both the
  parent's and child's original metaclasses.
  
  Ultimately, this is all transparent to you except in the case of an
  unresolvable conflict.
  
  =head1 CAVEATS
  
  =over 4
  
  =item *
  
  It should be noted that C<super> and C<inner> B<cannot> be used in the same
  method. However, they may be combined within the same class hierarchy; see
  F<t/basics/override_augment_inner_super.t> for an example.
  
  The reason for this is that C<super> is only valid within a method
  with the C<override> modifier, and C<inner> will never be valid within an
  C<override> method. In fact, C<augment> will skip over any C<override> methods
  when searching for its appropriate C<inner>.
  
  This might seem like a restriction, but I am of the opinion that keeping these
  two features separate (yet interoperable) actually makes them easy to use, since
  their behavior is then easier to predict. Time will tell whether I am right or
  not (UPDATE: so far so good).
  
  =back
  
  =head1 GETTING HELP
  
  We offer both a mailing list and a very active IRC channel.
  
  The mailing list is L<moose@perl.org>. You must be subscribed to send
  a message. To subscribe, send an empty message to
  L<moose-subscribe@perl.org>
  
  You can also visit us at C<#moose> on L<irc://irc.perl.org/#moose>
  This channel is quite active, and questions at all levels (on Moose-related
  topics ;) are welcome.
  
  =head1 ACKNOWLEDGEMENTS
  
  =over 4
  
  =item I blame Sam Vilain for introducing me to the insanity that is meta-models.
  
  =item I blame Audrey Tang for then encouraging my meta-model habit in #perl6.
  
  =item Without Yuval "nothingmuch" Kogman this module would not be possible,
  and it certainly wouldn't have this name ;P
  
  =item The basis of the TypeContraints module was Rob Kinyon's idea
  originally, I just ran with it.
  
  =item Thanks to mst & chansen and the whole #moose posse for all the
  early ideas/feature-requests/encouragement/bug-finding.
  
  =item Thanks to David "Theory" Wheeler for meta-discussions and spelling fixes.
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<http://www.iinteractive.com/moose>
  
  This is the official web home of Moose. It contains links to our public git
  repository, as well as links to a number of talks and articles on Moose and
  Moose related technologies.
  
  =item the L<Moose manual|Moose::Manual>
  
  This is an introduction to Moose which covers most of the basics.
  
  =item Modern Perl, by chromatic
  
  This is an introduction to modern Perl programming, which includes a section on
  Moose. It is available in print and as a free download from
  L<http://onyxneon.com/books/modern_perl/>.
  
  =item The Moose is flying, a tutorial by Randal Schwartz
  
  Part 1 - L<http://www.stonehenge.com/merlyn/LinuxMag/col94.html>
  
  Part 2 - L<http://www.stonehenge.com/merlyn/LinuxMag/col95.html>
  
  =item Several Moose extension modules in the C<MooseX::> namespace.
  
  See L<http://search.cpan.org/search?query=MooseX::> for extensions.
  
  =back
  
  =head2 Books
  
  =over 4
  
  =item The Art of the MetaObject Protocol
  
  I mention this in the L<Class::MOP> docs too, as this book was critical in
  the development of both modules and is highly recommended.
  
  =back
  
  =head2 Papers
  
  =over 4
  
  =item L<http://www.cs.utah.edu/plt/publications/oopsla04-gff.pdf>
  
  This paper (suggested by lbr on #moose) was what lead to the implementation
  of the C<super>/C<override> and C<inner>/C<augment> features. If you really
  want to understand them, I suggest you read this.
  
  =back
  
  =head1 BUGS
  
  All complex software has bugs lurking in it, and this module is no
  exception.
  
  Please report any bugs to C<bug-moose@rt.cpan.org>, or through the web
  interface at L<http://rt.cpan.org>.
  
  You can also discuss feature requests or possible bugs on the Moose mailing
  list (moose@perl.org) or on IRC at L<irc://irc.perl.org/#moose>.
  
  =head1 FEATURE REQUESTS
  
  We are very strict about what features we add to the Moose core, especially
  the user-visible features. Instead we have made sure that the underlying
  meta-system of Moose is as extensible as possible so that you can add your
  own features easily.
  
  That said, occasionally there is a feature needed in the meta-system
  to support your planned extension, in which case you should either
  email the mailing list (moose@perl.org) or join us on IRC at
  L<irc://irc.perl.org/#moose> to discuss. The
  L<Moose::Manual::Contributing> has more detail about how and when you
  can contribute.
  
  =head1 CABAL
  
  There are only a few people with the rights to release a new version
  of Moose. The Moose Cabal are the people to go to with questions regarding
  the wider purview of Moose. They help maintain not just the code
  but the community as well.
  
  Stevan (stevan) Little E<lt>stevan@iinteractive.comE<gt>
  
  Jesse (doy) Luehrs E<lt>doy at tozt dot netE<gt>
  
  Yuval (nothingmuch) Kogman
  
  Shawn (sartak) Moore E<lt>sartak@bestpractical.comE<gt>
  
  Hans Dieter (confound) Pearcey E<lt>hdp@pobox.comE<gt>
  
  Chris (perigrin) Prather
  
  Florian Ragwitz E<lt>rafl@debian.orgE<gt>
  
  Dave (autarch) Rolsky E<lt>autarch@urth.orgE<gt>
  
  =head1 CONTRIBUTORS
  
  Moose is a community project, and as such, involves the work of many, many
  members of the community beyond just the members in the cabal. In particular:
  
  Dave (autarch) Rolsky wrote most of the documentation in L<Moose::Manual>.
  
  John (jgoulah) Goulah wrote L<Moose::Cookbook::Snack::Keywords>.
  
  Jess (castaway) Robinson wrote L<Moose::Cookbook::Snack::Types>.
  
  Aran (bluefeet) Clary Deltac wrote L<Moose::Cookbook::Basics::Recipe9>.
  
  Anders (Debolaz) Nor Berle contributed L<Test::Moose> and L<Moose::Util>.
  
  Also, the code in L<Moose::Meta::Attribute::Native> is based on code from the
  L<MooseX::AttributeHelpers> distribution, which had contributions from:
  
  Chris (perigrin) Prather
  
  Cory (gphat) Watson
  
  Evan Carroll
  
  Florian (rafl) Ragwitz
  
  Jason May
  
  Jay Hannah
  
  Jesse (doy) Luehrs
  
  Paul (frodwith) Driver
  
  Robert (rlb3) Boone
  
  Robert Buels
  
  Robert (phaylon) Sedlacek
  
  Shawn (Sartak) Moore
  
  Stevan Little
  
  Tom (dec) Lanyon
  
  Yuval Kogman
  
  Finally, these people also contributed various tests, bug fixes,
  documentation, and features to the Moose codebase:
  
  Aankhen
  
  Adam (Alias) Kennedy
  
  Christian (chansen) Hansen
  
  Cory (gphat) Watson
  
  Dylan Hardison (doc fixes)
  
  Eric (ewilhelm) Wilhelm
  
  Evan Carroll
  
  Guillermo (groditi) Roditi
  
  Jason May
  
  Jay Hannah
  
  Jonathan (jrockway) Rockway
  
  Matt (mst) Trout
  
  Nathan (kolibrie) Gray
  
  Paul (frodwith) Driver
  
  Piotr (dexter) Roszatycki
  
  Robert Buels
  
  Robert (phaylon) Sedlacek
  
  Robert (rlb3) Boone
  
  Sam (mugwump) Vilain
  
  Scott (konobi) McWhirter
  
  Shlomi (rindolf) Fish
  
  Tom (dec) Lanyon
  
  Wallace (wreis) Reis
  
  ... and many other #moose folks
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE

$fatpacked{"i686-linux/Moose/Conflicts.pm"} = <<'I686-LINUX_MOOSE_CONFLICTS';
  package # hide from PAUSE
      Moose::Conflicts;
  
  use strict;
  use warnings;
  
  use Dist::CheckConflicts
      -dist      => 'Moose',
      -conflicts => {
          'Catalyst' => '5.80028',
          'Devel::REPL' => '1.003008',
          'Fey' => '0.36',
          'Fey::ORM' => '0.42',
          'File::ChangeNotify' => '0.15',
          'KiokuDB' => '0.51',
          'Markdent' => '0.16',
          'MooseX::Aliases' => '0.08',
          'MooseX::AlwaysCoerce' => '0.13',
          'MooseX::Attribute::Deflator' => '2.1.7',
          'MooseX::Attribute::Dependent' => '1.1.0',
          'MooseX::Attribute::Prototype' => '0.10',
          'MooseX::AttributeHelpers' => '0.22',
          'MooseX::AttributeIndexes' => '1.0.0',
          'MooseX::AttributeInflate' => '0.02',
          'MooseX::CascadeClearing' => '0.03',
          'MooseX::ClassAttribute' => '0.25',
          'MooseX::Constructor::AllErrors' => '0.012',
          'MooseX::FollowPBP' => '0.02',
          'MooseX::HasDefaults' => '0.02',
          'MooseX::InstanceTracking' => '0.04',
          'MooseX::LazyRequire' => '0.06',
          'MooseX::Meta::Attribute::Index' => '0.04',
          'MooseX::Meta::Attribute::Lvalue' => '0.05',
          'MooseX::MethodAttributes' => '0.22',
          'MooseX::NonMoose' => '0.17',
          'MooseX::POE' => '0.211',
          'MooseX::Params::Validate' => '0.05',
          'MooseX::PrivateSetters' => '0.03',
          'MooseX::Role::Cmd' => '0.06',
          'MooseX::Role::Parameterized' => '0.23',
          'MooseX::Role::WithOverloading' => '0.07',
          'MooseX::SemiAffordanceAccessor' => '0.05',
          'MooseX::SetOnce' => '0.100473',
          'MooseX::Singleton' => '0.25',
          'MooseX::SlurpyConstructor' => '1.1',
          'MooseX::StrictConstructor' => '0.12',
          'MooseX::Types' => '0.19',
          'MooseX::Types::Parameterizable' => '0.05',
          'MooseX::Types::Signal' => '1.101930',
          'MooseX::UndefTolerant' => '0.11',
          'PRANG' => '0.14',
          'Pod::Elemental' => '0.093280',
          'Reaction' => '0.002003',
          'Test::Able' => '0.10',
          'namespace::autoclean' => '0.08',
      },
      -also => [ qw(
          Class::Load
          Class::Load::XS
          Data::OptList
          Devel::GlobalDestruction
          Dist::CheckConflicts
          Eval::Closure
          List::MoreUtils
          MRO::Compat
          Package::DeprecationManager
          Package::Stash
          Package::Stash::XS
          Params::Util
          Scalar::Util
          Sub::Exporter
          Sub::Name
          Task::Weaken
          Try::Tiny
      ) ],
  
  ;
  
  1;
I686-LINUX_MOOSE_CONFLICTS

$fatpacked{"i686-linux/Moose/Deprecated.pm"} = <<'I686-LINUX_MOOSE_DEPRECATED';
  package Moose::Deprecated;
  BEGIN {
    $Moose::Deprecated::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Deprecated::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Package::DeprecationManager 0.07 -deprecations => {
      'optimized type constraint sub ref' => '2.0000',
      'default is for Native Trait'       => '1.14',
      'default default for Native Trait'  => '1.14',
      'coerce without coercion'           => '1.08',
      },
      -ignore => [qr/^(?:Class::MOP|Moose)(?:::)?/],
      ;
  
  1;
  
  # ABSTRACT: Manages deprecation warnings for Moose
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Deprecated - Manages deprecation warnings for Moose
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
      use Moose::Deprecated -api_version => $version;
  
  =head1 FUNCTIONS
  
  This module manages deprecation warnings for features that have been
  deprecated in Moose.
  
  If you specify C<< -api_version => $version >>, you can use deprecated features
  without warnings. Note that this special treatment is limited to the package
  that loads C<Moose::Deprecated>.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_DEPRECATED

$fatpacked{"i686-linux/Moose/Error/Confess.pm"} = <<'I686-LINUX_MOOSE_ERROR_CONFESS';
  package Moose::Error::Confess;
  BEGIN {
    $Moose::Error::Confess::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Error::Confess::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use base qw(Moose::Error::Default);
  
  sub new {
      my ( $self, @args ) = @_;
      $self->create_error_confess(@args);
  }
  
  sub _inline_new {
      my ( $self, %args ) = @_;
  
      my $depth = ($args{depth} || 0) - 1;
      return 'Moose::Error::Util::create_error_confess('
        . 'message => ' . $args{message} . ', '
        . 'depth   => ' . $depth         . ', '
    . ')';
  }
  
  1;
  
  # ABSTRACT: Prefer C<confess>
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Error::Confess - Prefer C<confess>
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 SYNOPSIS
  
      # Metaclass definition must come before Moose is used.
      use metaclass (
          metaclass => 'Moose::Meta::Class',
          error_class => 'Moose::Error::Confess',
      );
      use Moose;
      # ...
  
  =head1 DESCRIPTION
  
  This error class uses L<Carp/confess> to raise errors generated in your
  metaclass.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
  
  
  
I686-LINUX_MOOSE_ERROR_CONFESS

$fatpacked{"i686-linux/Moose/Error/Croak.pm"} = <<'I686-LINUX_MOOSE_ERROR_CROAK';
  package Moose::Error::Croak;
  BEGIN {
    $Moose::Error::Croak::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Error::Croak::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use base qw(Moose::Error::Default);
  
  sub new {
      my ( $self, @args ) = @_;
      $self->create_error_croak(@args);
  }
  
  sub _inline_new {
      my ( $self, %args ) = @_;
  
      my $depth = ($args{depth} || 0) - 1;
      return 'Moose::Error::Util::create_error_croak('
        . 'message => ' . $args{message} . ', '
        . 'depth   => ' . $depth         . ', '
    . ')';
  }
  
  1;
  
  # ABSTRACT: Prefer C<croak>
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Error::Croak - Prefer C<croak>
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 SYNOPSIS
  
      # Metaclass definition must come before Moose is used.
      use metaclass (
          metaclass => 'Moose::Meta::Class',
          error_class => 'Moose::Error::Croak',
      );
      use Moose;
      # ...
  
  =head1 DESCRIPTION
  
  This error class uses L<Carp/croak> to raise errors generated in your
  metaclass.
  
  =head1 METHODS
  
  =over 4
  
  =item new
  
  Overrides L<Moose::Error::Default/new> to prefer C<croak>.
  
  =back
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
  
  
I686-LINUX_MOOSE_ERROR_CROAK

$fatpacked{"i686-linux/Moose/Error/Default.pm"} = <<'I686-LINUX_MOOSE_ERROR_DEFAULT';
  package Moose::Error::Default;
  BEGIN {
    $Moose::Error::Default::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Error::Default::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Carp::Heavy;
  use Class::MOP::MiniTrait;
  
  use Moose::Error::Util;
  
  use base 'Class::MOP::Object';
  
  Class::MOP::MiniTrait::apply(__PACKAGE__, 'Moose::Meta::Object::Trait');
  
  sub new {
      my ( $self, @args ) = @_;
      # can't use Moose::Error::Util::create_error here because that would break
      # inheritance. we don't care about that for the inlined version, because
      # the inlined versions are explicitly not inherited.
      if (defined $ENV{MOOSE_ERROR_STYLE} && $ENV{MOOSE_ERROR_STYLE} eq 'croak') {
          $self->create_error_croak( @args );
      }
      else {
          $self->create_error_confess( @args );
      }
  }
  
  sub _inline_new {
      my ( $self, %args ) = @_;
  
      my $depth = ($args{depth} || 0) - 1;
      return 'Moose::Error::Util::create_error('
        . 'message => ' . $args{message} . ', '
        . 'depth   => ' . $depth         . ', '
    . ')';
  }
  
  sub create_error_croak {
      my ( $self, @args ) = @_;
      return Moose::Error::Util::create_error_croak(@args);
  }
  
  sub create_error_confess {
      my ( $self, @args ) = @_;
      return Moose::Error::Util::create_error_confess(@args);
  }
  
  1;
  
  # ABSTRACT: L<Carp> based error generation for Moose.
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Error::Default - L<Carp> based error generation for Moose.
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This class implements L<Carp> based error generation.
  
  The default behavior is like L<Moose::Error::Confess>. To override this to
  default to L<Moose::Error::Croak>'s behaviour on a system wide basis, set the
  MOOSE_ERROR_STYLE environment variable to C<croak>. The use of this
  environment variable is considered experimental, and may change in a future
  release.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Moose::Error::Default->new(@args) >>
  
  Create a new error. Delegates to C<create_error_confess> or
  C<create_error_croak>.
  
  =item B<< $error->create_error_confess(@args) >>
  
  =item B<< $error->create_error_croak(@args) >>
  
  Creates a new errors string of the specified style.
  
  =back
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
  
  
I686-LINUX_MOOSE_ERROR_DEFAULT

$fatpacked{"i686-linux/Moose/Error/Util.pm"} = <<'I686-LINUX_MOOSE_ERROR_UTIL';
  package # pretend this doesn't exist, because it shouldn't
      Moose::Error::Util;
  
  use strict;
  use warnings;
  
  # this intentionally exists to have a place to put this logic that doesn't
  # involve loading Class::MOP, so... don't do that
  
  use Carp::Heavy;
  
  sub _create_error_carpmess {
      my %args = @_;
  
      my $carp_level = 3 + ( $args{depth} || 0 );
      local $Carp::MaxArgNums = 20; # default is 8, usually we use named args which gets messier though
  
      my @args = exists $args{message} ? $args{message} : ();
  
      if ( $args{longmess} || $Carp::Verbose ) {
          local $Carp::CarpLevel = ( $Carp::CarpLevel || 0 ) + $carp_level;
          return Carp::longmess(@args);
      } else {
          return Carp::ret_summary($carp_level, @args);
      }
  }
  
  sub create_error_croak {
      _create_error_carpmess(@_);
  }
  
  sub create_error_confess {
      _create_error_carpmess(@_, longmess => 1);
  }
  
  sub create_error {
      if (defined $ENV{MOOSE_ERROR_STYLE} && $ENV{MOOSE_ERROR_STYLE} eq 'croak') {
          create_error_croak(@_);
      }
      else {
          create_error_confess(@_);
      }
  }
  
  1;
  
  __END__
  
  =pod
  
  =for pod_coverage_needs_some_pod
  
  =cut
  
I686-LINUX_MOOSE_ERROR_UTIL

$fatpacked{"i686-linux/Moose/Exporter.pm"} = <<'I686-LINUX_MOOSE_EXPORTER';
  package Moose::Exporter;
  BEGIN {
    $Moose::Exporter::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Exporter::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Class::Load qw(is_class_loaded);
  use Class::MOP;
  use List::MoreUtils qw( first_index uniq );
  use Moose::Util::MetaRole;
  use Scalar::Util qw(reftype);
  use Sub::Exporter 0.980;
  use Sub::Name qw(subname);
  
  my %EXPORT_SPEC;
  
  sub setup_import_methods {
      my ( $class, %args ) = @_;
  
      $args{exporting_package} ||= caller();
  
      $class->build_import_methods(
          %args,
          install => [qw(import unimport init_meta)]
      );
  }
  
  sub build_import_methods {
      my ( $class, %args ) = @_;
  
      my $exporting_package = $args{exporting_package} ||= caller();
  
      my $meta_lookup = $args{meta_lookup} || sub { Class::MOP::class_of(shift) };
  
      $EXPORT_SPEC{$exporting_package} = \%args;
  
      my @exports_from = $class->_follow_also($exporting_package);
  
      my $export_recorder = {};
      my $is_reexport     = {};
  
      my $exports = $class->_make_sub_exporter_params(
          [ @exports_from, $exporting_package ],
          $export_recorder,
          $is_reexport,
          $meta_lookup,
      );
  
      my $exporter = $class->_make_exporter(
          $exports,
          $is_reexport,
          $meta_lookup,
      );
  
      my %methods;
      $methods{import} = $class->_make_import_sub(
          $exporting_package,
          $exporter,
          \@exports_from,
          $is_reexport,
          $meta_lookup,
      );
  
      $methods{unimport} = $class->_make_unimport_sub(
          $exporting_package,
          $exports,
          $export_recorder,
          $is_reexport,
          $meta_lookup,
      );
  
      $methods{init_meta} = $class->_make_init_meta(
          $exporting_package,
          \%args,
          $meta_lookup,
      );
  
      my $package = Class::MOP::Package->initialize($exporting_package);
      for my $to_install ( @{ $args{install} || [] } ) {
          my $symbol = '&' . $to_install;
          next
              unless $methods{$to_install}
                  && !$package->has_package_symbol($symbol);
          $package->add_package_symbol( $symbol, $methods{$to_install} );
      }
  
      return ( $methods{import}, $methods{unimport}, $methods{init_meta} );
  }
  
  sub _make_exporter {
      my ($class, $exports, $is_reexport, $meta_lookup) = @_;
  
      return Sub::Exporter::build_exporter(
          {
              exports   => $exports,
              groups    => { default => [':all'] },
              installer => sub {
                  my ($arg, $to_export) = @_;
                  my $meta = $meta_lookup->($arg->{into});
  
                  goto &Sub::Exporter::default_installer unless $meta;
  
                  # don't overwrite existing symbols with our magically flagged
                  # version of it if we would install the same sub that's already
                  # in the importer
  
                  my @filtered_to_export;
                  my %installed;
                  for (my $i = 0; $i < @{ $to_export }; $i += 2) {
                      my ($as, $cv) = @{ $to_export }[$i, $i + 1];
  
                      next if !ref($as)
                           && $meta->has_package_symbol('&' . $as)
                           && $meta->get_package_symbol('&' . $as) == $cv;
  
                      push @filtered_to_export, $as, $cv;
                      $installed{$as} = 1 unless ref $as;
                  }
  
                  Sub::Exporter::default_installer($arg, \@filtered_to_export);
  
                  for my $name ( keys %{$is_reexport} ) {
                      no strict 'refs';
                      no warnings 'once';
                      next unless exists $installed{$name};
                      _flag_as_reexport( \*{ join q{::}, $arg->{into}, $name } );
                  }
              },
          }
      );
  }
  
  {
      my $seen = {};
  
      sub _follow_also {
          my $class             = shift;
          my $exporting_package = shift;
  
          local %$seen = ( $exporting_package => 1 );
  
          return reverse uniq( _follow_also_real($exporting_package) );
      }
  
      sub _follow_also_real {
          my $exporting_package = shift;
  
          if ( !exists $EXPORT_SPEC{$exporting_package} ) {
              my $loaded = is_class_loaded($exporting_package);
  
              die "Package in also ($exporting_package) does not seem to "
                  . "use Moose::Exporter"
                  . ( $loaded ? "" : " (is it loaded?)" );
          }
  
          my $also = $EXPORT_SPEC{$exporting_package}{also};
  
          return unless defined $also;
  
          my @also = ref $also ? @{$also} : $also;
  
          for my $package (@also) {
              die
                  "Circular reference in 'also' parameter to Moose::Exporter between $exporting_package and $package"
                  if $seen->{$package};
  
              $seen->{$package} = 1;
          }
  
          return @also, map { _follow_also_real($_) } @also;
      }
  }
  
  sub _parse_trait_aliases {
      my $class   = shift;
      my ($package, $aliases) = @_;
  
      my @ret;
      for my $alias (@$aliases) {
          my $name;
          if (ref($alias)) {
              reftype($alias) eq 'ARRAY'
                  or Moose->throw_error(reftype($alias) . " references are not "
                                      . "valid arguments to the 'trait_aliases' "
                                      . "option");
  
              ($alias, $name) = @$alias;
          }
          else {
              ($name = $alias) =~ s/.*:://;
          }
          push @ret, subname "${package}::${name}" => sub () { $alias };
      }
  
      return @ret;
  }
  
  sub _make_sub_exporter_params {
      my $class           = shift;
      my $packages        = shift;
      my $export_recorder = shift;
      my $is_reexport     = shift;
      my $meta_lookup     = shift;
  
      my %exports;
  
      for my $package ( @{$packages} ) {
          my $args = $EXPORT_SPEC{$package}
              or die "The $package package does not use Moose::Exporter\n";
  
          for my $name ( @{ $args->{with_meta} } ) {
              my $sub = $class->_sub_from_package( $package, $name )
                  or next;
  
              my $fq_name = $package . '::' . $name;
  
              $exports{$name} = $class->_make_wrapped_sub_with_meta(
                  $fq_name,
                  $sub,
                  $export_recorder,
                  $meta_lookup,
              );
          }
  
          for my $name ( @{ $args->{with_caller} } ) {
              my $sub = $class->_sub_from_package( $package, $name )
                  or next;
  
              my $fq_name = $package . '::' . $name;
  
              $exports{$name} = $class->_make_wrapped_sub(
                  $fq_name,
                  $sub,
                  $export_recorder,
              );
          }
  
          my @extra_exports = $class->_parse_trait_aliases(
              $package, $args->{trait_aliases},
          );
          for my $name ( @{ $args->{as_is} }, @extra_exports ) {
              my ( $sub, $coderef_name );
  
              if ( ref $name ) {
                  $sub = $name;
  
                  my $coderef_pkg;
                  ( $coderef_pkg, $coderef_name )
                      = Class::MOP::get_code_info($name);
  
                  if ( $coderef_pkg ne $package ) {
                      $is_reexport->{$coderef_name} = 1;
                  }
              }
              else {
                  $sub = $class->_sub_from_package( $package, $name )
                      or next;
  
                  $coderef_name = $name;
              }
  
              $export_recorder->{$sub} = 1;
  
              $exports{$coderef_name} = sub {$sub};
          }
      }
  
      return \%exports;
  }
  
  sub _sub_from_package {
      my $sclass  = shift;
      my $package = shift;
      my $name    = shift;
  
      my $sub = do {
          no strict 'refs';
          \&{ $package . '::' . $name };
      };
  
      return $sub if defined &$sub;
  
      Carp::cluck "Trying to export undefined sub ${package}::${name}";
  
      return;
  }
  
  our $CALLER;
  
  sub _make_wrapped_sub {
      my $self            = shift;
      my $fq_name         = shift;
      my $sub             = shift;
      my $export_recorder = shift;
  
      # We need to set the package at import time, so that when
      # package Foo imports has(), we capture "Foo" as the
      # package. This lets other packages call Foo::has() and get
      # the right package. This is done for backwards compatibility
      # with existing production code, not because this is a good
      # idea ;)
      return sub {
          my $caller = $CALLER;
  
          my $wrapper = $self->_curry_wrapper( $sub, $fq_name, $caller );
  
          my $sub = subname( $fq_name => $wrapper );
  
          $export_recorder->{$sub} = 1;
  
          return $sub;
      };
  }
  
  sub _make_wrapped_sub_with_meta {
      my $self            = shift;
      my $fq_name         = shift;
      my $sub             = shift;
      my $export_recorder = shift;
      my $meta_lookup     = shift;
  
      return sub {
          my $caller = $CALLER;
  
          my $wrapper = $self->_late_curry_wrapper(
              $sub, $fq_name,
              $meta_lookup => $caller
          );
  
          my $sub = subname( $fq_name => $wrapper );
  
          $export_recorder->{$sub} = 1;
  
          return $sub;
      };
  }
  
  sub _curry_wrapper {
      my $class   = shift;
      my $sub     = shift;
      my $fq_name = shift;
      my @extra   = @_;
  
      my $wrapper = sub { $sub->( @extra, @_ ) };
      if ( my $proto = prototype $sub ) {
  
          # XXX - Perl's prototype sucks. Use & to make set_prototype
          # ignore the fact that we're passing "private variables"
          &Scalar::Util::set_prototype( $wrapper, $proto );
      }
      return $wrapper;
  }
  
  sub _late_curry_wrapper {
      my $class   = shift;
      my $sub     = shift;
      my $fq_name = shift;
      my $extra   = shift;
      my @ex_args = @_;
  
      my $wrapper = sub {
  
          # resolve curried arguments at runtime via this closure
          my @curry = ( $extra->(@ex_args) );
          return $sub->( @curry, @_ );
      };
  
      if ( my $proto = prototype $sub ) {
  
          # XXX - Perl's prototype sucks. Use & to make set_prototype
          # ignore the fact that we're passing "private variables"
          &Scalar::Util::set_prototype( $wrapper, $proto );
      }
      return $wrapper;
  }
  
  sub _make_import_sub {
      shift;
      my $exporting_package = shift;
      my $exporter          = shift;
      my $exports_from      = shift;
      my $is_reexport       = shift;
      my $meta_lookup       = shift;
  
      return sub {
  
          # I think we could use Sub::Exporter's collector feature
          # to do this, but that would be rather gross, since that
          # feature isn't really designed to return a value to the
          # caller of the exporter sub.
          #
          # Also, this makes sure we preserve backwards compat for
          # _get_caller, so it always sees the arguments in the
          # expected order.
          my $traits;
          ( $traits, @_ ) = _strip_traits(@_);
  
          my $metaclass;
          ( $metaclass, @_ ) = _strip_metaclass(@_);
          $metaclass
              = Moose::Util::resolve_metaclass_alias( 'Class' => $metaclass )
              if defined $metaclass && length $metaclass;
  
          my $meta_name;
          ( $meta_name, @_ ) = _strip_meta_name(@_);
  
          # Normally we could look at $_[0], but in some weird cases
          # (involving goto &Moose::import), $_[0] ends as something
          # else (like Squirrel).
          my $class = $exporting_package;
  
          $CALLER = _get_caller(@_);
  
          # this works because both pragmas set $^H (see perldoc
          # perlvar) which affects the current compilation -
          # i.e. the file who use'd us - which is why we don't need
          # to do anything special to make it affect that file
          # rather than this one (which is already compiled)
  
          strict->import;
          warnings->import;
  
          my $did_init_meta;
          for my $c ( grep { $_->can('init_meta') } $class, @{$exports_from} ) {
  
              # init_meta can apply a role, which when loaded uses
              # Moose::Exporter, which in turn sets $CALLER, so we need
              # to protect against that.
              local $CALLER = $CALLER;
              $c->init_meta(
                  for_class => $CALLER,
                  metaclass => $metaclass,
                  meta_name => $meta_name,
              );
              $did_init_meta = 1;
          }
  
          if ( $did_init_meta && @{$traits} ) {
  
              # The traits will use Moose::Role, which in turn uses
              # Moose::Exporter, which in turn sets $CALLER, so we need
              # to protect against that.
              local $CALLER = $CALLER;
              _apply_meta_traits( $CALLER, $traits, $meta_lookup );
          }
          elsif ( @{$traits} ) {
              require Moose;
              Moose->throw_error(
                  "Cannot provide traits when $class does not have an init_meta() method"
              );
          }
  
          my ( undef, @args ) = @_;
          my $extra = shift @args if ref $args[0] eq 'HASH';
  
          $extra ||= {};
          if ( !$extra->{into} ) {
              $extra->{into_level} ||= 0;
              $extra->{into_level}++;
          }
  
          $class->$exporter( $extra, @args );
      };
  }
  
  sub _strip_traits {
      my $idx = first_index { ( $_ || '' ) eq '-traits' } @_;
  
      return ( [], @_ ) unless $idx >= 0 && $#_ >= $idx + 1;
  
      my $traits = $_[ $idx + 1 ];
  
      splice @_, $idx, 2;
  
      $traits = [$traits] unless ref $traits;
  
      return ( $traits, @_ );
  }
  
  sub _strip_metaclass {
      my $idx = first_index { ( $_ || '' ) eq '-metaclass' } @_;
  
      return ( undef, @_ ) unless $idx >= 0 && $#_ >= $idx + 1;
  
      my $metaclass = $_[ $idx + 1 ];
  
      splice @_, $idx, 2;
  
      return ( $metaclass, @_ );
  }
  
  sub _strip_meta_name {
      my $idx = first_index { ( $_ || '' ) eq '-meta_name' } @_;
  
      return ( 'meta', @_ ) unless $idx >= 0 && $#_ >= $idx + 1;
  
      my $meta_name = $_[ $idx + 1 ];
  
      splice @_, $idx, 2;
  
      return ( $meta_name, @_ );
  }
  
  sub _apply_meta_traits {
      my ( $class, $traits, $meta_lookup ) = @_;
  
      return unless @{$traits};
  
      my $meta = $meta_lookup->($class);
  
      my $type = ( split /::/, ref $meta )[-1]
          or Moose->throw_error(
          'Cannot determine metaclass type for trait application . Meta isa '
              . ref $meta );
  
      my @resolved_traits = map {
          ref $_
              ? $_
              : Moose::Util::resolve_metatrait_alias( $type => $_ )
      } @$traits;
  
      return unless @resolved_traits;
  
      my %args = ( for => $class );
  
      if ( $meta->isa('Moose::Meta::Role') ) {
          $args{role_metaroles} = { role => \@resolved_traits };
      }
      else {
          $args{class_metaroles} = { class => \@resolved_traits };
      }
  
      Moose::Util::MetaRole::apply_metaroles(%args);
  }
  
  sub _get_caller {
  
      # 1 extra level because it's called by import so there's a layer
      # of indirection
      my $offset = 1;
  
      return
            ( ref $_[1] && defined $_[1]->{into} ) ? $_[1]->{into}
          : ( ref $_[1] && defined $_[1]->{into_level} )
          ? caller( $offset + $_[1]->{into_level} )
          : caller($offset);
  }
  
  sub _make_unimport_sub {
      shift;
      my $exporting_package = shift;
      my $exports           = shift;
      my $export_recorder   = shift;
      my $is_reexport       = shift;
      my $meta_lookup       = shift;
  
      return sub {
          my $caller = scalar caller();
          Moose::Exporter->_remove_keywords(
              $caller,
              [ keys %{$exports} ],
              $export_recorder,
              $is_reexport,
          );
      };
  }
  
  sub _remove_keywords {
      shift;
      my $package          = shift;
      my $keywords         = shift;
      my $recorded_exports = shift;
      my $is_reexport      = shift;
  
      no strict 'refs';
  
      foreach my $name ( @{$keywords} ) {
          if ( defined &{ $package . '::' . $name } ) {
              my $sub = \&{ $package . '::' . $name };
  
              # make sure it is from us
              next unless $recorded_exports->{$sub};
  
              if ( $is_reexport->{$name} ) {
                  no strict 'refs';
                  next
                      unless _export_is_flagged(
                              \*{ join q{::} => $package, $name } );
              }
  
              # and if it is from us, then undef the slot
              delete ${ $package . '::' }{$name};
          }
      }
  }
  
  sub _make_init_meta {
      shift;
      my $class          = shift;
      my $args           = shift;
      my $meta_lookup    = shift;
  
      my %old_style_roles;
      for my $role (
          map {"${_}_roles"}
          qw(
          metaclass
          attribute_metaclass
          method_metaclass
          wrapped_method_metaclass
          instance_metaclass
          constructor_class
          destructor_class
          error_class
          )
          ) {
          $old_style_roles{$role} = $args->{$role}
              if exists $args->{$role};
      }
  
      my %base_class_roles;
      %base_class_roles = ( roles => $args->{base_class_roles} )
          if exists $args->{base_class_roles};
  
      my %new_style_roles = map { $_ => $args->{$_} }
          grep { exists $args->{$_} } qw( class_metaroles role_metaroles );
  
      return unless %new_style_roles || %old_style_roles || %base_class_roles;
  
      return sub {
          shift;
          my %options = @_;
  
          return unless $meta_lookup->( $options{for_class} );
  
          if ( %new_style_roles || %old_style_roles ) {
              Moose::Util::MetaRole::apply_metaroles(
                  for => $options{for_class},
                  %new_style_roles,
                  %old_style_roles,
              );
          }
  
          Moose::Util::MetaRole::apply_base_class_roles(
              for_class => $options{for_class},
              %base_class_roles,
              )
              if $meta_lookup->( $options{for_class} )
                  ->isa('Moose::Meta::Class');
  
          return $meta_lookup->( $options{for_class} );
      };
  }
  
  sub import {
      strict->import;
      warnings->import;
  }
  
  1;
  
  # ABSTRACT: make an import() and unimport() just like Moose.pm
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Exporter - make an import() and unimport() just like Moose.pm
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 SYNOPSIS
  
    package MyApp::Moose;
  
    use Moose ();
    use Moose::Exporter;
  
    Moose::Exporter->setup_import_methods(
        with_meta => [ 'has_rw', 'sugar2' ],
        as_is     => [ 'sugar3', \&Some::Random::thing ],
        also      => 'Moose',
    );
  
    sub has_rw {
        my ( $meta, $name, %options ) = @_;
        $meta->add_attribute(
            $name,
            is => 'rw',
            %options,
        );
    }
  
    # then later ...
    package MyApp::User;
  
    use MyApp::Moose;
  
    has 'name';
    has_rw 'size';
    thing;
  
    no MyApp::Moose;
  
  =head1 DESCRIPTION
  
  This module encapsulates the exporting of sugar functions in a
  C<Moose.pm>-like manner. It does this by building custom C<import>,
  C<unimport>, and C<init_meta> methods for your module, based on a spec you
  provide.
  
  It also lets you "stack" Moose-alike modules so you can export Moose's sugar
  as well as your own, along with sugar from any random C<MooseX> module, as
  long as they all use C<Moose::Exporter>. This feature exists to let you bundle
  a set of MooseX modules into a policy module that developers can use directly
  instead of using Moose itself.
  
  To simplify writing exporter modules, C<Moose::Exporter> also imports
  C<strict> and C<warnings> into your exporter module, as well as into
  modules that use it.
  
  =head1 METHODS
  
  This module provides two public methods:
  
  =over 4
  
  =item B<< Moose::Exporter->setup_import_methods(...) >>
  
  When you call this method, C<Moose::Exporter> builds custom C<import>,
  C<unimport>, and C<init_meta> methods for your module. The C<import> method
  will export the functions you specify, and can also re-export functions
  exported by some other module (like C<Moose.pm>).
  
  The C<unimport> method cleans the caller's namespace of all the exported
  functions. This includes any functions you re-export from other
  packages. However, if the consumer of your package also imports those
  functions from the original package, they will I<not> be cleaned.
  
  If you pass any parameters for L<Moose::Util::MetaRole>, this method will
  generate an C<init_meta> for you as well (see below for details). This
  C<init_meta> will call C<Moose::Util::MetaRole::apply_metaroles> and
  C<Moose::Util::MetaRole::apply_base_class_roles> as needed.
  
  Note that if any of these methods already exist, they will not be
  overridden, you will have to use C<build_import_methods> to get the
  coderef that would be installed.
  
  This method accepts the following parameters:
  
  =over 8
  
  =item * with_meta => [ ... ]
  
  This list of function I<names only> will be wrapped and then exported. The
  wrapper will pass the metaclass object for the caller as its first argument.
  
  Many sugar functions will need to use this metaclass object to do something to
  the calling package.
  
  =item * as_is => [ ... ]
  
  This list of function names or sub references will be exported as-is. You can
  identify a subroutine by reference, which is handy to re-export some other
  module's functions directly by reference (C<\&Some::Package::function>).
  
  If you do export some other package's function, this function will never be
  removed by the C<unimport> method. The reason for this is we cannot know if
  the caller I<also> explicitly imported the sub themselves, and therefore wants
  to keep it.
  
  =item * trait_aliases => [ ... ]
  
  This is a list of package names which should have shortened aliases exported,
  similar to the functionality of L<aliased>. Each element in the list can be
  either a package name, in which case the export will be named as the last
  namespace component of the package, or an arrayref, whose first element is the
  package to alias to, and second element is the alias to export.
  
  =item * also => $name or \@names
  
  This is a list of modules which contain functions that the caller
  wants to export. These modules must also use C<Moose::Exporter>. The
  most common use case will be to export the functions from C<Moose.pm>.
  Functions specified by C<with_meta> or C<as_is> take precedence over
  functions exported by modules specified by C<also>, so that a module
  can selectively override functions exported by another module.
  
  C<Moose::Exporter> also makes sure all these functions get removed
  when C<unimport> is called.
  
  =item * meta_lookup => sub { ... }
  
  This is a function which will be called to provide the metaclass
  to be operated upon by the exporter. This is an advanced feature
  intended for use by package generator modules in the vein of
  L<MooseX::Role::Parameterized> in order to simplify reusing sugar
  from other modules that use C<Moose::Exporter>. This function is
  used, for example, to select the metaclass to bind to functions
  that are exported using the C<with_meta> option.
  
  This function will receive one parameter: the class name into which
  the sugar is being exported. The default implementation is:
  
      sub { Class::MOP::class_of(shift) }
  
  Accordingly, this function is expected to return a metaclass.
  
  =back
  
  You can also provide parameters for C<Moose::Util::MetaRole::apply_metaroles>
  and C<Moose::Util::MetaRole::base_class_roles>. Specifically, valid parameters
  are "class_metaroles", "role_metaroles", and "base_class_roles".
  
  =item B<< Moose::Exporter->build_import_methods(...) >>
  
  Returns two or three code refs, one for C<import>, one for
  C<unimport>, and optionally one for C<init_meta>, if the appropriate
  options are passed in.
  
  Accepts the additional C<install> option, which accepts an arrayref of method
  names to install into your exporting package. The valid options are C<import>,
  C<unimport>, and C<init_meta>. Calling C<setup_import_methods> is equivalent
  to calling C<build_import_methods> with C<< install => [qw(import unimport
  init_meta)] >> except that it doesn't also return the methods.
  
  The C<import> method is built using L<Sub::Exporter>. This means that it can
  take a hashref of the form C<< { into => $package } >> to specify the package
  it operates on.
  
  Used by C<setup_import_methods>.
  
  =back
  
  =head1 IMPORTING AND init_meta
  
  If you want to set an alternative base object class or metaclass class, see
  above for details on how this module can call L<Moose::Util::MetaRole> for
  you.
  
  If you want to do something that is not supported by this module, simply
  define an C<init_meta> method in your class. The C<import> method that
  C<Moose::Exporter> generates for you will call this method (if it exists). It
  will always pass the caller to this method via the C<for_class> parameter.
  
  Most of the time, your C<init_meta> method will probably just call C<<
  Moose->init_meta >> to do the real work:
  
    sub init_meta {
        shift; # our class name
        return Moose->init_meta( @_, metaclass => 'My::Metaclass' );
    }
  
  Keep in mind that C<build_import_methods> will return an C<init_meta>
  method for you, which you can also call from within your custom
  C<init_meta>:
  
    my ( $import, $unimport, $init_meta )
        = Moose::Exporter->build_import_methods(...);
  
    sub import {
        my $class = shift;
  
        ...
  
        # You can either pass an explicit package to import into ...
        $class->$import( { into => scalar(caller) }, ... );
  
        ...;
    }
  
    # ... or you can use 'goto' to provide the correct caller info to the
    # generated method
    sub unimport { goto &$unimport }
  
    sub init_meta {
        my $class = shift;
  
        ...
  
        $class->$init_meta(...);
  
        ...
    }
  
  =head1 METACLASS TRAITS
  
  The C<import> method generated by C<Moose::Exporter> will allow the
  user of your module to specify metaclass traits in a C<-traits>
  parameter passed as part of the import:
  
    use Moose -traits => 'My::Meta::Trait';
  
    use Moose -traits => [ 'My::Meta::Trait', 'My::Other::Trait' ];
  
  These traits will be applied to the caller's metaclass
  instance. Providing traits for an exporting class that does not create
  a metaclass for the caller is an error.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_EXPORTER

$fatpacked{"i686-linux/Moose/Meta/Attribute.pm"} = <<'I686-LINUX_MOOSE_META_ATTRIBUTE';
  
  package Moose::Meta::Attribute;
  BEGIN {
    $Moose::Meta::Attribute::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Attribute::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use B ();
  use Class::Load qw(is_class_loaded load_class);
  use Scalar::Util 'blessed', 'weaken';
  use List::MoreUtils 'any';
  use Try::Tiny;
  use overload     ();
  
  use Moose::Deprecated;
  use Moose::Meta::Method::Accessor;
  use Moose::Meta::Method::Delegation;
  use Moose::Util ();
  use Moose::Util::TypeConstraints ();
  use Class::MOP::MiniTrait;
  
  use base 'Class::MOP::Attribute', 'Moose::Meta::Mixin::AttributeCore';
  
  Class::MOP::MiniTrait::apply(__PACKAGE__, 'Moose::Meta::Object::Trait');
  
  __PACKAGE__->meta->add_attribute('traits' => (
      reader    => 'applied_traits',
      predicate => 'has_applied_traits',
      Class::MOP::_definition_context(),
  ));
  
  # we need to have a ->does method in here to
  # more easily support traits, and the introspection
  # of those traits. We extend the does check to look
  # for metatrait aliases.
  sub does {
      my ($self, $role_name) = @_;
      my $name = try {
          Moose::Util::resolve_metatrait_alias(Attribute => $role_name)
      };
      return 0 if !defined($name); # failed to load class
      return $self->Moose::Object::does($name);
  }
  
  sub _error_thrower {
      my $self = shift;
      require Moose::Meta::Class;
      ( ref $self && $self->associated_class ) || "Moose::Meta::Class";
  }
  
  sub throw_error {
      my $self = shift;
      my $inv = $self->_error_thrower;
      unshift @_, "message" if @_ % 2 == 1;
      unshift @_, attr => $self if ref $self;
      unshift @_, $inv;
      my $handler = $inv->can("throw_error"); # to avoid incrementing depth by 1
      goto $handler;
  }
  
  sub _inline_throw_error {
      my ( $self, $msg, $args ) = @_;
  
      my $inv = $self->_error_thrower;
      # XXX ugh
      $inv = 'Moose::Meta::Class' unless $inv->can('_inline_throw_error');
  
      # XXX ugh ugh UGH
      my $class = $self->associated_class;
      if ($class) {
          my $class_name = B::perlstring($class->name);
          my $attr_name = B::perlstring($self->name);
          $args = 'attr => Class::MOP::class_of(' . $class_name . ')'
                . '->find_attribute_by_name(' . $attr_name . '), '
                . (defined $args ? $args : '');
      }
  
      return $inv->_inline_throw_error($msg, $args)
  }
  
  sub new {
      my ($class, $name, %options) = @_;
      $class->_process_options($name, \%options) unless $options{__hack_no_process_options}; # used from clone()... YECHKKK FIXME ICKY YUCK GROSS
  
      delete $options{__hack_no_process_options};
  
      my %attrs =
          ( map { $_ => 1 }
            grep { defined }
            map { $_->init_arg() }
            $class->meta()->get_all_attributes()
          );
  
      my @bad = sort grep { ! $attrs{$_} }  keys %options;
  
      if (@bad)
      {
          Carp::cluck "Found unknown argument(s) passed to '$name' attribute constructor in '$class': @bad";
      }
  
      return $class->SUPER::new($name, %options);
  }
  
  sub interpolate_class_and_new {
      my ($class, $name, %args) = @_;
  
      my ( $new_class, @traits ) = $class->interpolate_class(\%args);
  
      $new_class->new($name, %args, ( scalar(@traits) ? ( traits => \@traits ) : () ) );
  }
  
  sub interpolate_class {
      my ($class, $options) = @_;
  
      $class = ref($class) || $class;
  
      if ( my $metaclass_name = delete $options->{metaclass} ) {
          my $new_class = Moose::Util::resolve_metaclass_alias( Attribute => $metaclass_name );
  
          if ( $class ne $new_class ) {
              if ( $new_class->can("interpolate_class") ) {
                  return $new_class->interpolate_class($options);
              } else {
                  $class = $new_class;
              }
          }
      }
  
      my @traits;
  
      if (my $traits = $options->{traits}) {
          my $i = 0;
          my $has_foreign_options = 0;
  
          while ($i < @$traits) {
              my $trait = $traits->[$i++];
              next if ref($trait); # options to a trait we discarded
  
              $trait = Moose::Util::resolve_metatrait_alias(Attribute => $trait)
                    || $trait;
  
              next if $class->does($trait);
  
              push @traits, $trait;
  
              # are there options?
              if ($traits->[$i] && ref($traits->[$i])) {
                  $has_foreign_options = 1
                      if any { $_ ne '-alias' && $_ ne '-excludes' } keys %{ $traits->[$i] };
  
                  push @traits, $traits->[$i++];
              }
          }
  
          if (@traits) {
              my %options = (
                  superclasses => [ $class ],
                  roles        => [ @traits ],
              );
  
              if ($has_foreign_options) {
                  $options{weaken} = 0;
              }
              else {
                  $options{cache} = 1;
              }
  
              my $anon_class = Moose::Meta::Class->create_anon_class(%options);
              $class = $anon_class->name;
          }
      }
  
      return ( wantarray ? ( $class, @traits ) : $class );
  }
  
  # ...
  
  # method-generating options shouldn't be overridden
  sub illegal_options_for_inheritance {
      qw(reader writer accessor clearer predicate)
  }
  
  # NOTE/TODO
  # This method *must* be able to handle
  # Class::MOP::Attribute instances as
  # well. Yes, I know that is wrong, but
  # apparently we didn't realize it was
  # doing that and now we have some code
  # which is dependent on it. The real
  # solution of course is to push this
  # feature back up into Class::MOP::Attribute
  # but I not right now, I am too lazy.
  # However if you are reading this and
  # looking for something to do,.. please
  # be my guest.
  # - stevan
  sub clone_and_inherit_options {
      my ($self, %options) = @_;
  
      # NOTE:
      # we may want to extends a Class::MOP::Attribute
      # in which case we need to be able to use the
      # core set of legal options that have always
      # been here. But we allows Moose::Meta::Attribute
      # instances to changes them.
      # - SL
      my @illegal_options = $self->can('illegal_options_for_inheritance')
          ? $self->illegal_options_for_inheritance
          : ();
  
      my @found_illegal_options = grep { exists $options{$_} && exists $self->{$_} ? $_ : undef } @illegal_options;
      (scalar @found_illegal_options == 0)
          || $self->throw_error("Illegal inherited options => (" . (join ', ' => @found_illegal_options) . ")", data => \%options);
  
      if ($options{isa}) {
          my $type_constraint;
          if (blessed($options{isa}) && $options{isa}->isa('Moose::Meta::TypeConstraint')) {
              $type_constraint = $options{isa};
          }
          else {
              $type_constraint = Moose::Util::TypeConstraints::find_or_create_isa_type_constraint($options{isa}, { package_defined_in => $options{definition_context}->{package} });
              (defined $type_constraint)
                  || $self->throw_error("Could not find the type constraint '" . $options{isa} . "'", data => $options{isa});
          }
  
          $options{type_constraint} = $type_constraint;
      }
  
      if ($options{does}) {
          my $type_constraint;
          if (blessed($options{does}) && $options{does}->isa('Moose::Meta::TypeConstraint')) {
              $type_constraint = $options{does};
          }
          else {
              $type_constraint = Moose::Util::TypeConstraints::find_or_create_does_type_constraint($options{does}, { package_defined_in => $options{definition_context}->{package} });
              (defined $type_constraint)
                  || $self->throw_error("Could not find the type constraint '" . $options{does} . "'", data => $options{does});
          }
  
          $options{type_constraint} = $type_constraint;
      }
  
      # NOTE:
      # this doesn't apply to Class::MOP::Attributes,
      # so we can ignore it for them.
      # - SL
      if ($self->can('interpolate_class')) {
          ( $options{metaclass}, my @traits ) = $self->interpolate_class(\%options);
  
          my %seen;
          my @all_traits = grep { $seen{$_}++ } @{ $self->applied_traits || [] }, @traits;
          $options{traits} = \@all_traits if @all_traits;
      }
  
      # This method can be called on a CMOP::Attribute object, so we need to
      # make sure we can call this method.
      $self->_process_lazy_build_option( $self->name, \%options )
          if $self->can('_process_lazy_build_option');
  
      $self->clone(%options);
  }
  
  sub clone {
      my ( $self, %params ) = @_;
  
      my $class = delete $params{metaclass} || ref $self;
  
      my ( @init, @non_init );
  
      foreach my $attr ( grep { $_->has_value($self) } Class::MOP::class_of($self)->get_all_attributes ) {
          push @{ $attr->has_init_arg ? \@init : \@non_init }, $attr;
      }
  
      my %new_params = ( ( map { $_->init_arg => $_->get_value($self) } @init ), %params );
  
      my $name = delete $new_params{name};
  
      my $clone = $class->new($name, %new_params, __hack_no_process_options => 1 );
  
      foreach my $attr ( @non_init ) {
          $attr->set_value($clone, $attr->get_value($self));
      }
  
      return $clone;
  }
  
  sub _process_options {
      my ( $class, $name, $options ) = @_;
  
      $class->_process_is_option( $name, $options );
      $class->_process_isa_option( $name, $options );
      $class->_process_does_option( $name, $options );
      $class->_process_coerce_option( $name, $options );
      $class->_process_trigger_option( $name, $options );
      $class->_process_auto_deref_option( $name, $options );
      $class->_process_lazy_build_option( $name, $options );
      $class->_process_lazy_option( $name, $options );
      $class->_process_required_option( $name, $options );
  }
  
  sub _process_is_option {
      my ( $class, $name, $options ) = @_;
  
      return unless $options->{is};
  
      ### -------------------------
      ## is => ro, writer => _foo    # turns into (reader => foo, writer => _foo) as before
      ## is => rw, writer => _foo    # turns into (reader => foo, writer => _foo)
      ## is => rw, accessor => _foo  # turns into (accessor => _foo)
      ## is => ro, accessor => _foo  # error, accesor is rw
      ### -------------------------
  
      if ( $options->{is} eq 'ro' ) {
          $class->throw_error(
              "Cannot define an accessor name on a read-only attribute, accessors are read/write",
              data => $options )
              if exists $options->{accessor};
          $options->{reader} ||= $name;
      }
      elsif ( $options->{is} eq 'rw' ) {
          if ( $options->{writer} ) {
              $options->{reader} ||= $name;
          }
          else {
              $options->{accessor} ||= $name;
          }
      }
      elsif ( $options->{is} eq 'bare' ) {
          return;
          # do nothing, but don't complain (later) about missing methods
      }
      else {
          $class->throw_error( "I do not understand this option (is => "
                  . $options->{is}
                  . ") on attribute ($name)", data => $options->{is} );
      }
  }
  
  sub _process_isa_option {
      my ( $class, $name, $options ) = @_;
  
      return unless exists $options->{isa};
  
      if ( exists $options->{does} ) {
          if ( try { $options->{isa}->can('does') } ) {
              ( $options->{isa}->does( $options->{does} ) )
                  || $class->throw_error(
                  "Cannot have an isa option and a does option if the isa does not do the does on attribute ($name)",
                  data => $options );
          }
          else {
              $class->throw_error(
                  "Cannot have an isa option which cannot ->does() on attribute ($name)",
                  data => $options );
          }
      }
  
      # allow for anon-subtypes here ...
      if ( blessed( $options->{isa} )
          && $options->{isa}->isa('Moose::Meta::TypeConstraint') ) {
          $options->{type_constraint} = $options->{isa};
      }
      else {
          $options->{type_constraint}
              = Moose::Util::TypeConstraints::find_or_create_isa_type_constraint(
              $options->{isa},
              { package_defined_in => $options->{definition_context}->{package} }
          );
      }
  }
  
  sub _process_does_option {
      my ( $class, $name, $options ) = @_;
  
      return unless exists $options->{does} && ! exists $options->{isa};
  
      # allow for anon-subtypes here ...
      if ( blessed( $options->{does} )
          && $options->{does}->isa('Moose::Meta::TypeConstraint') ) {
          $options->{type_constraint} = $options->{does};
      }
      else {
          $options->{type_constraint}
              = Moose::Util::TypeConstraints::find_or_create_does_type_constraint(
              $options->{does},
              { package_defined_in => $options->{definition_context}->{package} }
          );
      }
  }
  
  sub _process_coerce_option {
      my ( $class, $name, $options ) = @_;
  
      return unless $options->{coerce};
  
      ( exists $options->{type_constraint} )
          || $class->throw_error(
          "You cannot have coercion without specifying a type constraint on attribute ($name)",
          data => $options );
  
      $class->throw_error(
          "You cannot have a weak reference to a coerced value on attribute ($name)",
          data => $options )
          if $options->{weak_ref};
  
      unless ( $options->{type_constraint}->has_coercion ) {
          my $type = $options->{type_constraint}->name;
  
          Moose::Deprecated::deprecated(
              feature => 'coerce without coercion',
              message =>
                  "You cannot coerce an attribute ($name) unless its type ($type) has a coercion"
          );
      }
  }
  
  sub _process_trigger_option {
      my ( $class, $name, $options ) = @_;
  
      return unless exists $options->{trigger};
  
      ( 'CODE' eq ref $options->{trigger} )
          || $class->throw_error("Trigger must be a CODE ref on attribute ($name)", data => $options->{trigger});
  }
  
  sub _process_auto_deref_option {
      my ( $class, $name, $options ) = @_;
  
      return unless $options->{auto_deref};
  
      ( exists $options->{type_constraint} )
          || $class->throw_error(
          "You cannot auto-dereference without specifying a type constraint on attribute ($name)",
          data => $options );
  
      ( $options->{type_constraint}->is_a_type_of('ArrayRef')
        || $options->{type_constraint}->is_a_type_of('HashRef') )
          || $class->throw_error(
          "You cannot auto-dereference anything other than a ArrayRef or HashRef on attribute ($name)",
          data => $options );
  }
  
  sub _process_lazy_build_option {
      my ( $class, $name, $options ) = @_;
  
      return unless $options->{lazy_build};
  
      $class->throw_error(
          "You can not use lazy_build and default for the same attribute ($name)",
          data => $options )
          if exists $options->{default};
  
      $options->{lazy} = 1;
      $options->{builder} ||= "_build_${name}";
  
      if ( $name =~ /^_/ ) {
          $options->{clearer}   ||= "_clear${name}";
          $options->{predicate} ||= "_has${name}";
      }
      else {
          $options->{clearer}   ||= "clear_${name}";
          $options->{predicate} ||= "has_${name}";
      }
  }
  
  sub _process_lazy_option {
      my ( $class, $name, $options ) = @_;
  
      return unless $options->{lazy};
  
      ( exists $options->{default} || defined $options->{builder} )
          || $class->throw_error(
          "You cannot have a lazy attribute ($name) without specifying a default value for it",
          data => $options );
  }
  
  sub _process_required_option {
      my ( $class, $name, $options ) = @_;
  
      if (
          $options->{required}
          && !(
              ( !exists $options->{init_arg} || defined $options->{init_arg} )
              || exists $options->{default}
              || defined $options->{builder}
          )
          ) {
          $class->throw_error(
              "You cannot have a required attribute ($name) without a default, builder, or an init_arg",
              data => $options );
      }
  }
  
  sub initialize_instance_slot {
      my ($self, $meta_instance, $instance, $params) = @_;
      my $init_arg = $self->init_arg();
      # try to fetch the init arg from the %params ...
  
      my $val;
      my $value_is_set;
      if ( defined($init_arg) and exists $params->{$init_arg}) {
          $val = $params->{$init_arg};
          $value_is_set = 1;
      }
      else {
          # skip it if it's lazy
          return if $self->is_lazy;
          # and die if it's required and doesn't have a default value
          $self->throw_error("Attribute (" . $self->name . ") is required", object => $instance, data => $params)
              if $self->is_required && !$self->has_default && !$self->has_builder;
  
          # if nothing was in the %params, we can use the
          # attribute's default value (if it has one)
          if ($self->has_default) {
              $val = $self->default($instance);
              $value_is_set = 1;
          }
          elsif ($self->has_builder) {
              $val = $self->_call_builder($instance);
              $value_is_set = 1;
          }
      }
  
      return unless $value_is_set;
  
      $val = $self->_coerce_and_verify( $val, $instance );
  
      $self->set_initial_value($instance, $val);
  
      if ( ref $val && $self->is_weak_ref ) {
          $self->_weaken_value($instance);
      }
  }
  
  sub _call_builder {
      my ( $self, $instance ) = @_;
  
      my $builder = $self->builder();
  
      return $instance->$builder()
          if $instance->can( $self->builder );
  
      $self->throw_error(  blessed($instance)
              . " does not support builder method '"
              . $self->builder
              . "' for attribute '"
              . $self->name
              . "'",
              object => $instance,
       );
  }
  
  ## Slot management
  
  sub _make_initializer_writer_callback {
      my $self = shift;
      my ($meta_instance, $instance, $slot_name) = @_;
      my $old_callback = $self->SUPER::_make_initializer_writer_callback(@_);
      return sub {
          $old_callback->($self->_coerce_and_verify($_[0], $instance));
      };
  }
  
  sub set_value {
      my ($self, $instance, @args) = @_;
      my $value = $args[0];
  
      my $attr_name = quotemeta($self->name);
  
      if ($self->is_required and not @args) {
          $self->throw_error("Attribute ($attr_name) is required", object => $instance);
      }
  
      $value = $self->_coerce_and_verify( $value, $instance );
  
      my @old;
      if ( $self->has_trigger && $self->has_value($instance) ) {
          @old = $self->get_value($instance, 'for trigger');
      }
  
      $self->SUPER::set_value($instance, $value);
  
      if ( ref $value && $self->is_weak_ref ) {
          $self->_weaken_value($instance);
      }
  
      if ($self->has_trigger) {
          $self->trigger->($instance, $value, @old);
      }
  }
  
  sub _inline_set_value {
      my $self = shift;
      my ($instance, $value, $tc, $coercion, $message, $for_constructor) = @_;
  
      my $old     = '@old';
      my $copy    = '$val';
      $tc       ||= '$type_constraint';
      $coercion ||= '$type_coercion';
      $message  ||= '$type_message';
  
      my @code;
      if ($self->_writer_value_needs_copy) {
          push @code, $self->_inline_copy_value($value, $copy);
          $value = $copy;
      }
  
      # constructors already handle required checks
      push @code, $self->_inline_check_required
          unless $for_constructor;
  
      push @code, $self->_inline_tc_code($value, $tc, $coercion, $message);
  
      # constructors do triggers all at once at the end
      push @code, $self->_inline_get_old_value_for_trigger($instance, $old)
          unless $for_constructor;
  
      push @code, (
          $self->SUPER::_inline_set_value($instance, $value),
          $self->_inline_weaken_value($instance, $value),
      );
  
      # constructors do triggers all at once at the end
      push @code, $self->_inline_trigger($instance, $value, $old)
          unless $for_constructor;
  
      return @code;
  }
  
  sub _writer_value_needs_copy {
      my $self = shift;
      return $self->should_coerce;
  }
  
  sub _inline_copy_value {
      my $self = shift;
      my ($value, $copy) = @_;
  
      return 'my ' . $copy . ' = ' . $value . ';'
  }
  
  sub _inline_check_required {
      my $self = shift;
  
      return unless $self->is_required;
  
      my $attr_name = quotemeta($self->name);
  
      return (
          'if (@_ < 2) {',
              $self->_inline_throw_error(
                  '"Attribute (' . $attr_name . ') is required, so cannot '
                . 'be set to undef"' # defined $_[1] is not good enough
              ) . ';',
          '}',
      );
  }
  
  sub _inline_tc_code {
      my $self = shift;
      my ($value, $tc, $coercion, $message, $is_lazy) = @_;
      return (
          $self->_inline_check_coercion(
              $value, $tc, $coercion, $is_lazy,
          ),
          $self->_inline_check_constraint(
              $value, $tc, $message, $is_lazy,
          ),
      );
  }
  
  sub _inline_check_coercion {
      my $self = shift;
      my ($value, $tc, $coercion) = @_;
  
      return unless $self->should_coerce && $self->type_constraint->has_coercion;
  
      if ( $self->type_constraint->can_be_inlined ) {
          return (
              'if (! (' . $self->type_constraint->_inline_check($value) . ')) {',
                  $value . ' = ' . $coercion . '->(' . $value . ');',
              '}',
          );
      }
      else {
          return (
              'if (!' . $tc . '->(' . $value . ')) {',
                  $value . ' = ' . $coercion . '->(' . $value . ');',
              '}',
          );
      }
  }
  
  sub _inline_check_constraint {
      my $self = shift;
      my ($value, $tc, $message) = @_;
  
      return unless $self->has_type_constraint;
  
      my $attr_name = quotemeta($self->name);
  
      if ( $self->type_constraint->can_be_inlined ) {
          return (
              'if (! (' . $self->type_constraint->_inline_check($value) . ')) {',
                  $self->_inline_throw_error(
                      '"Attribute (' . $attr_name . ') does not pass the type '
                    . 'constraint because: " . '
                    . 'do { local $_ = ' . $value . '; '
                        . $message . '->(' . $value . ')'
                    . '}',
                      'data => ' . $value
                  ) . ';',
              '}',
          );
      }
      else {
          return (
              'if (!' . $tc . '->(' . $value . ')) {',
                  $self->_inline_throw_error(
                      '"Attribute (' . $attr_name . ') does not pass the type '
                    . 'constraint because: " . '
                    . 'do { local $_ = ' . $value . '; '
                        . $message . '->(' . $value . ')'
                    . '}',
                      'data => ' . $value
                  ) . ';',
              '}',
          );
      }
  }
  
  sub _inline_get_old_value_for_trigger {
      my $self = shift;
      my ($instance, $old) = @_;
  
      return unless $self->has_trigger;
  
      return (
          'my ' . $old . ' = ' . $self->_inline_instance_has($instance),
              '? ' . $self->_inline_instance_get($instance),
              ': ();',
      );
  }
  
  sub _inline_weaken_value {
      my $self = shift;
      my ($instance, $value) = @_;
  
      return unless $self->is_weak_ref;
  
      my $mi = $self->associated_class->get_meta_instance;
      return (
          $mi->inline_weaken_slot_value($instance, $self->name),
              'if ref ' . $value . ';',
      );
  }
  
  sub _inline_trigger {
      my $self = shift;
      my ($instance, $value, $old) = @_;
  
      return unless $self->has_trigger;
  
      return '$trigger->(' . $instance . ', ' . $value . ', ' . $old . ');';
  }
  
  sub _eval_environment {
      my $self = shift;
  
      my $env = { };
  
      $env->{'$trigger'} = \($self->trigger)
          if $self->has_trigger;
      $env->{'$attr_default'} = \($self->default)
          if $self->has_default;
  
      if ($self->has_type_constraint) {
          my $tc_obj = $self->type_constraint;
  
          $env->{'$type_constraint'} = \(
              $tc_obj->_compiled_type_constraint
          ) unless $tc_obj->can_be_inlined;
          # these two could probably get inlined versions too
          $env->{'$type_coercion'} = \(
              $tc_obj->coercion->_compiled_type_coercion
          ) if $tc_obj->has_coercion;
          $env->{'$type_message'} = \(
              $tc_obj->has_message ? $tc_obj->message : $tc_obj->_default_message
          );
  
          $env = { %$env, %{ $tc_obj->inline_environment } };
      }
  
      # XXX ugh, fix these
      $env->{'$attr'} = \$self
          if $self->has_initializer && $self->is_lazy;
      # pretty sure this is only going to be closed over if you use a custom
      # error class at this point, but we should still get rid of this
      # at some point
      $env->{'$meta'} = \($self->associated_class);
  
      return $env;
  }
  
  sub _weaken_value {
      my ( $self, $instance ) = @_;
  
      my $meta_instance = Class::MOP::Class->initialize( blessed($instance) )
          ->get_meta_instance;
  
      $meta_instance->weaken_slot_value( $instance, $self->name );
  }
  
  sub get_value {
      my ($self, $instance, $for_trigger) = @_;
  
      if ($self->is_lazy) {
          unless ($self->has_value($instance)) {
              my $value;
              if ($self->has_default) {
                  $value = $self->default($instance);
              } elsif ( $self->has_builder ) {
                  $value = $self->_call_builder($instance);
              }
  
              $value = $self->_coerce_and_verify( $value, $instance );
  
              $self->set_initial_value($instance, $value);
  
              if ( ref $value && $self->is_weak_ref ) {
                  $self->_weaken_value($instance);
              }
          }
      }
  
      if ( $self->should_auto_deref && ! $for_trigger ) {
  
          my $type_constraint = $self->type_constraint;
  
          if ($type_constraint->is_a_type_of('ArrayRef')) {
              my $rv = $self->SUPER::get_value($instance);
              return unless defined $rv;
              return wantarray ? @{ $rv } : $rv;
          }
          elsif ($type_constraint->is_a_type_of('HashRef')) {
              my $rv = $self->SUPER::get_value($instance);
              return unless defined $rv;
              return wantarray ? %{ $rv } : $rv;
          }
          else {
              $self->throw_error("Can not auto de-reference the type constraint '" . $type_constraint->name . "'", object => $instance, type_constraint => $type_constraint);
          }
  
      }
      else {
  
          return $self->SUPER::get_value($instance);
      }
  }
  
  sub _inline_get_value {
      my $self = shift;
      my ($instance, $tc, $coercion, $message) = @_;
  
      my $slot_access = $self->_inline_instance_get($instance);
      $tc           ||= '$type_constraint';
      $coercion     ||= '$type_coercion';
      $message      ||= '$type_message';
  
      return (
          $self->_inline_check_lazy($instance, $tc, $coercion, $message),
          $self->_inline_return_auto_deref($slot_access),
      );
  }
  
  sub _inline_check_lazy {
      my $self = shift;
      my ($instance, $tc, $coercion, $message) = @_;
  
      return unless $self->is_lazy;
  
      my $slot_exists = $self->_inline_instance_has($instance);
  
      return (
          'if (!' . $slot_exists . ') {',
              $self->_inline_init_from_default($instance, '$default', $tc, $coercion, $message, 'lazy'),
          '}',
      );
  }
  
  sub _inline_init_from_default {
      my $self = shift;
      my ($instance, $default, $tc, $coercion, $message, $for_lazy) = @_;
  
      if (!($self->has_default || $self->has_builder)) {
          $self->throw_error(
              'You cannot have a lazy attribute '
            . '(' . $self->name . ') '
            . 'without specifying a default value for it',
              attr => $self,
          );
      }
  
      return (
          $self->_inline_generate_default($instance, $default),
          # intentionally not using _inline_tc_code, since that can be overridden
          # to do things like possibly only do member tc checks, which isn't
          # appropriate for checking the result of a default
          $self->has_type_constraint
              ? ($self->_inline_check_coercion($default, $tc, $coercion, $for_lazy),
                 $self->_inline_check_constraint($default, $tc, $message, $for_lazy))
              : (),
          $self->_inline_init_slot($instance, $default),
          $self->_inline_weaken_value($instance, $default),
      );
  }
  
  sub _inline_generate_default {
      my $self = shift;
      my ($instance, $default) = @_;
  
      if ($self->has_default) {
          my $source = 'my ' . $default . ' = $attr_default';
          $source .= '->(' . $instance . ')'
              if $self->is_default_a_coderef;
          return $source . ';';
      }
      elsif ($self->has_builder) {
          my $builder = B::perlstring($self->builder);
          my $builder_str = quotemeta($self->builder);
          my $attr_name_str = quotemeta($self->name);
          return (
              'my ' . $default . ';',
              'if (my $builder = ' . $instance . '->can(' . $builder . ')) {',
                  $default . ' = ' . $instance . '->$builder;',
              '}',
              'else {',
                  'my $class = ref(' . $instance . ') || ' . $instance . ';',
                  $self->_inline_throw_error(
                      '"$class does not support builder method '
                    . '\'' . $builder_str . '\' for attribute '
                    . '\'' . $attr_name_str . '\'"'
                  ) . ';',
              '}',
          );
      }
      else {
          $self->throw_error(
              "Can't generate a default for " . $self->name
            . " since no default or builder was specified"
          );
      }
  }
  
  sub _inline_init_slot {
      my $self = shift;
      my ($inv, $value) = @_;
  
      if ($self->has_initializer) {
          return '$attr->set_initial_value(' . $inv . ', ' . $value . ');';
      }
      else {
          return $self->_inline_instance_set($inv, $value) . ';';
      }
  }
  
  sub _inline_return_auto_deref {
      my $self = shift;
  
      return 'return ' . $self->_auto_deref(@_) . ';';
  }
  
  sub _auto_deref {
      my $self = shift;
      my ($ref_value) = @_;
  
      return $ref_value unless $self->should_auto_deref;
  
      my $type_constraint = $self->type_constraint;
  
      my $sigil;
      if ($type_constraint->is_a_type_of('ArrayRef')) {
          $sigil = '@';
      }
      elsif ($type_constraint->is_a_type_of('HashRef')) {
          $sigil = '%';
      }
      else {
          $self->throw_error(
              'Can not auto de-reference the type constraint \''
            . $type_constraint->name
            . '\'',
              type_constraint => $type_constraint,
          );
      }
  
      return 'wantarray '
               . '? ' . $sigil . '{ (' . $ref_value . ') || return } '
               . ': (' . $ref_value . ')';
  }
  
  ## installing accessors
  
  sub accessor_metaclass { 'Moose::Meta::Method::Accessor' }
  
  sub install_accessors {
      my $self = shift;
      $self->SUPER::install_accessors(@_);
      $self->install_delegation if $self->has_handles;
      return;
  }
  
  sub _check_associated_methods {
      my $self = shift;
      unless (
          @{ $self->associated_methods }
          || ($self->_is_metadata || '') eq 'bare'
      ) {
          Carp::cluck(
              'Attribute (' . $self->name . ') of class '
              . $self->associated_class->name
              . ' has no associated methods'
              . ' (did you mean to provide an "is" argument?)'
              . "\n"
          )
      }
  }
  
  sub _process_accessors {
      my $self = shift;
      my ($type, $accessor, $generate_as_inline_methods) = @_;
  
      $accessor = ( keys %$accessor )[0] if ( ref($accessor) || '' ) eq 'HASH';
      my $method = $self->associated_class->get_method($accessor);
  
      if (   $method
          && $method->isa('Class::MOP::Method::Accessor')
          && $method->associated_attribute->name ne $self->name ) {
  
          my $other_attr_name = $method->associated_attribute->name;
          my $name            = $self->name;
  
          Carp::cluck(
              "You are overwriting an accessor ($accessor) for the $other_attr_name attribute"
                  . " with a new accessor method for the $name attribute" );
      }
  
      if (
             $method
          && !$method->is_stub
          && !$method->isa('Class::MOP::Method::Accessor')
          && (  !$self->definition_context
              || $method->package_name eq $self->definition_context->{package} )
          ) {
  
          Carp::cluck(
              "You are overwriting a locally defined method ($accessor) with "
                  . "an accessor" );
      }
  
      if (  !$self->associated_class->has_method($accessor)
          && $self->associated_class->has_package_symbol( '&' . $accessor ) ) {
  
          Carp::cluck(
              "You are overwriting a locally defined function ($accessor) with "
                  . "an accessor" );
      }
  
      $self->SUPER::_process_accessors(@_);
  }
  
  sub remove_accessors {
      my $self = shift;
      $self->SUPER::remove_accessors(@_);
      $self->remove_delegation if $self->has_handles;
      return;
  }
  
  sub install_delegation {
      my $self = shift;
  
      # NOTE:
      # Here we canonicalize the 'handles' option
      # this will sort out any details and always
      # return an hash of methods which we want
      # to delagate to, see that method for details
      my %handles = $self->_canonicalize_handles;
  
  
      # install the delegation ...
      my $associated_class = $self->associated_class;
      foreach my $handle (sort keys %handles) {
          my $method_to_call = $handles{$handle};
          my $class_name = $associated_class->name;
          my $name = "${class_name}::${handle}";
  
          if ( my $method = $associated_class->get_method($handle) ) {
              $self->throw_error(
                  "You cannot overwrite a locally defined method ($handle) with a delegation",
                  method_name => $handle
              ) unless $method->is_stub;
          }
  
          # NOTE:
          # handles is not allowed to delegate
          # any of these methods, as they will
          # override the ones in your class, which
          # is almost certainly not what you want.
  
          # FIXME warn when $handle was explicitly specified, but not if the source is a regex or something
          #cluck("Not delegating method '$handle' because it is a core method") and
          next if $class_name->isa("Moose::Object") and $handle =~ /^BUILD|DEMOLISH$/ || Moose::Object->can($handle);
  
          my $method = $self->_make_delegation_method($handle, $method_to_call);
  
          $self->associated_class->add_method($method->name, $method);
          $self->associate_method($method);
      }
  }
  
  sub remove_delegation {
      my $self = shift;
      my %handles = $self->_canonicalize_handles;
      my $associated_class = $self->associated_class;
      foreach my $handle (keys %handles) {
          next unless any { $handle eq $_ }
                      map { $_->name }
                      @{ $self->associated_methods };
          $self->associated_class->remove_method($handle);
      }
  }
  
  # private methods to help delegation ...
  
  sub _canonicalize_handles {
      my $self    = shift;
      my $handles = $self->handles;
      if (my $handle_type = ref($handles)) {
          if ($handle_type eq 'HASH') {
              return %{$handles};
          }
          elsif ($handle_type eq 'ARRAY') {
              return map { $_ => $_ } @{$handles};
          }
          elsif ($handle_type eq 'Regexp') {
              ($self->has_type_constraint)
                  || $self->throw_error("Cannot delegate methods based on a Regexp without a type constraint (isa)", data => $handles);
              return map  { ($_ => $_) }
                     grep { /$handles/ } $self->_get_delegate_method_list;
          }
          elsif ($handle_type eq 'CODE') {
              return $handles->($self, $self->_find_delegate_metaclass);
          }
          elsif (blessed($handles) && $handles->isa('Moose::Meta::TypeConstraint::DuckType')) {
              return map { $_ => $_ } @{ $handles->methods };
          }
          elsif (blessed($handles) && $handles->isa('Moose::Meta::TypeConstraint::Role')) {
              $handles = $handles->role;
          }
          else {
              $self->throw_error("Unable to canonicalize the 'handles' option with $handles", data => $handles);
          }
      }
  
      load_class($handles);
      my $role_meta = Class::MOP::class_of($handles);
  
      (blessed $role_meta && $role_meta->isa('Moose::Meta::Role'))
          || $self->throw_error("Unable to canonicalize the 'handles' option with $handles because its metaclass is not a Moose::Meta::Role", data => $handles);
  
      return map { $_ => $_ }
          map { $_->name }
          grep { !$_->isa('Class::MOP::Method::Meta') } (
          $role_meta->_get_local_methods,
          $role_meta->get_required_method_list,
          );
  }
  
  sub _get_delegate_method_list {
      my $self = shift;
      my $meta = $self->_find_delegate_metaclass;
      if ($meta->isa('Class::MOP::Class')) {
          return map  { $_->name }  # NOTE: !never! delegate &meta
                 grep { $_->package_name ne 'Moose::Object' && !$_->isa('Class::MOP::Method::Meta') }
                      $meta->get_all_methods;
      }
      elsif ($meta->isa('Moose::Meta::Role')) {
          return $meta->get_method_list;
      }
      else {
          $self->throw_error("Unable to recognize the delegate metaclass '$meta'", data => $meta);
      }
  }
  
  sub _find_delegate_metaclass {
      my $self = shift;
      if (my $class = $self->_isa_metadata) {
          unless ( is_class_loaded($class) ) {
              $self->throw_error(
                  sprintf(
                      'The %s attribute is trying to delegate to a class which has not been loaded - %s',
                      $self->name, $class
                  )
              );
          }
          # we might be dealing with a non-Moose class,
          # and need to make our own metaclass. if there's
          # already a metaclass, it will be returned
          return Class::MOP::Class->initialize($class);
      }
      elsif (my $role = $self->_does_metadata) {
          unless ( is_class_loaded($class) ) {
              $self->throw_error(
                  sprintf(
                      'The %s attribute is trying to delegate to a role which has not been loaded - %s',
                      $self->name, $role
                  )
              );
          }
  
          return Class::MOP::class_of($role);
      }
      else {
          $self->throw_error("Cannot find delegate metaclass for attribute " . $self->name);
      }
  }
  
  sub delegation_metaclass { 'Moose::Meta::Method::Delegation' }
  
  sub _make_delegation_method {
      my ( $self, $handle_name, $method_to_call ) = @_;
  
      my @curried_arguments;
  
      ($method_to_call, @curried_arguments) = @$method_to_call
          if 'ARRAY' eq ref($method_to_call);
  
      return $self->delegation_metaclass->new(
          name               => $handle_name,
          package_name       => $self->associated_class->name,
          attribute          => $self,
          delegate_to_method => $method_to_call,
          curried_arguments  => \@curried_arguments,
      );
  }
  
  sub _coerce_and_verify {
      my $self     = shift;
      my $val      = shift;
      my $instance = shift;
  
      return $val unless $self->has_type_constraint;
  
      $val = $self->type_constraint->coerce($val)
          if $self->should_coerce && $self->type_constraint->has_coercion;
  
      $self->verify_against_type_constraint($val, instance => $instance);
  
      return $val;
  }
  
  sub verify_against_type_constraint {
      my $self = shift;
      my $val  = shift;
  
      return 1 if !$self->has_type_constraint;
  
      my $type_constraint = $self->type_constraint;
  
      $type_constraint->check($val)
          || $self->throw_error("Attribute ("
                   . $self->name
                   . ") does not pass the type constraint because: "
                   . $type_constraint->get_message($val), data => $val, @_);
  }
  
  package Moose::Meta::Attribute::Custom::Moose;
  BEGIN {
    $Moose::Meta::Attribute::Custom::Moose::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Attribute::Custom::Moose::VERSION = '2.0401';
  }
  sub register_implementation { 'Moose::Meta::Attribute' }
  
  1;
  
  # ABSTRACT: The Moose attribute metaclass
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::Attribute - The Moose attribute metaclass
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This class is a subclass of L<Class::MOP::Attribute> that provides
  additional Moose-specific functionality.
  
  To really understand this class, you will need to start with the
  L<Class::MOP::Attribute> documentation. This class can be understood
  as a set of additional features on top of the basic feature provided
  by that parent class.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Attribute> is a subclass of L<Class::MOP::Attribute>.
  
  =head1 METHODS
  
  Many of the documented below override methods in
  L<Class::MOP::Attribute> and add Moose specific features.
  
  =head2 Creation
  
  =over 4
  
  =item B<< Moose::Meta::Attribute->new(%options) >>
  
  This method overrides the L<Class::MOP::Attribute> constructor.
  
  Many of the options below are described in more detail in the
  L<Moose::Manual::Attributes> document.
  
  It adds the following options to the constructor:
  
  =over 8
  
  =item * is => 'ro', 'rw', 'bare'
  
  This provides a shorthand for specifying the C<reader>, C<writer>, or
  C<accessor> names. If the attribute is read-only ('ro') then it will
  have a C<reader> method with the same attribute as the name.
  
  If it is read-write ('rw') then it will have an C<accessor> method
  with the same name. If you provide an explicit C<writer> for a
  read-write attribute, then you will have a C<reader> with the same
  name as the attribute, and a C<writer> with the name you provided.
  
  Use 'bare' when you are deliberately not installing any methods
  (accessor, reader, etc.) associated with this attribute; otherwise,
  Moose will issue a deprecation warning when this attribute is added to a
  metaclass.
  
  =item * isa => $type
  
  This option accepts a type. The type can be a string, which should be
  a type name. If the type name is unknown, it is assumed to be a class
  name.
  
  This option can also accept a L<Moose::Meta::TypeConstraint> object.
  
  If you I<also> provide a C<does> option, then your C<isa> option must
  be a class name, and that class must do the role specified with
  C<does>.
  
  =item * does => $role
  
  This is short-hand for saying that the attribute's type must be an
  object which does the named role.
  
  =item * coerce => $bool
  
  This option is only valid for objects with a type constraint
  (C<isa>) that defined a coercion. If this is true, then coercions will be applied whenever
  this attribute is set.
  
  You can make both this and the C<weak_ref> option true.
  
  =item * trigger => $sub
  
  This option accepts a subroutine reference, which will be called after
  the attribute is set.
  
  =item * required => $bool
  
  An attribute which is required must be provided to the constructor. An
  attribute which is required can also have a C<default> or C<builder>,
  which will satisfy its required-ness.
  
  A required attribute must have a C<default>, C<builder> or a
  non-C<undef> C<init_arg>
  
  =item * lazy => $bool
  
  A lazy attribute must have a C<default> or C<builder>. When an
  attribute is lazy, the default value will not be calculated until the
  attribute is read.
  
  =item * weak_ref => $bool
  
  If this is true, the attribute's value will be stored as a weak
  reference.
  
  =item * auto_deref => $bool
  
  If this is true, then the reader will dereference the value when it is
  called. The attribute must have a type constraint which defines the
  attribute as an array or hash reference.
  
  =item * lazy_build => $bool
  
  Setting this to true makes the attribute lazy and provides a number of
  default methods.
  
    has 'size' => (
        is         => 'ro',
        lazy_build => 1,
    );
  
  is equivalent to this:
  
    has 'size' => (
        is        => 'ro',
        lazy      => 1,
        builder   => '_build_size',
        clearer   => 'clear_size',
        predicate => 'has_size',
    );
  
  If your attribute name starts with an underscore (C<_>), then the clearer
  and predicate will as well:
  
    has '_size' => (
        is         => 'ro',
        lazy_build => 1,
    );
  
  becomes:
  
    has '_size' => (
        is        => 'ro',
        lazy      => 1,
        builder   => '_build__size',
        clearer   => '_clear_size',
        predicate => '_has_size',
    );
  
  Note the doubled underscore in the builder name. Internally, Moose
  simply prepends the attribute name with "_build_" to come up with the
  builder name.
  
  =item * documentation
  
  An arbitrary string that can be retrieved later by calling C<<
  $attr->documentation >>.
  
  =back
  
  =item B<< $attr->clone(%options) >>
  
  This creates a new attribute based on attribute being cloned. You must
  supply a C<name> option to provide a new name for the attribute.
  
  The C<%options> can only specify options handled by
  L<Class::MOP::Attribute>.
  
  =back
  
  =head2 Value management
  
  =over 4
  
  =item B<< $attr->initialize_instance_slot($meta_instance, $instance, $params) >>
  
  This method is used internally to initialize the attribute's slot in
  the object C<$instance>.
  
  This overrides the L<Class::MOP::Attribute> method to handle lazy
  attributes, weak references, and type constraints.
  
  =item B<get_value>
  
  =item B<set_value>
  
    eval { $point->meta->get_attribute('x')->set_value($point, 'forty-two') };
    if($@) {
      print "Oops: $@\n";
    }
  
  I<Attribute (x) does not pass the type constraint (Int) with 'forty-two'>
  
  Before setting the value, a check is made on the type constraint of
  the attribute, if it has one, to see if the value passes it. If the
  value fails to pass, the set operation dies with a L</throw_error>.
  
  Any coercion to convert values is done before checking the type constraint.
  
  To check a value against a type constraint before setting it, fetch the
  attribute instance using L<Class::MOP::Class/find_attribute_by_name>,
  fetch the type_constraint from the attribute using L<Moose::Meta::Attribute/type_constraint>
  and call L<Moose::Meta::TypeConstraint/check>. See L<Moose::Cookbook::Basics::Recipe4>
  for an example.
  
  =back
  
  =head2 Attribute Accessor generation
  
  =over 4
  
  =item B<< $attr->install_accessors >>
  
  This method overrides the parent to also install delegation methods.
  
  If, after installing all methods, the attribute object has no associated
  methods, it throws an error unless C<< is => 'bare' >> was passed to the
  attribute constructor.  (Trying to add an attribute that has no associated
  methods is almost always an error.)
  
  =item B<< $attr->remove_accessors >>
  
  This method overrides the parent to also remove delegation methods.
  
  =item B<< $attr->inline_set($instance_var, $value_var) >>
  
  This method return a code snippet suitable for inlining the relevant
  operation. It expect strings containing variable names to be used in the
  inlining, like C<'$self'> or C<'$_[1]'>.
  
  =item B<< $attr->install_delegation >>
  
  This method adds its delegation methods to the attribute's associated
  class, if it has any to add.
  
  =item B<< $attr->remove_delegation >>
  
  This method remove its delegation methods from the attribute's
  associated class.
  
  =item B<< $attr->accessor_metaclass >>
  
  Returns the accessor metaclass name, which defaults to
  L<Moose::Meta::Method::Accessor>.
  
  =item B<< $attr->delegation_metaclass >>
  
  Returns the delegation metaclass name, which defaults to
  L<Moose::Meta::Method::Delegation>.
  
  =back
  
  =head2 Additional Moose features
  
  These methods are not found in the superclass. They support features
  provided by Moose.
  
  =over 4
  
  =item B<< $attr->does($role) >>
  
  This indicates whether the I<attribute itself> does the given
  role. The role can be given as a full class name, or as a resolvable
  trait name.
  
  Note that this checks the attribute itself, not its type constraint,
  so it is checking the attribute's metaclass and any traits applied to
  the attribute.
  
  =item B<< Moose::Meta::Class->interpolate_class_and_new($name, %options) >>
  
  This is an alternate constructor that handles the C<metaclass> and
  C<traits> options.
  
  Effectively, this method is a factory that finds or creates the
  appropriate class for the given C<metaclass> and/or C<traits>.
  
  Once it has the appropriate class, it will call C<< $class->new($name,
  %options) >> on that class.
  
  =item B<< $attr->clone_and_inherit_options(%options) >>
  
  This method supports the C<has '+foo'> feature. It does various bits
  of processing on the supplied C<%options> before ultimately calling
  the C<clone> method.
  
  One of its main tasks is to make sure that the C<%options> provided
  does not include the options returned by the
  C<illegal_options_for_inheritance> method.
  
  =item B<< $attr->illegal_options_for_inheritance >>
  
  This returns a blacklist of options that can not be overridden in a
  subclass's attribute definition.
  
  This exists to allow a custom metaclass to change or add to the list
  of options which can not be changed.
  
  =item B<< $attr->type_constraint >>
  
  Returns the L<Moose::Meta::TypeConstraint> object for this attribute,
  if it has one.
  
  =item B<< $attr->has_type_constraint >>
  
  Returns true if this attribute has a type constraint.
  
  =item B<< $attr->verify_against_type_constraint($value) >>
  
  Given a value, this method returns true if the value is valid for the
  attribute's type constraint. If the value is not valid, it throws an
  error.
  
  =item B<< $attr->handles >>
  
  This returns the value of the C<handles> option passed to the
  constructor.
  
  =item B<< $attr->has_handles >>
  
  Returns true if this attribute performs delegation.
  
  =item B<< $attr->is_weak_ref >>
  
  Returns true if this attribute stores its value as a weak reference.
  
  =item B<< $attr->is_required >>
  
  Returns true if this attribute is required to have a value.
  
  =item B<< $attr->is_lazy >>
  
  Returns true if this attribute is lazy.
  
  =item B<< $attr->is_lazy_build >>
  
  Returns true if the C<lazy_build> option was true when passed to the
  constructor.
  
  =item B<< $attr->should_coerce >>
  
  Returns true if the C<coerce> option passed to the constructor was
  true.
  
  =item B<< $attr->should_auto_deref >>
  
  Returns true if the C<auto_deref> option passed to the constructor was
  true.
  
  =item B<< $attr->trigger >>
  
  This is the subroutine reference that was in the C<trigger> option
  passed to the constructor, if any.
  
  =item B<< $attr->has_trigger >>
  
  Returns true if this attribute has a trigger set.
  
  =item B<< $attr->documentation >>
  
  Returns the value that was in the C<documentation> option passed to
  the constructor, if any.
  
  =item B<< $attr->has_documentation >>
  
  Returns true if this attribute has any documentation.
  
  =item B<< $attr->applied_traits >>
  
  This returns an array reference of all the traits which were applied
  to this attribute. If none were applied, this returns C<undef>.
  
  =item B<< $attr->has_applied_traits >>
  
  Returns true if this attribute has any traits applied.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_META_ATTRIBUTE

$fatpacked{"i686-linux/Moose/Meta/Attribute/Native.pm"} = <<'I686-LINUX_MOOSE_META_ATTRIBUTE_NATIVE';
  package Moose::Meta::Attribute::Native;
  BEGIN {
    $Moose::Meta::Attribute::Native::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Attribute::Native::VERSION = '2.0401';
  }
  
  use Class::Load qw(load_class);
  
  my @trait_names = qw(Bool Counter Number String Array Hash Code);
  
  for my $trait_name (@trait_names) {
      my $trait_class = "Moose::Meta::Attribute::Native::Trait::$trait_name";
      my $meta = Class::MOP::Class->initialize(
          "Moose::Meta::Attribute::Custom::Trait::$trait_name"
      );
      if ($meta->find_method_by_name('register_implementation')) {
          my $class = $meta->name->register_implementation;
          Moose->throw_error(
              "An implementation for $trait_name already exists " .
              "(found '$class' when trying to register '$trait_class')"
          );
      }
      $meta->add_method(register_implementation => sub {
          # resolve_metatrait_alias will load classes anyway, but throws away
          # their error message; we WANT to die if there's a problem
          load_class($trait_class);
          return $trait_class;
      });
  }
  
  1;
  
  # ABSTRACT: Delegate to native Perl types
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native - Delegate to native Perl types
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 SYNOPSIS
  
    package MyClass;
    use Moose;
  
    has 'mapping' => (
        traits  => ['Hash'],
        is      => 'rw',
        isa     => 'HashRef[Str]',
        default => sub { {} },
        handles => {
            exists_in_mapping => 'exists',
            ids_in_mapping    => 'keys',
            get_mapping       => 'get',
            set_mapping       => 'set',
            set_quantity      => [ set => 'quantity' ],
        },
    );
  
    my $obj = MyClass->new;
    $obj->set_quantity(10);      # quantity => 10
    $obj->set_mapping('foo', 4); # foo => 4
    $obj->set_mapping('bar', 5); # bar => 5
    $obj->set_mapping('baz', 6); # baz => 6
  
    # prints 5
    print $obj->get_mapping('bar') if $obj->exists_in_mapping('bar');
  
    # prints 'quantity, foo, bar, baz'
    print join ', ', $obj->ids_in_mapping;
  
  =head1 DESCRIPTION
  
  Native delegations allow you to delegate to native Perl data
  structures as if they were objects. For example, in the L</SYNOPSIS> you can
  see a hash reference being treated as if it has methods named C<exists()>,
  C<keys()>, C<get()>, and C<set()>.
  
  The delegation methods (mostly) map to Perl builtins and operators. The return
  values of these delegations should be the same as the corresponding Perl
  operation. Any deviations will be explicitly documented.
  
  =head1 API
  
  Native delegations are enabled by passing certain options to C<has> when
  creating an attribute.
  
  =head2 traits
  
  To enable this feature, pass the appropriate name in the C<traits> array
  reference for the attribute. For example, to enable this feature for hash
  reference, we include C<'Hash'> in the list of traits.
  
  =head2 isa
  
  You will need to make sure that the attribute has an appropriate type. For
  example, to use this with a Hash you must specify that your attribute is some
  sort of C<HashRef>.
  
  =head2 handles
  
  This is just like any other delegation, but only a hash reference is allowed
  when defining native delegations. The keys are the methods to be created in
  the class which contains the attribute. The values are the methods provided by
  the associated trait. Currying works the same way as it does with any other
  delegation.
  
  See the docs for each native trait for details on what methods are available.
  
  =head2 is
  
  Some traits provide a default C<is> for historical reasons. This behavior is
  deprecated, and you are strongly encouraged to provide a value. If you don't
  plan to read and write the attribute value directly, not passing the C<is>
  option will prevent standard accessor generation.
  
  =head2 default or builder
  
  Some traits provide a default C<default> for historical reasons. This behavior
  is deprecated, and you are strongly encouraged to provide a default value or
  make the attribute required.
  
  =head1 TRAITS FOR NATIVE DELEGATIONS
  
  =over
  
  =item L<Array|Moose::Meta::Attribute::Native::Trait::Array>
  
      has 'queue' => (
          traits  => ['Array'],
          is      => 'ro',
          isa     => 'ArrayRef[Str]',
          default => sub { [] },
          handles => {
              add_item  => 'push',
              next_item => 'shift',
              # ...
          }
      );
  
  =item L<Bool|Moose::Meta::Attribute::Native::Trait::Bool>
  
      has 'is_lit' => (
          traits  => ['Bool'],
          is      => 'ro',
          isa     => 'Bool',
          default => 0,
          handles => {
              illuminate  => 'set',
              darken      => 'unset',
              flip_switch => 'toggle',
              is_dark     => 'not',
              # ...
          }
      );
  
  =item L<Code|Moose::Meta::Attribute::Native::Trait::Code>
  
      has 'callback' => (
          traits  => ['Code'],
          is      => 'ro',
          isa     => 'CodeRef',
          default => sub {
              sub {'called'}
          },
          handles => {
              call => 'execute',
              # ...
          }
      );
  
  =item L<Counter|Moose::Meta::Attribute::Native::Trait::Counter>
  
      has 'counter' => (
          traits  => ['Counter'],
          is      => 'ro',
          isa     => 'Num',
          default => 0,
          handles => {
              inc_counter   => 'inc',
              dec_counter   => 'dec',
              reset_counter => 'reset',
              # ...
          }
      );
  
  =item L<Hash|Moose::Meta::Attribute::Native::Trait::Hash>
  
      has 'options' => (
          traits  => ['Hash'],
          is      => 'ro',
          isa     => 'HashRef[Str]',
          default => sub { {} },
          handles => {
              set_option => 'set',
              get_option => 'get',
              has_option => 'exists',
              # ...
          }
      );
  
  =item L<Number|Moose::Meta::Attribute::Native::Trait::Number>
  
      has 'integer' => (
          traits  => ['Number'],
          is      => 'ro',
          isa     => 'Int',
          default => 5,
          handles => {
              set => 'set',
              add => 'add',
              sub => 'sub',
              mul => 'mul',
              div => 'div',
              mod => 'mod',
              abs => 'abs',
              # ...
          }
      );
  
  =item L<String|Moose::Meta::Attribute::Native::Trait::String>
  
      has 'text' => (
          traits  => ['String'],
          is      => 'ro',
          isa     => 'Str',
          default => q{},
          handles => {
              add_text     => 'append',
              replace_text => 'replace',
              # ...
          }
      );
  
  =back
  
  =head1 COMPATIBILITY WITH MooseX::AttributeHelpers
  
  This feature used to be a separated CPAN distribution called
  L<MooseX::AttributeHelpers>.
  
  When the feature was incorporated into the Moose core, some of the API details
  were changed. The underlying capabilities are the same, but some details of
  the API were changed.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_META_ATTRIBUTE_NATIVE

$fatpacked{"i686-linux/Moose/Meta/Attribute/Native/Trait.pm"} = <<'I686-LINUX_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT';
  
  package Moose::Meta::Attribute::Native::Trait;
  BEGIN {
    $Moose::Meta::Attribute::Native::Trait::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Attribute::Native::Trait::VERSION = '2.0401';
  }
  use Moose::Role;
  
  use Class::Load qw(load_class);
  use List::MoreUtils qw( any uniq );
  use Moose::Util::TypeConstraints;
  use Moose::Deprecated;
  
  requires '_helper_type';
  
  has _used_default_is => (
      is      => 'rw',
      isa     => 'Bool',
      default => 0,
  );
  
  before '_process_options' => sub {
      my ( $self, $name, $options ) = @_;
  
      $self->_check_helper_type( $options, $name );
  
      if ( !( any { exists $options->{$_} } qw( is reader writer accessor ) )
          && $self->can('_default_is') ) {
  
          $options->{is} = $self->_default_is;
  
          $options->{_used_default_is} = 1;
      }
  
      if (
          !(
              $options->{required}
              || any { exists $options->{$_} } qw( default builder lazy_build )
          )
          && $self->can('_default_default')
          ) {
  
          $options->{default} = $self->_default_default;
  
          Moose::Deprecated::deprecated(
              feature => 'default default for Native Trait',
              message =>
                  'Allowing a native trait to automatically supply a default is deprecated.'
                  . ' You can avoid this warning by supplying a default, builder, or making the attribute required'
          );
      }
  };
  
  after 'install_accessors' => sub {
      my $self = shift;
  
      return unless $self->_used_default_is;
  
      my @methods
          = $self->_default_is eq 'rw'
          ? qw( reader writer accessor )
          : 'reader';
  
      my $name = $self->name;
      my $class = $self->associated_class->name;
  
      for my $meth ( uniq grep {defined} map { $self->$_ } @methods ) {
  
          my $message
              = "The $meth method in the $class class was automatically created"
              . " by the native delegation trait for the $name attribute."
              . q{ This "default is" feature is deprecated.}
              . q{ Explicitly set "is" or define accessor names to avoid this};
  
          $self->associated_class->add_before_method_modifier(
              $meth => sub {
                  Moose::Deprecated::deprecated(
                      feature => 'default is for Native Trait',
                      message =>$message,
                  );
              }
          );
      }
      };
  
  sub _check_helper_type {
      my ( $self, $options, $name ) = @_;
  
      my $type = $self->_helper_type;
  
      $options->{isa} = $type
          unless exists $options->{isa};
  
      my $isa = Moose::Util::TypeConstraints::find_or_create_type_constraint(
          $options->{isa} );
  
      ( $isa->is_a_type_of($type) )
          || confess
          "The type constraint for $name must be a subtype of $type but it's a $isa";
  }
  
  before 'install_accessors' => sub { (shift)->_check_handles_values };
  
  sub _check_handles_values {
      my $self = shift;
  
      my %handles = $self->_canonicalize_handles;
  
      for my $original_method ( values %handles ) {
          my $name = $original_method->[0];
  
          my $accessor_class = $self->_native_accessor_class_for($name);
  
          ( $accessor_class && $accessor_class->can('new') )
              || confess
              "$name is an unsupported method type - $accessor_class";
      }
  }
  
  around '_canonicalize_handles' => sub {
      shift;
      my $self    = shift;
      my $handles = $self->handles;
  
      return unless $handles;
  
      unless ( 'HASH' eq ref $handles ) {
          $self->throw_error(
              "The 'handles' option must be a HASH reference, not $handles");
      }
  
      return
          map { $_ => $self->_canonicalize_handles_value( $handles->{$_} ) }
          keys %$handles;
  };
  
  sub _canonicalize_handles_value {
      my $self  = shift;
      my $value = shift;
  
      if ( ref $value && 'ARRAY' ne ref $value ) {
          $self->throw_error(
              "All values passed to handles must be strings or ARRAY references, not $value"
          );
      }
  
      return ref $value ? $value : [$value];
  }
  
  around '_make_delegation_method' => sub {
      my $next = shift;
      my ( $self, $handle_name, $method_to_call ) = @_;
  
      my ( $name, @curried_args ) = @$method_to_call;
  
      my $accessor_class = $self->_native_accessor_class_for($name);
  
      die "Cannot find an accessor class for $name"
          unless $accessor_class && $accessor_class->can('new');
  
      return $accessor_class->new(
          name               => $handle_name,
          package_name       => $self->associated_class->name,
          delegate_to_method => $name,
          attribute          => $self,
          is_inline          => 1,
          curried_arguments  => \@curried_args,
          root_types         => [ $self->_root_types ],
      );
  };
  
  sub _root_types {
      return $_[0]->_helper_type;
  }
  
  sub _native_accessor_class_for {
      my ( $self, $suffix ) = @_;
  
      my $role
          = 'Moose::Meta::Method::Accessor::Native::'
          . $self->_native_type . '::'
          . $suffix;
  
      load_class($role);
      return Moose::Meta::Class->create_anon_class(
          superclasses =>
              [ $self->accessor_metaclass, $self->delegation_metaclass ],
          roles => [$role],
          cache => 1,
      )->name;
  }
  
  sub _build_native_type {
      my $self = shift;
  
      for my $role_name ( map { $_->name } $self->meta->calculate_all_roles ) {
          return $1 if $role_name =~ /::Native::Trait::(\w+)$/;
      }
  
      die "Cannot calculate native type for " . ref $self;
  }
  
  has '_native_type' => (
      is      => 'ro',
      isa     => 'Str',
      lazy    => 1,
      builder => '_build_native_type',
  );
  
  no Moose::Role;
  no Moose::Util::TypeConstraints;
  
  1;
  
  # ABSTRACT: Shared role for native delegation traits
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native::Trait - Shared role for native delegation traits
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 SEE ALSO
  
  Documentation for Moose native traits can be found in
  L<Moose::Meta::Attribute::Native>.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT

$fatpacked{"i686-linux/Moose/Meta/Attribute/Native/Trait/Array.pm"} = <<'I686-LINUX_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_ARRAY';
  
  package Moose::Meta::Attribute::Native::Trait::Array;
  BEGIN {
    $Moose::Meta::Attribute::Native::Trait::Array::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Attribute::Native::Trait::Array::VERSION = '2.0401';
  }
  use Moose::Role;
  
  with 'Moose::Meta::Attribute::Native::Trait';
  
  sub _helper_type { 'ArrayRef' }
  
  no Moose::Role;
  
  1;
  
  # ABSTRACT: Helper trait for ArrayRef attributes
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native::Trait::Array - Helper trait for ArrayRef attributes
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 SYNOPSIS
  
      package Stuff;
      use Moose;
  
      has 'options' => (
          traits  => ['Array'],
          is      => 'ro',
          isa     => 'ArrayRef[Str]',
          default => sub { [] },
          handles => {
              all_options    => 'elements',
              add_option     => 'push',
              map_options    => 'map',
              filter_options => 'grep',
              find_option    => 'first',
              get_option     => 'get',
              join_options   => 'join',
              count_options  => 'count',
              has_options    => 'count',
              has_no_options => 'is_empty',
              sorted_options => 'sort',
          },
      );
  
      no Moose;
      1;
  
  =head1 DESCRIPTION
  
  This trait provides native delegation methods for array references.
  
  =head1 DEFAULT TYPE
  
  If you don't provide an C<isa> value for your attribute, it will default to
  C<ArrayRef>.
  
  =head1 PROVIDED METHODS
  
  =over 4
  
  =item * B<count>
  
  Returns the number of elements in the array.
  
    $stuff = Stuff->new;
    $stuff->options( [ "foo", "bar", "baz", "boo" ] );
  
    print $stuff->count_options; # prints 4
  
  This method does not accept any arguments.
  
  =item * B<is_empty>
  
  Returns a boolean value that is true when the array has no elements.
  
    $stuff->has_no_options ? die "No options!\n" : print "Good boy.\n";
  
  This method does not accept any arguments.
  
  =item * B<elements>
  
  Returns all of the elements of the array as an array (not an array reference).
  
    my @option = $stuff->all_options;
    print "@options\n";    # prints "foo bar baz boo"
  
  This method does not accept any arguments.
  
  =item * B<get($index)>
  
  Returns an element of the array by its index. You can also use negative index
  numbers, just as with Perl's core array handling.
  
    my $option = $stuff->get_option(1);
    print "$option\n";    # prints "bar"
  
  If the specified element does not exist, this will return C<undef>.
  
  This method accepts just one argument.
  
  =item * B<pop>
  
  Just like Perl's builtin C<pop>.
  
  This method does not accept any arguments.
  
  =item * B<push($value1, $value2, value3 ...)>
  
  Just like Perl's builtin C<push>. Returns the number of elements in the new
  array.
  
  This method accepts any number of arguments.
  
  =item * B<shift>
  
  Just like Perl's builtin C<shift>.
  
  This method does not accept any arguments.
  
  =item * B<unshift($value1, $value2, value3 ...)>
  
  Just like Perl's builtin C<unshift>. Returns the number of elements in the new
  array.
  
  This method accepts any number of arguments.
  
  =item * B<splice($offset, $length, @values)>
  
  Just like Perl's builtin C<splice>. In scalar context, this returns the last
  element removed, or C<undef> if no elements were removed. In list context,
  this returns all the elements removed from the array.
  
  This method requires at least one argument.
  
  =item * B<first( sub { ... } )>
  
  This method returns the first matching item in the array, just like
  L<List::Util>'s C<first> function. The matching is done with a subroutine
  reference you pass to this method. The subroutine will be called against each
  element in the array until one matches or all elements have been checked.
  
    my $found = $stuff->find_option( sub {/^b/} );
    print "$found\n";    # prints "bar"
  
  This method requires a single argument.
  
  =item * B<first_index( sub { ... } )>
  
  This method returns the index of the first matching item in the array, just
  like L<List::MoreUtils>'s C<first_index> function. The matching is done with a
  subroutine reference you pass to this method. The subroutine will be called
  against each element in the array until one matches or all elements have been
  checked.
  
  This method requires a single argument.
  
  =item * B<grep( sub { ... } )>
  
  This method returns every element matching a given criteria, just like Perl's
  core C<grep> function. This method requires a subroutine which implements the
  matching logic.
  
    my @found = $stuff->filter_options( sub {/^b/} );
    print "@found\n";    # prints "bar baz boo"
  
  This method requires a single argument.
  
  =item * B<map( sub { ... } )>
  
  This method transforms every element in the array and returns a new array,
  just like Perl's core C<map> function. This method requires a subroutine which
  implements the transformation.
  
    my @mod_options = $stuff->map_options( sub { $_ . "-tag" } );
    print "@mod_options\n";    # prints "foo-tag bar-tag baz-tag boo-tag"
  
  This method requires a single argument.
  
  =item * B<reduce( sub { ... } )>
  
  This method turns an array into a single value, by passing a function the
  value so far and the next value in the array, just like L<List::Util>'s
  C<reduce> function. The reducing is done with a subroutine reference you pass
  to this method.
  
    my $found = $stuff->reduce_options( sub { $_[0] . $_[1] } );
    print "$found\n";    # prints "foobarbazboo"
  
  This method requires a single argument.
  
  =item * B<sort>
  
  =item * B<sort( sub { ... } )>
  
  Returns the elements of the array in sorted order.
  
  You can provide an optional subroutine reference to sort with (as you can with
  Perl's core C<sort> function). However, instead of using C<$a> and C<$b> in
  this subroutine, you will need to use C<$_[0]> and C<$_[1]>.
  
    # ascending ASCIIbetical
    my @sorted = $stuff->sort_options();
  
    # Descending alphabetical order
    my @sorted_options = $stuff->sort_options( sub { lc $_[1] cmp lc $_[0] } );
    print "@sorted_options\n";    # prints "foo boo baz bar"
  
  This method accepts a single argument.
  
  =item * B<sort_in_place>
  
  =item * B<sort_in_place( sub { ... } )>
  
  Sorts the array I<in place>, modifying the value of the attribute.
  
  You can provide an optional subroutine reference to sort with (as you can with
  Perl's core C<sort> function). However, instead of using C<$a> and C<$b>, you
  will need to use C<$_[0]> and C<$_[1]> instead.
  
  This method does not define a return value.
  
  This method accepts a single argument.
  
  =item * B<shuffle>
  
  Returns the elements of the array in random order, like C<shuffle> from
  L<List::Util>.
  
  This method does not accept any arguments.
  
  =item * B<uniq>
  
  Returns the array with all duplicate elements removed, like C<uniq> from
  L<List::MoreUtils>.
  
  This method does not accept any arguments.
  
  =item * B<join($str)>
  
  Joins every element of the array using the separator given as argument, just
  like Perl's core C<join> function.
  
    my $joined = $stuff->join_options(':');
    print "$joined\n";    # prints "foo:bar:baz:boo"
  
  This method requires a single argument.
  
  =item * B<set($index, $value)>
  
  Given an index and a value, sets the specified array element's value.
  
  This method returns the value at C<$index> after the set.
  
  This method requires two arguments.
  
  =item * B<delete($index)>
  
  Removes the element at the given index from the array.
  
  This method returns the deleted value. Note that if no value exists, it will
  return C<undef>.
  
  This method requires one argument.
  
  =item * B<insert($index, $value)>
  
  Inserts a new element into the array at the given index.
  
  This method returns the new value at C<$index>.
  
  This method requires two arguments.
  
  =item * B<clear>
  
  Empties the entire array, like C<@array = ()>.
  
  This method does not define a return value.
  
  This method does not accept any arguments.
  
  =item * B<accessor($index)>
  
  =item * B<accessor($index, $value)>
  
  This method provides a get/set accessor for the array, based on array indexes.
  If passed one argument, it returns the value at the specified index.  If
  passed two arguments, it sets the value of the specified index.
  
  When called as a setter, this method returns the new value at C<$index>.
  
  This method accepts one or two arguments.
  
  =item * B<natatime($n)>
  
  =item * B<natatime($n, $code)>
  
  This method returns an iterator which, on each call, returns C<$n> more items
  from the array, in order, like C<natatime> from L<List::MoreUtils>. A coderef
  can optionally be provided; it will be called on each group of C<$n> elements
  in the array.
  
  This method accepts one or two arguments.
  
  =item * B<shallow_clone>
  
  This method returns a shallow clone of the array reference.  The return value
  is a reference to a new array with the same elements.  It is I<shallow>
  because any elements that were references in the original will be the I<same>
  references in the clone.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_ARRAY

$fatpacked{"i686-linux/Moose/Meta/Attribute/Native/Trait/Bool.pm"} = <<'I686-LINUX_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_BOOL';
  package Moose::Meta::Attribute::Native::Trait::Bool;
  BEGIN {
    $Moose::Meta::Attribute::Native::Trait::Bool::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Attribute::Native::Trait::Bool::VERSION = '2.0401';
  }
  use Moose::Role;
  
  with 'Moose::Meta::Attribute::Native::Trait';
  
  sub _default_is  { 'rw' }
  sub _helper_type { 'Bool' }
  
  no Moose::Role;
  
  1;
  
  # ABSTRACT: Helper trait for Bool attributes
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native::Trait::Bool - Helper trait for Bool attributes
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 SYNOPSIS
  
    package Room;
    use Moose;
  
    has 'is_lit' => (
        traits  => ['Bool'],
        is      => 'rw',
        isa     => 'Bool',
        default => 0,
        handles => {
            illuminate  => 'set',
            darken      => 'unset',
            flip_switch => 'toggle',
            is_dark     => 'not',
        },
    );
  
    my $room = Room->new();
    $room->illuminate;        # same as $room->is_lit(1);
    $room->darken;            # same as $room->is_lit(0);
    $room->flip_switch;       # same as $room->is_lit(not $room->is_lit);
    return $room->is_dark;    # same as !$room->is_lit
  
  =head1 DESCRIPTION
  
  This trait provides native delegation methods for boolean values. A boolean is
  a scalar which can be C<1>, C<0>, C<"">, or C<undef>.
  
  =head1 DEFAULT TYPE
  
  If you don't provide an C<isa> value for your attribute, it will default to
  C<Bool>.
  
  =head1 PROVIDED METHODS
  
  None of these methods accept arguments.
  
  =over 4
  
  =item * B<set>
  
  Sets the value to C<1> and returns C<1>.
  
  =item * B<unset>
  
  Set the value to C<0> and returns C<0>.
  
  =item * B<toggle>
  
  Toggles the value. If it's true, set to false, and vice versa.
  
  Returns the new value.
  
  =item * B<not>
  
  Equivalent of 'not C<$value>'.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_BOOL

$fatpacked{"i686-linux/Moose/Meta/Attribute/Native/Trait/Code.pm"} = <<'I686-LINUX_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_CODE';
  package Moose::Meta::Attribute::Native::Trait::Code;
  BEGIN {
    $Moose::Meta::Attribute::Native::Trait::Code::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Attribute::Native::Trait::Code::VERSION = '2.0401';
  }
  use Moose::Role;
  
  with 'Moose::Meta::Attribute::Native::Trait';
  
  sub _helper_type { 'CodeRef' }
  
  no Moose::Role;
  
  1;
  
  # ABSTRACT: Helper trait for CodeRef attributes
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native::Trait::Code - Helper trait for CodeRef attributes
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 SYNOPSIS
  
    package Foo;
    use Moose;
  
    has 'callback' => (
        traits  => ['Code'],
        is      => 'ro',
        isa     => 'CodeRef',
        default => sub {
            sub { print "called" }
        },
        handles => {
            call => 'execute',
        },
    );
  
    my $foo = Foo->new;
    $foo->call;    # prints "called"
  
  =head1 DESCRIPTION
  
  This trait provides native delegation methods for code references.
  
  =head1 DEFAULT TYPE
  
  If you don't provide an C<isa> value for your attribute, it will default to
  C<CodeRef>.
  
  =head1 PROVIDED METHODS
  
  =over 4
  
  =item * B<execute(@args)>
  
  Calls the coderef with the given args.
  
  =item * B<execute_method(@args)>
  
  Calls the coderef with the the instance as invocant and given args.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_CODE

$fatpacked{"i686-linux/Moose/Meta/Attribute/Native/Trait/Counter.pm"} = <<'I686-LINUX_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_COUNTER';
  
  package Moose::Meta::Attribute::Native::Trait::Counter;
  BEGIN {
    $Moose::Meta::Attribute::Native::Trait::Counter::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Attribute::Native::Trait::Counter::VERSION = '2.0401';
  }
  use Moose::Role;
  
  with 'Moose::Meta::Attribute::Native::Trait' =>
      { -excludes => ['_root_types'] };
  
  sub _default_default { 0 }
  sub _default_is { 'ro' }
  sub _helper_type { 'Num' }
  sub _root_types { 'Num', 'Int' }
  
  no Moose::Role;
  
  1;
  
  # ABSTRACT: Helper trait for Int attributes which represent counters
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native::Trait::Counter - Helper trait for Int attributes which represent counters
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 SYNOPSIS
  
    package MyHomePage;
    use Moose;
  
    has 'counter' => (
        traits  => ['Counter'],
        is      => 'ro',
        isa     => 'Num',
        default => 0,
        handles => {
            inc_counter   => 'inc',
            dec_counter   => 'dec',
            reset_counter => 'reset',
        },
    );
  
    my $page = MyHomePage->new();
    $page->inc_counter;    # same as $page->counter( $page->counter + 1 );
    $page->dec_counter;    # same as $page->counter( $page->counter - 1 );
  
    my $count_by_twos = 2;
    $page->inc_counter($count_by_twos);
  
  =head1 DESCRIPTION
  
  This trait provides native delegation methods for counters. A counter can be
  any sort of number (integer or not). The delegation methods allow you to
  increment, decrement, or reset the value.
  
  =head1 DEFAULT TYPE
  
  If you don't provide an C<isa> value for your attribute, it will default to
  C<Num>.
  
  =head1 PROVIDED METHODS
  
  =over 4
  
  =item * B<set($value)>
  
  Sets the counter to the specified value and returns the new value.
  
  This method requires a single argument.
  
  =item * B<inc>
  
  =item * B<inc($arg)>
  
  Increases the attribute value by the amount of the argument, or by 1 if no
  argument is given. This method returns the new value.
  
  This method accepts a single argument.
  
  =item * B<dec>
  
  =item * B<dec($arg)>
  
  Decreases the attribute value by the amount of the argument, or by 1 if no
  argument is given. This method returns the new value.
  
  This method accepts a single argument.
  
  =item * B<reset>
  
  Resets the value stored in this slot to its default value, and returns the new
  value.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_COUNTER

$fatpacked{"i686-linux/Moose/Meta/Attribute/Native/Trait/Hash.pm"} = <<'I686-LINUX_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_HASH';
  
  package Moose::Meta::Attribute::Native::Trait::Hash;
  BEGIN {
    $Moose::Meta::Attribute::Native::Trait::Hash::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Attribute::Native::Trait::Hash::VERSION = '2.0401';
  }
  use Moose::Role;
  
  with 'Moose::Meta::Attribute::Native::Trait';
  
  sub _helper_type { 'HashRef' }
  
  no Moose::Role;
  
  1;
  
  # ABSTRACT: Helper trait for HashRef attributes
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native::Trait::Hash - Helper trait for HashRef attributes
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 SYNOPSIS
  
    package Stuff;
    use Moose;
  
    has 'options' => (
        traits    => ['Hash'],
        is        => 'ro',
        isa       => 'HashRef[Str]',
        default   => sub { {} },
        handles   => {
            set_option     => 'set',
            get_option     => 'get',
            has_no_options => 'is_empty',
            num_options    => 'count',
            delete_option  => 'delete',
            option_pairs   => 'kv',
        },
    );
  
  =head1 DESCRIPTION
  
  This trait provides native delegation methods for hash references.
  
  =head1 PROVIDED METHODS
  
  =over 4
  
  =item B<get($key, $key2, $key3...)>
  
  Returns values from the hash.
  
  In list context it returns a list of values in the hash for the given keys. In
  scalar context it returns the value for the last key specified.
  
  This method requires at least one argument.
  
  =item B<set($key =E<gt> $value, $key2 =E<gt> $value2...)>
  
  Sets the elements in the hash to the given values. It returns the new values
  set for each key, in the same order as the keys passed to the method.
  
  This method requires at least two arguments, and expects an even number of
  arguments.
  
  =item B<delete($key, $key2, $key3...)>
  
  Removes the elements with the given keys.
  
  In list context it returns a list of values in the hash for the deleted
  keys. In scalar context it returns the value for the last key specified.
  
  =item B<keys>
  
  Returns the list of keys in the hash.
  
  This method does not accept any arguments.
  
  =item B<exists($key)>
  
  Returns true if the given key is present in the hash.
  
  This method requires a single argument.
  
  =item B<defined($key)>
  
  Returns true if the value of a given key is defined.
  
  This method requires a single argument.
  
  =item B<values>
  
  Returns the list of values in the hash.
  
  This method does not accept any arguments.
  
  =item B<kv>
  
  Returns the key/value pairs in the hash as an array of array references.
  
    for my $pair ( $object->options->kv ) {
        print "$pair->[0] = $pair->[1]\n";
    }
  
  This method does not accept any arguments.
  
  =item B<elements>
  
  Returns the key/value pairs in the hash as a flattened list..
  
  This method does not accept any arguments.
  
  =item B<clear>
  
  Resets the hash to an empty value, like C<%hash = ()>.
  
  This method does not accept any arguments.
  
  =item B<count>
  
  Returns the number of elements in the hash. Also useful for not empty:
  C<< has_options => 'count' >>.
  
  This method does not accept any arguments.
  
  =item B<is_empty>
  
  If the hash is populated, returns false. Otherwise, returns true.
  
  This method does not accept any arguments.
  
  =item B<accessor($key)>
  
  =item B<accessor($key, $value)>
  
  If passed one argument, returns the value of the specified key. If passed two
  arguments, sets the value of the specified key.
  
  When called as a setter, this method returns the value that was set.
  
  =item B<shallow_clone>
  
  This method returns a shallow clone of the hash reference.  The return value
  is a reference to a new hash with the same keys and values.  It is I<shallow>
  because any values that were references in the original will be the I<same>
  references in the clone.
  
  =back
  
  Note that C<each> is deliberately omitted, due to its stateful interaction
  with the hash iterator. C<keys> or C<kv> are much safer.
  
  =head1 METHODS
  
  =over 4
  
  =item B<meta>
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_HASH

$fatpacked{"i686-linux/Moose/Meta/Attribute/Native/Trait/Number.pm"} = <<'I686-LINUX_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_NUMBER';
  package Moose::Meta::Attribute::Native::Trait::Number;
  BEGIN {
    $Moose::Meta::Attribute::Native::Trait::Number::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Attribute::Native::Trait::Number::VERSION = '2.0401';
  }
  use Moose::Role;
  
  with 'Moose::Meta::Attribute::Native::Trait';
  
  sub _helper_type { 'Num' }
  
  no Moose::Role;
  
  1;
  
  # ABSTRACT: Helper trait for Num attributes
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native::Trait::Number - Helper trait for Num attributes
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 SYNOPSIS
  
    package Real;
    use Moose;
  
    has 'integer' => (
        traits  => ['Number'],
        is      => 'ro',
        isa     => 'Num',
        default => 5,
        handles => {
            set => 'set',
            add => 'add',
            sub => 'sub',
            mul => 'mul',
            div => 'div',
            mod => 'mod',
            abs => 'abs',
        },
    );
  
    my $real = Real->new();
    $real->add(5);    # same as $real->integer($real->integer + 5);
    $real->sub(2);    # same as $real->integer($real->integer - 2);
  
  =head1 DESCRIPTION
  
  This trait provides native delegation methods for numbers. All of the
  operations correspond to arithmetic operations like addition or
  multiplication.
  
  =head1 DEFAULT TYPE
  
  If you don't provide an C<isa> value for your attribute, it will default to
  C<Num>.
  
  =head1 PROVIDED METHODS
  
  All of these methods modify the attribute's value in place. All methods return
  the new value.
  
  =over 4
  
  =item * B<add($value)>
  
  Adds the current value of the attribute to C<$value>.
  
  =item * B<sub($value)>
  
  Subtracts C<$value> from the current value of the attribute.
  
  =item * B<mul($value)>
  
  Multiplies the current value of the attribute by C<$value>.
  
  =item * B<div($value)>
  
  Divides the current value of the attribute by C<$value>.
  
  =item * B<mod($value)>
  
  Returns the current value of the attribute modulo C<$value>.
  
  =item * B<abs>
  
  Sets the current value of the attribute to its absolute value.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_NUMBER

$fatpacked{"i686-linux/Moose/Meta/Attribute/Native/Trait/String.pm"} = <<'I686-LINUX_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_STRING';
  package Moose::Meta::Attribute::Native::Trait::String;
  BEGIN {
    $Moose::Meta::Attribute::Native::Trait::String::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Attribute::Native::Trait::String::VERSION = '2.0401';
  }
  use Moose::Role;
  
  with 'Moose::Meta::Attribute::Native::Trait';
  
  sub _default_default { q{} }
  sub _default_is { 'rw' }
  sub _helper_type { 'Str' }
  
  no Moose::Role;
  
  1;
  
  # ABSTRACT: Helper trait for Str attributes
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::Attribute::Native::Trait::String - Helper trait for Str attributes
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 SYNOPSIS
  
    package MyHomePage;
    use Moose;
  
    has 'text' => (
        traits  => ['String'],
        is      => 'rw',
        isa     => 'Str',
        default => q{},
        handles => {
            add_text     => 'append',
            replace_text => 'replace',
        },
    );
  
    my $page = MyHomePage->new();
    $page->add_text("foo");    # same as $page->text($page->text . "foo");
  
  =head1 DESCRIPTION
  
  This trait provides native delegation methods for strings.
  
  =head1 DEFAULT TYPE
  
  If you don't provide an C<isa> value for your attribute, it will default to
  C<Str>.
  
  =head1 PROVIDED METHODS
  
  =over 4
  
  =item * B<inc>
  
  Increments the value stored in this slot using the magical string autoincrement
  operator. Note that Perl doesn't provide analogous behavior in C<-->, so
  C<dec> is not available. This method returns the new value.
  
  This method does not accept any arguments.
  
  =item * B<append($string)>
  
  Appends to the string, like C<.=>, and returns the new value.
  
  This method requires a single argument.
  
  =item * B<prepend($string)>
  
  Prepends to the string and returns the new value.
  
  This method requires a single argument.
  
  =item * B<replace($pattern, $replacement)>
  
  Performs a regexp substitution (L<perlop/s>). There is no way to provide the
  C<g> flag, but code references will be accepted for the replacement, causing
  the regex to be modified with a single C<e>. C</smxi> can be applied using the
  C<qr> operator. This method returns the new value.
  
  This method requires two arguments.
  
  =item * B<match($pattern)>
  
  Runs the regex against the string and returns the matching value(s).
  
  This method requires a single argument.
  
  =item * B<chop>
  
  Just like L<perlfunc/chop>. This method returns the chopped character.
  
  This method does not accept any arguments.
  
  =item * B<chomp>
  
  Just like L<perlfunc/chomp>. This method returns the number of characters
  removed.
  
  This method does not accept any arguments.
  
  =item * B<clear>
  
  Sets the string to the empty string (not the value passed to C<default>).
  
  This method does not have a defined return value.
  
  This method does not accept any arguments.
  
  =item * B<length>
  
  Just like L<perlfunc/length>, returns the length of the string.
  
  =item * B<substr>
  
  This acts just like L<perlfunc/substr>. When called as a writer, it returns
  the substring that was replaced, just like the Perl builtin.
  
  This method requires at least one argument, and accepts no more than three.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_META_ATTRIBUTE_NATIVE_TRAIT_STRING

$fatpacked{"i686-linux/Moose/Meta/Class.pm"} = <<'I686-LINUX_MOOSE_META_CLASS';
  
  package Moose::Meta::Class;
  BEGIN {
    $Moose::Meta::Class::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Class::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Class::Load qw(load_class);
  use Class::MOP;
  use Carp qw( confess );
  use Data::OptList;
  use List::Util qw( first );
  use List::MoreUtils qw( any all uniq first_index );
  use Scalar::Util 'blessed';
  
  use Moose::Meta::Method::Overridden;
  use Moose::Meta::Method::Augmented;
  use Moose::Error::Default;
  use Moose::Meta::Class::Immutable::Trait;
  use Moose::Meta::Method::Constructor;
  use Moose::Meta::Method::Destructor;
  use Moose::Meta::Method::Meta;
  use Moose::Util;
  use Class::MOP::MiniTrait;
  
  use base 'Class::MOP::Class';
  
  Class::MOP::MiniTrait::apply(__PACKAGE__, 'Moose::Meta::Object::Trait');
  
  __PACKAGE__->meta->add_attribute('roles' => (
      reader  => 'roles',
      default => sub { [] },
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('role_applications' => (
      reader  => '_get_role_applications',
      default => sub { [] },
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute(
      Class::MOP::Attribute->new('immutable_trait' => (
          accessor => "immutable_trait",
          default  => 'Moose::Meta::Class::Immutable::Trait',
          Class::MOP::_definition_context(),
      ))
  );
  
  __PACKAGE__->meta->add_attribute('constructor_class' => (
      accessor => 'constructor_class',
      default  => 'Moose::Meta::Method::Constructor',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('destructor_class' => (
      accessor => 'destructor_class',
      default  => 'Moose::Meta::Method::Destructor',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('error_class' => (
      accessor => 'error_class',
      default  => 'Moose::Error::Default',
      Class::MOP::_definition_context(),
  ));
  
  sub initialize {
      my $class = shift;
      my @args = @_;
      unshift @args, 'package' if @args % 2;
      my %opts = @args;
      my $package = delete $opts{package};
      return Class::MOP::get_metaclass_by_name($package)
          || $class->SUPER::initialize($package,
                  'attribute_metaclass' => 'Moose::Meta::Attribute',
                  'method_metaclass'    => 'Moose::Meta::Method',
                  'instance_metaclass'  => 'Moose::Meta::Instance',
                  %opts,
              );
  }
  
  sub create {
      my $class = shift;
      my @args = @_;
  
      unshift @args, 'package' if @args % 2 == 1;
      my %options = @args;
  
      (ref $options{roles} eq 'ARRAY')
          || $class->throw_error("You must pass an ARRAY ref of roles", data => $options{roles})
              if exists $options{roles};
  
      my $package = delete $options{package};
      my $roles   = delete $options{roles};
  
      my $new_meta = $class->SUPER::create($package, %options);
  
      if ($roles) {
          Moose::Util::apply_all_roles( $new_meta, @$roles );
      }
  
      return $new_meta;
  }
  
  sub _meta_method_class { 'Moose::Meta::Method::Meta' }
  
  sub _anon_package_prefix { 'Moose::Meta::Class::__ANON__::SERIAL::' }
  
  sub _anon_cache_key {
      my $class = shift;
      my %options = @_;
  
      my $superclass_key = join('|',
          map { $_->[0] } @{ Data::OptList::mkopt($options{superclasses} || []) }
      );
  
      my $roles = Data::OptList::mkopt(($options{roles} || []), {
          moniker  => 'role',
          val_test => sub { ref($_[0]) eq 'HASH' },
      });
  
      my @role_keys;
      for my $role_spec (@$roles) {
          my ($role, $params) = @$role_spec;
          $params = { %$params } if $params;
  
          my $key = blessed($role) ? $role->name : $role;
  
          if ($params && %$params) {
              my $alias    = delete $params->{'-alias'}
                          || delete $params->{'alias'}
                          || {};
              my $excludes = delete $params->{'-excludes'}
                          || delete $params->{'excludes'}
                          || [];
              $excludes = [$excludes] unless ref($excludes) eq 'ARRAY';
  
              if (%$params) {
                  warn "Roles with parameters cannot be cached. Consider "
                     . "applying the parameters before calling "
                     . "create_anon_class, or using 'weaken => 0' instead";
                  return;
              }
  
              my $alias_key = join('%',
                  map { $_ => $alias->{$_} } sort keys %$alias
              );
              my $excludes_key = join('%',
                  sort @$excludes
              );
              $key .= '<' . join('+', 'a', $alias_key, 'e', $excludes_key) . '>';
          }
  
          push @role_keys, $key;
      }
  
      my $role_key = join('|', sort @role_keys);
  
      # Makes something like Super::Class|Super::Class::2=Role|Role::1
      return join('=', $superclass_key, $role_key);
  }
  
  sub reinitialize {
      my $self = shift;
      my $pkg  = shift;
  
      my $meta = blessed $pkg ? $pkg : Class::MOP::class_of($pkg);
  
      my %existing_classes;
      if ($meta) {
          %existing_classes = map { $_ => $meta->$_() } qw(
              attribute_metaclass
              method_metaclass
              wrapped_method_metaclass
              instance_metaclass
              constructor_class
              destructor_class
              error_class
          );
      }
  
      return $self->SUPER::reinitialize(
          $pkg,
          %existing_classes,
          @_,
      );
  }
  
  sub add_role {
      my ($self, $role) = @_;
      (blessed($role) && $role->isa('Moose::Meta::Role'))
          || $self->throw_error("Roles must be instances of Moose::Meta::Role", data => $role);
      push @{$self->roles} => $role;
  }
  
  sub role_applications {
      my ($self) = @_;
  
      return @{$self->_get_role_applications};
  }
  
  sub add_role_application {
      my ($self, $application) = @_;
      (blessed($application) && $application->isa('Moose::Meta::Role::Application::ToClass'))
          || $self->throw_error("Role applications must be instances of Moose::Meta::Role::Application::ToClass", data => $application);
      push @{$self->_get_role_applications} => $application;
  }
  
  sub calculate_all_roles {
      my $self = shift;
      my %seen;
      grep { !$seen{$_->name}++ } map { $_->calculate_all_roles } @{ $self->roles };
  }
  
  sub calculate_all_roles_with_inheritance {
      my $self = shift;
      my %seen;
      grep { !$seen{$_->name}++ }
           map { Class::MOP::class_of($_)->can('calculate_all_roles')
                     ? Class::MOP::class_of($_)->calculate_all_roles
                     : () }
               $self->linearized_isa;
  }
  
  sub does_role {
      my ($self, $role_name) = @_;
  
      (defined $role_name)
          || $self->throw_error("You must supply a role name to look for");
  
      foreach my $class ($self->class_precedence_list) {
          my $meta = Class::MOP::class_of($class);
          # when a Moose metaclass is itself extended with a role,
          # this check needs to be done since some items in the
          # class_precedence_list might in fact be Class::MOP
          # based still.
          next unless $meta && $meta->can('roles');
          foreach my $role (@{$meta->roles}) {
              return 1 if $role->does_role($role_name);
          }
      }
      return 0;
  }
  
  sub excludes_role {
      my ($self, $role_name) = @_;
  
      (defined $role_name)
          || $self->throw_error("You must supply a role name to look for");
  
      foreach my $class ($self->class_precedence_list) {
          my $meta = Class::MOP::class_of($class);
          # when a Moose metaclass is itself extended with a role,
          # this check needs to be done since some items in the
          # class_precedence_list might in fact be Class::MOP
          # based still.
          next unless $meta && $meta->can('roles');
          foreach my $role (@{$meta->roles}) {
              return 1 if $role->excludes_role($role_name);
          }
      }
      return 0;
  }
  
  sub new_object {
      my $self   = shift;
      my $params = @_ == 1 ? $_[0] : {@_};
      my $object = $self->SUPER::new_object($params);
  
      $self->_call_all_triggers($object, $params);
  
      $object->BUILDALL($params) if $object->can('BUILDALL');
  
      return $object;
  }
  
  sub _call_all_triggers {
      my ($self, $object, $params) = @_;
  
      foreach my $attr ( $self->get_all_attributes() ) {
  
          next unless $attr->can('has_trigger') && $attr->has_trigger;
  
          my $init_arg = $attr->init_arg;
          next unless defined $init_arg;
          next unless exists $params->{$init_arg};
  
          $attr->trigger->(
              $object,
              (
                    $attr->should_coerce
                  ? $attr->get_read_method_ref->($object)
                  : $params->{$init_arg}
              ),
          );
      }
  }
  
  sub _generate_fallback_constructor {
      my $self = shift;
      my ($class) = @_;
      return $class . '->Moose::Object::new(@_)'
  }
  
  sub _inline_params {
      my $self = shift;
      my ($params, $class) = @_;
      return (
          'my ' . $params . ' = ',
          $self->_inline_BUILDARGS($class, '@_'),
          ';',
      );
  }
  
  sub _inline_BUILDARGS {
      my $self = shift;
      my ($class, $args) = @_;
  
      my $buildargs = $self->find_method_by_name("BUILDARGS");
  
      if ($args eq '@_'
       && (!$buildargs or $buildargs->body == \&Moose::Object::BUILDARGS)) {
          return (
              'do {',
                  'my $params;',
                  'if (scalar @_ == 1) {',
                      'if (!defined($_[0]) || ref($_[0]) ne \'HASH\') {',
                          $self->_inline_throw_error(
                              '"Single parameters to new() must be a HASH ref"',
                              'data => $_[0]',
                          ) . ';',
                      '}',
                      '$params = { %{ $_[0] } };',
                  '}',
                  'elsif (@_ % 2) {',
                      'Carp::carp(',
                          '"The new() method for ' . $class . ' expects a '
                        . 'hash reference or a key/value list. You passed an '
                        . 'odd number of arguments"',
                      ');',
                      '$params = {@_, undef};',
                  '}',
                  'else {',
                      '$params = {@_};',
                  '}',
                  '$params;',
              '}',
          );
      }
      else {
          return $class . '->BUILDARGS(' . $args . ')';
      }
  }
  
  sub _inline_slot_initializer {
      my $self  = shift;
      my ($attr, $idx) = @_;
  
      return (
          '## ' . $attr->name,
          $self->_inline_check_required_attr($attr),
          $self->SUPER::_inline_slot_initializer(@_),
      );
  }
  
  sub _inline_check_required_attr {
      my $self = shift;
      my ($attr) = @_;
  
      return unless defined $attr->init_arg;
      return unless $attr->can('is_required') && $attr->is_required;
      return if $attr->has_default || $attr->has_builder;
  
      return (
          'if (!exists $params->{\'' . $attr->init_arg . '\'}) {',
              $self->_inline_throw_error(
                  '"Attribute (' . quotemeta($attr->name) . ') is required"'
              ) . ';',
          '}',
      );
  }
  
  # XXX: these two are duplicated from cmop, because we have to pass the tc stuff
  # through to _inline_set_value - this should probably be fixed, but i'm not
  # quite sure how. -doy
  sub _inline_init_attr_from_constructor {
      my $self = shift;
      my ($attr, $idx) = @_;
  
      my @initial_value = $attr->_inline_set_value(
          '$instance',
          '$params->{\'' . $attr->init_arg . '\'}',
          '$type_constraint_bodies[' . $idx . ']',
          '$type_coercions[' . $idx . ']',
          '$type_constraint_messages[' . $idx . ']',
          'for constructor',
      );
  
      push @initial_value, (
          '$attrs->[' . $idx . ']->set_initial_value(',
              '$instance,',
              $attr->_inline_instance_get('$instance'),
          ');',
      ) if $attr->has_initializer;
  
      return @initial_value;
  }
  
  sub _inline_init_attr_from_default {
      my $self = shift;
      my ($attr, $idx) = @_;
  
      return if $attr->can('is_lazy') && $attr->is_lazy;
      my $default = $self->_inline_default_value($attr, $idx);
      return unless $default;
  
      my @initial_value = (
          'my $default = ' . $default . ';',
          $attr->_inline_set_value(
              '$instance',
              '$default',
              '$type_constraint_bodies[' . $idx . ']',
              '$type_coercions[' . $idx . ']',
              '$type_constraint_messages[' . $idx . ']',
              'for constructor',
          ),
      );
  
      push @initial_value, (
          '$attrs->[' . $idx . ']->set_initial_value(',
              '$instance,',
              $attr->_inline_instance_get('$instance'),
          ');',
      ) if $attr->has_initializer;
  
      return @initial_value;
  }
  
  sub _inline_extra_init {
      my $self = shift;
      return (
          $self->_inline_triggers,
          $self->_inline_BUILDALL,
      );
  }
  
  sub _inline_triggers {
      my $self = shift;
      my @trigger_calls;
  
      my @attrs = sort { $a->name cmp $b->name } $self->get_all_attributes;
      for my $i (0 .. $#attrs) {
          my $attr = $attrs[$i];
  
          next unless $attr->can('has_trigger') && $attr->has_trigger;
  
          my $init_arg = $attr->init_arg;
          next unless defined $init_arg;
  
          push @trigger_calls,
              'if (exists $params->{\'' . $init_arg . '\'}) {',
                  '$triggers->[' . $i . ']->(',
                      '$instance,',
                      $attr->_inline_instance_get('$instance') . ',',
                  ');',
              '}';
      }
  
      return @trigger_calls;
  }
  
  sub _inline_BUILDALL {
      my $self = shift;
  
      my @methods = reverse $self->find_all_methods_by_name('BUILD');
      my @BUILD_calls;
  
      foreach my $method (@methods) {
          push @BUILD_calls,
              '$instance->' . $method->{class} . '::BUILD($params);';
      }
  
      return @BUILD_calls;
  }
  
  sub _eval_environment {
      my $self = shift;
  
      my @attrs = sort { $a->name cmp $b->name } $self->get_all_attributes;
  
      my $triggers = [
          map { $_->can('has_trigger') && $_->has_trigger ? $_->trigger : undef }
              @attrs
      ];
  
      # We need to check if the attribute ->can('type_constraint')
      # since we may be trying to immutabilize a Moose meta class,
      # which in turn has attributes which are Class::MOP::Attribute
      # objects, rather than Moose::Meta::Attribute. And
      # Class::MOP::Attribute attributes have no type constraints.
      # However we need to make sure we leave an undef value there
      # because the inlined code is using the index of the attributes
      # to determine where to find the type constraint
  
      my @type_constraints = map {
          $_->can('type_constraint') ? $_->type_constraint : undef
      } @attrs;
  
      my @type_constraint_bodies = map {
          defined $_ ? $_->_compiled_type_constraint : undef;
      } @type_constraints;
  
      my @type_coercions = map {
          defined $_ && $_->has_coercion
              ? $_->coercion->_compiled_type_coercion
              : undef
      } @type_constraints;
  
      my @type_constraint_messages = map {
          defined $_
              ? ($_->has_message ? $_->message : $_->_default_message)
              : undef
      } @type_constraints;
  
      return {
          %{ $self->SUPER::_eval_environment },
          ((any { defined && $_->has_initializer } @attrs)
              ? ('$attrs' => \[@attrs])
              : ()),
          '$triggers' => \$triggers,
          '@type_coercions' => \@type_coercions,
          '@type_constraint_bodies' => \@type_constraint_bodies,
          '@type_constraint_messages' => \@type_constraint_messages,
          ( map { defined($_) ? %{ $_->inline_environment } : () }
                @type_constraints ),
          # pretty sure this is only going to be closed over if you use a custom
          # error class at this point, but we should still get rid of this
          # at some point
          '$meta'  => \$self,
      };
  }
  
  sub superclasses {
      my $self = shift;
      my $supers = Data::OptList::mkopt(\@_);
      foreach my $super (@{ $supers }) {
          my ($name, $opts) = @{ $super };
          load_class($name, $opts);
          my $meta = Class::MOP::class_of($name);
          $self->throw_error("You cannot inherit from a Moose Role ($name)")
              if $meta && $meta->isa('Moose::Meta::Role')
      }
      return $self->SUPER::superclasses(map { $_->[0] } @{ $supers });
  }
  
  ### ---------------------------------------------
  
  sub add_attribute {
      my $self = shift;
      my $attr =
          (blessed $_[0] && $_[0]->isa('Class::MOP::Attribute')
              ? $_[0]
              : $self->_process_attribute(@_));
      $self->SUPER::add_attribute($attr);
      # it may be a Class::MOP::Attribute, theoretically, which doesn't have
      # 'bare' and doesn't implement this method
      if ($attr->can('_check_associated_methods')) {
          $attr->_check_associated_methods;
      }
      return $attr;
  }
  
  sub add_override_method_modifier {
      my ($self, $name, $method, $_super_package) = @_;
  
      (!$self->has_method($name))
          || $self->throw_error("Cannot add an override method if a local method is already present");
  
      $self->add_method($name => Moose::Meta::Method::Overridden->new(
          method  => $method,
          class   => $self,
          package => $_super_package, # need this for roles
          name    => $name,
      ));
  }
  
  sub add_augment_method_modifier {
      my ($self, $name, $method) = @_;
      (!$self->has_method($name))
          || $self->throw_error("Cannot add an augment method if a local method is already present");
  
      $self->add_method($name => Moose::Meta::Method::Augmented->new(
          method  => $method,
          class   => $self,
          name    => $name,
      ));
  }
  
  ## Private Utility methods ...
  
  sub _find_next_method_by_name_which_is_not_overridden {
      my ($self, $name) = @_;
      foreach my $method ($self->find_all_methods_by_name($name)) {
          return $method->{code}
              if blessed($method->{code}) && !$method->{code}->isa('Moose::Meta::Method::Overridden');
      }
      return undef;
  }
  
  ## Metaclass compatibility
  
  sub _base_metaclasses {
      my $self = shift;
      my %metaclasses = $self->SUPER::_base_metaclasses;
      for my $class (keys %metaclasses) {
          $metaclasses{$class} =~ s/^Class::MOP/Moose::Meta/;
      }
      return (
          %metaclasses,
          error_class => 'Moose::Error::Default',
      );
  }
  
  sub _fix_class_metaclass_incompatibility {
      my $self = shift;
      my ($super_meta) = @_;
  
      $self->SUPER::_fix_class_metaclass_incompatibility(@_);
  
      if ($self->_class_metaclass_can_be_made_compatible($super_meta)) {
          ($self->is_pristine)
              || confess "Can't fix metaclass incompatibility for "
                       . $self->name
                       . " because it is not pristine.";
          my $super_meta_name = $super_meta->_real_ref_name;
          my $class_meta_subclass_meta_name = Moose::Util::_reconcile_roles_for_metaclass(blessed($self), $super_meta_name);
          my $new_self = $class_meta_subclass_meta_name->reinitialize(
              $self->name,
          );
  
          $self->_replace_self( $new_self, $class_meta_subclass_meta_name );
      }
  }
  
  sub _fix_single_metaclass_incompatibility {
      my $self = shift;
      my ($metaclass_type, $super_meta) = @_;
  
      $self->SUPER::_fix_single_metaclass_incompatibility(@_);
  
      if ($self->_single_metaclass_can_be_made_compatible($super_meta, $metaclass_type)) {
          ($self->is_pristine)
              || confess "Can't fix metaclass incompatibility for "
                       . $self->name
                       . " because it is not pristine.";
          my $super_meta_name = $super_meta->_real_ref_name;
          my $class_specific_meta_subclass_meta_name = Moose::Util::_reconcile_roles_for_metaclass($self->$metaclass_type, $super_meta->$metaclass_type);
          my $new_self = $super_meta->reinitialize(
              $self->name,
              $metaclass_type => $class_specific_meta_subclass_meta_name,
          );
  
          $self->_replace_self( $new_self, $super_meta_name );
      }
  }
  
  sub _replace_self {
      my $self      = shift;
      my ( $new_self, $new_class)   = @_;
  
      %$self = %$new_self;
      bless $self, $new_class;
  
      # We need to replace the cached metaclass instance or else when it goes
      # out of scope Class::MOP::Class destroy's the namespace for the
      # metaclass's class, causing much havoc.
      my $weaken = Class::MOP::metaclass_is_weak( $self->name );
      Class::MOP::store_metaclass_by_name( $self->name, $self );
      Class::MOP::weaken_metaclass( $self->name ) if $weaken;
  }
  
  sub _process_attribute {
      my ( $self, $name, @args ) = @_;
  
      @args = %{$args[0]} if scalar @args == 1 && ref($args[0]) eq 'HASH';
  
      if (($name || '') =~ /^\+(.*)/) {
          return $self->_process_inherited_attribute($1, @args);
      }
      else {
          return $self->_process_new_attribute($name, @args);
      }
  }
  
  sub _process_new_attribute {
      my ( $self, $name, @args ) = @_;
  
      $self->attribute_metaclass->interpolate_class_and_new($name, @args);
  }
  
  sub _process_inherited_attribute {
      my ($self, $attr_name, %options) = @_;
      my $inherited_attr = $self->find_attribute_by_name($attr_name);
      (defined $inherited_attr)
          || $self->throw_error("Could not find an attribute by the name of '$attr_name' to inherit from in ${\$self->name}", data => $attr_name);
      if ($inherited_attr->isa('Moose::Meta::Attribute')) {
          return $inherited_attr->clone_and_inherit_options(%options);
      }
      else {
          # NOTE:
          # kind of a kludge to handle Class::MOP::Attributes
          return $inherited_attr->Moose::Meta::Attribute::clone_and_inherit_options(%options);
      }
  }
  
  # reinitialization support
  
  sub _restore_metaobjects_from {
      my $self = shift;
      my ($old_meta) = @_;
  
      $self->SUPER::_restore_metaobjects_from($old_meta);
  
      for my $role ( @{ $old_meta->roles } ) {
          $self->add_role($role);
      }
  
      for my $application ( @{ $old_meta->_get_role_applications } ) {
          $application->class($self);
          $self->add_role_application ($application);
      }
  }
  
  ## Immutability
  
  sub _immutable_options {
      my ( $self, @args ) = @_;
  
      $self->SUPER::_immutable_options(
          inline_destructor => 1,
  
          # Moose always does this when an attribute is created
          inline_accessors => 0,
  
          @args,
      );
  }
  
  sub _fixup_attributes_after_rebless {
      my $self = shift;
      my ($instance, $rebless_from, %params) = @_;
  
      $self->SUPER::_fixup_attributes_after_rebless(
          $instance,
          $rebless_from,
          %params
      );
  
      $self->_call_all_triggers( $instance, \%params );
  }
  
  ## -------------------------------------------------
  
  our $error_level;
  
  sub throw_error {
      my ( $self, @args ) = @_;
      local $error_level = ($error_level || 0) + 1;
      $self->raise_error($self->create_error(@args));
  }
  
  sub _inline_throw_error {
      my ( $self, @args ) = @_;
      $self->_inline_raise_error($self->_inline_create_error(@args));
  }
  
  sub raise_error {
      my ( $self, @args ) = @_;
      die @args;
  }
  
  sub _inline_raise_error {
      my ( $self, $message ) = @_;
  
      return 'die ' . $message;
  }
  
  sub create_error {
      my ( $self, @args ) = @_;
  
      require Carp::Heavy;
  
      local $error_level = ($error_level || 0 ) + 1;
  
      if ( @args % 2 == 1 ) {
          unshift @args, "message";
      }
  
      my %args = ( metaclass => $self, last_error => $@, @args );
  
      $args{depth} += $error_level;
  
      my $class = ref $self ? $self->error_class : "Moose::Error::Default";
  
      load_class($class);
  
      $class->new(
          Carp::caller_info($args{depth}),
          %args
      );
  }
  
  sub _inline_create_error {
      my ( $self, $msg, $args ) = @_;
      # XXX ignore $args for now, nothing currently uses it anyway
  
      require Carp::Heavy;
  
      my %args = (
          metaclass  => $self,
          last_error => $@,
          message    => $msg,
      );
  
      my $class = ref $self ? $self->error_class : "Moose::Error::Default";
  
      load_class($class);
  
      # don't check inheritance here - the intention is that the class needs
      # to provide a non-inherited inlining method, because falling back to
      # the default inlining method is most likely going to be wrong
      # yes, this is a huge hack, but so is the entire error system, so.
      return
            '$meta->create_error('
          . $msg
          . ( defined $args ? ', ' . $args : q{} ) . ');'
          unless $class->meta->has_method('_inline_new');
  
      $class->_inline_new(
          # XXX ignore this for now too
          # Carp::caller_info($args{depth}),
          %args
      );
  }
  
  1;
  
  # ABSTRACT: The Moose metaclass
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::Class - The Moose metaclass
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This class is a subclass of L<Class::MOP::Class> that provides
  additional Moose-specific functionality.
  
  To really understand this class, you will need to start with the
  L<Class::MOP::Class> documentation. This class can be understood as a
  set of additional features on top of the basic feature provided by
  that parent class.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Class> is a subclass of L<Class::MOP::Class>.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Moose::Meta::Class->initialize($package_name, %options) >>
  
  This overrides the parent's method in order to provide its own
  defaults for the C<attribute_metaclass>, C<instance_metaclass>, and
  C<method_metaclass> options.
  
  These all default to the appropriate Moose class.
  
  =item B<< Moose::Meta::Class->create($package_name, %options) >>
  
  This overrides the parent's method in order to accept a C<roles>
  option. This should be an array reference containing roles
  that the class does, each optionally followed by a hashref of options
  (C<-excludes> and C<-alias>).
  
    my $metaclass = Moose::Meta::Class->create( 'New::Class', roles => [...] );
  
  =item B<< Moose::Meta::Class->create_anon_class >>
  
  This overrides the parent's method to accept a C<roles> option, just
  as C<create> does.
  
  It also accepts a C<cache> option. If this is true, then the anonymous
  class will be cached based on its superclasses and roles. If an
  existing anonymous class in the cache has the same superclasses and
  roles, it will be reused.
  
    my $metaclass = Moose::Meta::Class->create_anon_class(
        superclasses => ['Foo'],
        roles        => [qw/Some Roles Go Here/],
        cache        => 1,
    );
  
  Each entry in both the C<superclasses> and the C<roles> option can be
  followed by a hash reference with arguments. The C<superclasses>
  option can be supplied with a L<-version|Class::MOP/Class Loading
  Options> option that ensures the loaded superclass satisfies the
  required version. The C<role> option also takes the C<-version> as an
  argument, but the option hash reference can also contain any other
  role relevant values like exclusions or parameterized role arguments.
  
  =item B<< $metaclass->new_object(%params) >>
  
  This overrides the parent's method in order to add support for
  attribute triggers.
  
  =item B<< $metaclass->superclasses(@superclasses) >>
  
  This is the accessor allowing you to read or change the parents of
  the class.
  
  Each superclass can be followed by a hash reference containing a
  L<-version|Class::MOP/Class Loading Options> value. If the version
  requirement is not satisfied an error will be thrown.
  
  =item B<< $metaclass->add_override_method_modifier($name, $sub) >>
  
  This adds an C<override> method modifier to the package.
  
  =item B<< $metaclass->add_augment_method_modifier($name, $sub) >>
  
  This adds an C<augment> method modifier to the package.
  
  =item B<< $metaclass->calculate_all_roles >>
  
  This will return a unique array of C<Moose::Meta::Role> instances
  which are attached to this class.
  
  =item B<< $metaclass->calculate_all_roles_with_inheritance >>
  
  This will return a unique array of C<Moose::Meta::Role> instances
  which are attached to this class, and each of this class's ancestors.
  
  =item B<< $metaclass->add_role($role) >>
  
  This takes a L<Moose::Meta::Role> object, and adds it to the class's
  list of roles. This I<does not> actually apply the role to the class.
  
  =item B<< $metaclass->role_applications >>
  
  Returns a list of L<Moose::Meta::Role::Application::ToClass>
  objects, which contain the arguments to role application.
  
  =item B<< $metaclass->add_role_application($application) >>
  
  This takes a L<Moose::Meta::Role::Application::ToClass> object, and
  adds it to the class's list of role applications. This I<does not>
  actually apply any role to the class; it is only for tracking role
  applications.
  
  =item B<< $metaclass->does_role($role) >>
  
  This returns a boolean indicating whether or not the class does the specified
  role. The role provided can be either a role name or a L<Moose::Meta::Role>
  object. This tests both the class and its parents.
  
  =item B<< $metaclass->excludes_role($role_name) >>
  
  A class excludes a role if it has already composed a role which
  excludes the named role. This tests both the class and its parents.
  
  =item B<< $metaclass->add_attribute($attr_name, %params|$params) >>
  
  This overrides the parent's method in order to allow the parameters to
  be provided as a hash reference.
  
  =item B<< $metaclass->constructor_class($class_name) >>
  
  =item B<< $metaclass->destructor_class($class_name) >>
  
  These are the names of classes used when making a class immutable. These
  default to L<Moose::Meta::Method::Constructor> and
  L<Moose::Meta::Method::Destructor> respectively. These accessors are
  read-write, so you can use them to change the class name.
  
  =item B<< $metaclass->error_class($class_name) >>
  
  The name of the class used to throw errors. This defaults to
  L<Moose::Error::Default>, which generates an error with a stacktrace
  just like C<Carp::confess>.
  
  =item B<< $metaclass->throw_error($message, %extra) >>
  
  Throws the error created by C<create_error> using C<raise_error>
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
  
I686-LINUX_MOOSE_META_CLASS

$fatpacked{"i686-linux/Moose/Meta/Class/Immutable/Trait.pm"} = <<'I686-LINUX_MOOSE_META_CLASS_IMMUTABLE_TRAIT';
  package Moose::Meta::Class::Immutable::Trait;
  BEGIN {
    $Moose::Meta::Class::Immutable::Trait::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Class::Immutable::Trait::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Class::MOP;
  use Scalar::Util qw( blessed );
  
  use base 'Class::MOP::Class::Immutable::Trait';
  
  sub add_role { $_[1]->_immutable_cannot_call }
  
  sub calculate_all_roles {
      my $orig = shift;
      my $self = shift;
      @{ $self->{__immutable}{calculate_all_roles} ||= [ $self->$orig ] };
  }
  
  sub calculate_all_roles_with_inheritance {
      my $orig = shift;
      my $self = shift;
      @{ $self->{__immutable}{calculate_all_roles_with_inheritance} ||= [ $self->$orig ] };
  }
  
  sub does_role {
      shift;
      my $self = shift;
      my $role = shift;
  
      (defined $role)
          || $self->throw_error("You must supply a role name to look for");
  
      $self->{__immutable}{does_role} ||= { map { $_->name => 1 } $self->calculate_all_roles_with_inheritance };
  
      my $name = blessed $role ? $role->name : $role;
  
      return $self->{__immutable}{does_role}{$name};
  }
  
  1;
  
  # ABSTRACT: Implements immutability for metaclass objects
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::Class::Immutable::Trait - Implements immutability for metaclass objects
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This class makes some Moose-specific metaclass methods immutable. This
  is deep guts.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
  
I686-LINUX_MOOSE_META_CLASS_IMMUTABLE_TRAIT

$fatpacked{"i686-linux/Moose/Meta/Instance.pm"} = <<'I686-LINUX_MOOSE_META_INSTANCE';
  
  package Moose::Meta::Instance;
  BEGIN {
    $Moose::Meta::Instance::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Instance::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Class::MOP::MiniTrait;
  
  use base "Class::MOP::Instance";
  
  Class::MOP::MiniTrait::apply(__PACKAGE__, 'Moose::Meta::Object::Trait');
  
  1;
  
  # ABSTRACT: The Moose Instance metaclass
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::Instance - The Moose Instance metaclass
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 SYNOPSIS
  
      # nothing to see here
  
  =head1 DESCRIPTION
  
  This class provides the low level data storage abstractions for
  attributes.
  
  Using this API directly in your own code violates encapsulation, and
  we recommend that you use the appropriate APIs in
  L<Moose::Meta::Class> and L<Moose::Meta::Attribute> instead. Those
  APIs in turn call the methods in this class as appropriate.
  
  At present, this is an empty subclass of L<Class::MOP::Instance>, so
  you should see that class for all API details.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Instance> is a subclass of L<Class::MOP::Instance>.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_META_INSTANCE

$fatpacked{"i686-linux/Moose/Meta/Method.pm"} = <<'I686-LINUX_MOOSE_META_METHOD';
  package Moose::Meta::Method;
  BEGIN {
    $Moose::Meta::Method::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Class::MOP::MiniTrait;
  
  use base 'Class::MOP::Method';
  
  Class::MOP::MiniTrait::apply(__PACKAGE__, 'Moose::Meta::Object::Trait');
  
  sub _error_thrower {
      my $self = shift;
      require Moose::Meta::Class;
      ( ref $self && $self->associated_metaclass ) || "Moose::Meta::Class";
  }
  
  sub throw_error {
      my $self = shift;
      my $inv = $self->_error_thrower;
      unshift @_, "message" if @_ % 2 == 1;
      unshift @_, method => $self if ref $self;
      unshift @_, $inv;
      my $handler = $inv->can("throw_error");
      goto $handler; # to avoid incrementing depth by 1
  }
  
  sub _inline_throw_error {
      my ( $self, $msg, $args ) = @_;
  
      my $inv = $self->_error_thrower;
      # XXX ugh
      $inv = 'Moose::Meta::Class' unless $inv->can('_inline_throw_error');
  
      # XXX ugh ugh UGH
      my $class = $self->associated_metaclass;
      if ($class) {
          my $class_name = B::perlstring($class->name);
          my $meth_name = B::perlstring($self->name);
          $args = 'method => Class::MOP::class_of(' . $class_name . ')'
                . '->find_method_by_name(' . $meth_name . '), '
                . (defined $args ? $args : '');
      }
  
      return $inv->_inline_throw_error($msg, $args)
  }
  
  1;
  
  # ABSTRACT: A Moose Method metaclass
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::Method - A Moose Method metaclass
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This class is a subclass of L<Class::MOP::Method> that provides
  additional Moose-specific functionality, all of which is private.
  
  To understand this class, you should read the the L<Class::MOP::Method>
  documentation.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Method> is a subclass of L<Class::MOP::Method>.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_META_METHOD

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR';
  
  package Moose::Meta::Method::Accessor;
  BEGIN {
    $Moose::Meta::Method::Accessor::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Try::Tiny;
  
  use base 'Moose::Meta::Method',
           'Class::MOP::Method::Accessor';
  
  # multiple inheritance is terrible
  sub new {
      goto &Class::MOP::Method::Accessor::new;
  }
  
  sub _new {
      goto &Class::MOP::Method::Accessor::_new;
  }
  
  sub _error_thrower {
      my $self = shift;
      return $self->associated_attribute
          if ref($self) && defined($self->associated_attribute);
      return $self->SUPER::_error_thrower;
  }
  
  sub _compile_code {
      my $self = shift;
      my @args = @_;
      try {
          $self->SUPER::_compile_code(@args);
      }
      catch {
          $self->throw_error(
              'Could not create writer for '
            . "'" . $self->associated_attribute->name . "' "
            . 'because ' . $_,
              error => $_,
          );
      };
  }
  
  sub _eval_environment {
      my $self = shift;
      return $self->associated_attribute->_eval_environment;
  }
  
  sub _instance_is_inlinable {
      my $self = shift;
      return $self->associated_attribute->associated_class->instance_metaclass->is_inlinable;
  }
  
  sub _generate_reader_method {
      my $self = shift;
      $self->_instance_is_inlinable ? $self->_generate_reader_method_inline(@_)
                                    : $self->SUPER::_generate_reader_method(@_);
  }
  
  sub _generate_writer_method {
      my $self = shift;
      $self->_instance_is_inlinable ? $self->_generate_writer_method_inline(@_)
                                    : $self->SUPER::_generate_writer_method(@_);
  }
  
  sub _generate_accessor_method {
      my $self = shift;
      $self->_instance_is_inlinable ? $self->_generate_accessor_method_inline(@_)
                                    : $self->SUPER::_generate_accessor_method(@_);
  }
  
  sub _generate_predicate_method {
      my $self = shift;
      $self->_instance_is_inlinable ? $self->_generate_predicate_method_inline(@_)
                                    : $self->SUPER::_generate_predicate_method(@_);
  }
  
  sub _generate_clearer_method {
      my $self = shift;
      $self->_instance_is_inlinable ? $self->_generate_clearer_method_inline(@_)
                                    : $self->SUPER::_generate_clearer_method(@_);
  }
  
  sub _writer_value_needs_copy {
      shift->associated_attribute->_writer_value_needs_copy(@_);
  }
  
  sub _inline_tc_code {
      shift->associated_attribute->_inline_tc_code(@_);
  }
  
  sub _inline_check_coercion {
      shift->associated_attribute->_inline_check_coercion(@_);
  }
  
  sub _inline_check_constraint {
      shift->associated_attribute->_inline_check_constraint(@_);
  }
  
  sub _inline_check_lazy {
      shift->associated_attribute->_inline_check_lazy(@_);
  }
  
  sub _inline_store_value {
      shift->associated_attribute->_inline_instance_set(@_) . ';';
  }
  
  sub _inline_get_old_value_for_trigger {
      shift->associated_attribute->_inline_get_old_value_for_trigger(@_);
  }
  
  sub _inline_trigger {
      shift->associated_attribute->_inline_trigger(@_);
  }
  
  sub _get_value {
      shift->associated_attribute->_inline_instance_get(@_);
  }
  
  sub _has_value {
      shift->associated_attribute->_inline_instance_has(@_);
  }
  
  1;
  
  # ABSTRACT: A Moose Method metaclass for accessors
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::Method::Accessor - A Moose Method metaclass for accessors
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This class is a subclass of L<Class::MOP::Method::Accessor> that
  provides additional Moose-specific functionality, all of which is
  private.
  
  To understand this class, you should read the the
  L<Class::MOP::Method::Accessor> documentation.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_META_METHOD_ACCESSOR

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE';
  package Moose::Meta::Method::Accessor::Native;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Carp qw( confess );
  use Scalar::Util qw( blessed weaken );
  
  use Moose::Role;
  
  around new => sub {
      my $orig = shift;
      my $class   = shift;
      my %options = @_;
  
      $options{curried_arguments} = []
          unless exists $options{curried_arguments};
  
      confess 'You must supply a curried_arguments which is an ARRAY reference'
          unless $options{curried_arguments}
              && ref($options{curried_arguments}) eq 'ARRAY';
  
      my $attr_context = $options{attribute}->definition_context;
      my $desc = 'native delegation method ';
      $desc   .= $options{attribute}->associated_class->name;
      $desc   .= '::' . $options{name};
      $desc   .= " ($options{delegate_to_method})";
      $desc   .= " of attribute " . $options{attribute}->name;
      $options{definition_context} = {
          %{ $attr_context || {} },
          description => $desc,
      };
  
      $options{accessor_type} = 'native';
  
      return $class->$orig(%options);
  };
  
  sub _new {
      my $class = shift;
      my $options = @_ == 1 ? $_[0] : {@_};
  
      return bless $options, $class;
  }
  
  sub root_types { (shift)->{'root_types'} }
  
  sub _initialize_body {
      my $self = shift;
  
      $self->{'body'} = $self->_compile_code( [$self->_generate_method] );
  
      return;
  }
  
  sub _inline_curried_arguments {
      my $self = shift;
  
      return unless @{ $self->curried_arguments };
  
      return 'unshift @_, @curried;';
  }
  
  sub _inline_check_argument_count {
      my $self = shift;
  
      my @code;
  
      if (my $min = $self->_minimum_arguments) {
          push @code, (
              'if (@_ < ' . $min . ') {',
                  $self->_inline_throw_error(
                      sprintf(
                          '"Cannot call %s without at least %s argument%s"',
                          $self->delegate_to_method,
                          $min,
                          ($min == 1 ? '' : 's'),
                      )
                  ) . ';',
              '}',
          );
      }
  
      if (defined(my $max = $self->_maximum_arguments)) {
          push @code, (
              'if (@_ > ' . $max . ') {',
                  $self->_inline_throw_error(
                      sprintf(
                          '"Cannot call %s with %s argument%s"',
                          $self->delegate_to_method,
                          $max ? "more than $max" : 'any',
                          ($max == 1 ? '' : 's'),
                      )
                  ) . ';',
              '}',
          );
      }
  
      return @code;
  }
  
  sub _inline_return_value {
      my $self = shift;
      my ($slot_access, $for_writer) = @_;
  
      return 'return ' . $self->_return_value($slot_access, $for_writer) . ';';
  }
  
  sub _minimum_arguments { 0 }
  sub _maximum_arguments { undef }
  
  override _get_value => sub {
      my $self = shift;
      my ($instance) = @_;
  
      return $self->_slot_access_can_be_inlined
          ? super()
          : $instance . '->$reader';
  };
  
  override _inline_store_value => sub {
      my $self = shift;
      my ($instance, $value) = @_;
  
      return $self->_slot_access_can_be_inlined
          ? super()
          : $instance . '->$writer(' . $value . ');';
  };
  
  override _eval_environment => sub {
      my $self = shift;
  
      my $env = super();
  
      $env->{'@curried'} = $self->curried_arguments;
  
      return $env if $self->_slot_access_can_be_inlined;
  
      my $reader = $self->associated_attribute->get_read_method_ref;
      $reader = $reader->body if blessed $reader;
  
      $env->{'$reader'} = \$reader;
  
      my $writer = $self->associated_attribute->get_write_method_ref;
      $writer = $writer->body if blessed $writer;
  
      $env->{'$writer'} = \$writer;
  
      return $env;
  };
  
  sub _slot_access_can_be_inlined {
      my $self = shift;
  
      return $self->is_inline && $self->_instance_is_inlinable;
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Array.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY';
  package Moose::Meta::Method::Accessor::Native::Array;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Array::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  use Scalar::Util qw( looks_like_number );
  
  sub _inline_check_var_is_valid_index {
      my $self = shift;
      my ($var) = @_;
  
      return (
          'if (!defined(' . $var . ') || ' . $var . ' !~ /^-?\d+$/) {',
              $self->_inline_throw_error(
                  '"The index passed to ' . $self->delegate_to_method
                . ' must be an integer"',
              ) . ';',
          '}',
      );
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Array/Writer.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_WRITER';
  package Moose::Meta::Method::Accessor::Native::Array::Writer;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::Writer::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Array::Writer::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer' => {
          -excludes => ['_inline_coerce_new_values'],
      },
      'Moose::Meta::Method::Accessor::Native::Array',
      'Moose::Meta::Method::Accessor::Native::Collection';
  
  sub _new_members { '@_' }
  
  sub _copy_old_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '[ @{(' . $slot_access . ')} ]';
  }
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_WRITER

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Array/accessor.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_ACCESSOR';
  package Moose::Meta::Method::Accessor::Native::Array::accessor;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::accessor::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Array::accessor::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::set' => {
      -excludes => [
          qw( _generate_method
              _minimum_arguments
              _maximum_arguments
              _inline_process_arguments
              _inline_check_arguments
              _return_value)
      ]
      },
      'Moose::Meta::Method::Accessor::Native::Array::get' => {
      -excludes => [
          qw(
              _generate_method
              _minimum_arguments
              _maximum_arguments
              )
      ]
      };
  
  sub _generate_method {
      my $self = shift;
  
      my $inv         = '$self';
      my $slot_access = $self->_get_value($inv);
  
      return (
          'sub {',
              'my ' . $inv . ' = shift;',
              $self->_inline_curried_arguments,
              $self->_inline_check_lazy($inv, '$type_constraint', '$type_coercion', '$type_message'),
              # get
              'if (@_ == 1) {',
                  $self->_inline_check_var_is_valid_index('$_[0]'),
                  $self->Moose::Meta::Method::Accessor::Native::Array::get::_inline_return_value($slot_access),
              '}',
              # set
              'else {',
                  $self->_inline_writer_core($inv, $slot_access),
              '}',
          '}',
      );
  }
  
  sub _minimum_arguments { 1 }
  sub _maximum_arguments { 2 }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_ACCESSOR

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Array/clear.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_CLEAR';
  package Moose::Meta::Method::Accessor::Native::Array::clear;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::clear::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Array::clear::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer' => {
      -excludes => [
          qw(
              _maximum_arguments
              _inline_optimized_set_new_value
              _return_value
              )
      ]
  };
  
  sub _maximum_arguments { 0 }
  
  sub _adds_members { 0 }
  
  sub _potential_value { '[]' }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = [];';
  }
  
  sub _return_value { '' }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_CLEAR

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Array/count.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_COUNT';
  package Moose::Meta::Method::Accessor::Native::Array::count;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::count::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Array::count::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader' =>
      { -excludes => ['_maximum_arguments'] };
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'scalar @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_COUNT

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Array/delete.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_DELETE';
  package Moose::Meta::Method::Accessor::Native::Array::delete;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::delete::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Array::delete::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer' => {
      -excludes => [
          qw(
              _minimum_arguments
              _maximum_arguments
              _inline_check_arguments
              _inline_optimized_set_new_value
              _return_value
              )
      ],
  };
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return $self->_inline_check_var_is_valid_index('$_[0]');
  }
  
  sub _adds_members { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my @potential = @{ (' . $slot_access . ') }; '
               . '@return = splice @potential, $_[0], 1; '
               . '\@potential; '
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return '@return = splice @{ (' . $slot_access . ') }, $_[0], 1;';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '$return[0]';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_DELETE

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Array/elements.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_ELEMENTS';
  package Moose::Meta::Method::Accessor::Native::Array::elements;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::elements::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Array::elements::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader' =>
      { -excludes => ['_maximum_arguments'] };
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '@{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_ELEMENTS

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Array/first.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_FIRST';
  package Moose::Meta::Method::Accessor::Native::Array::first;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::first::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Array::first::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use List::Util ();
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader' => {
      -excludes => [
          qw(
              _minimum_arguments
              _maximum_arguments
              _inline_check_arguments
              )
      ]
  };
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!Params::Util::_CODELIKE($_[0])) {',
              $self->_inline_throw_error(
                  '"The argument passed to first must be a code reference"',
              ) . ';',
          '}',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '&List::Util::first($_[0], @{ (' . $slot_access . ') })';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_FIRST

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Array/first_index.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_FIRST_INDEX';
  package Moose::Meta::Method::Accessor::Native::Array::first_index;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::first_index::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Array::first_index::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use List::MoreUtils ();
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader' => {
      -excludes => [
          qw(
              _minimum_arguments
              _maximum_arguments
              _inline_check_arguments
              )
      ]
  };
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!Params::Util::_CODELIKE($_[0])) {',
              $self->_inline_throw_error(
                  '"The argument passed to first_index must be a code reference"',
              ) . ';',
          '}',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '&List::MoreUtils::first_index($_[0], @{ (' . $slot_access . ') })';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_FIRST_INDEX

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Array/get.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_GET';
  package Moose::Meta::Method::Accessor::Native::Array::get;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::get::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Array::get::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Class::MOP::MiniTrait;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader' => {
      -excludes => [
          qw(
              _minimum_arguments
              _maximum_arguments
              _inline_check_arguments
              )
      ],
      },
      'Moose::Meta::Method::Accessor::Native::Array';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return $self->_inline_check_var_is_valid_index('$_[0]');
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . '->[ $_[0] ]';
  }
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_GET

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Array/grep.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_GREP';
  package Moose::Meta::Method::Accessor::Native::Array::grep;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::grep::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Array::grep::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader' => {
      -excludes => [
          qw(
              _minimum_arguments
              _maximum_arguments
              _inline_check_arguments
              )
      ]
  };
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!Params::Util::_CODELIKE($_[0])) {',
              $self->_inline_throw_error(
                  '"The argument passed to grep must be a code reference"',
              ) . ';',
          '}',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'grep { $_[0]->() } @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_GREP

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Array/insert.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_INSERT';
  package Moose::Meta::Method::Accessor::Native::Array::insert;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::insert::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Array::insert::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer' => {
      -excludes => [
          qw(
              _minimum_arguments
              _maximum_arguments
              _inline_coerce_new_values
              _new_members
              _inline_optimized_set_new_value
              _return_value
              )
      ]
  };
  
  sub _minimum_arguments { 2 }
  
  sub _maximum_arguments { 2 }
  
  sub _adds_members { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my @potential = @{ (' . $slot_access . ') }; '
               . 'splice @potential, $_[0], 0, $_[1]; '
               . '\@potential; '
           . '})';
  }
  
  # We need to override this because while @_ can be written to, we cannot write
  # directly to $_[1].
  sub _inline_coerce_new_values {
      my $self = shift;
  
      return unless $self->associated_attribute->should_coerce;
  
      return unless $self->_tc_member_type_can_coerce;
  
      return '@_ = ($_[0], $member_coercion->($_[1]));';
  };
  
  sub _new_members { '$_[1]' }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return 'splice @{ (' . $slot_access . ') }, $_[0], 0, $_[1];';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . '->[ $_[0] ]';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_INSERT

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Array/is_empty.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_IS_EMPTY';
  package Moose::Meta::Method::Accessor::Native::Array::is_empty;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::is_empty::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Array::is_empty::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader' =>
      { -excludes => ['_maximum_arguments'] };
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '@{ (' . $slot_access . ') } ? 0 : 1';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_IS_EMPTY

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Array/join.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_JOIN';
  package Moose::Meta::Method::Accessor::Native::Array::join;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::join::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Array::join::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader' => {
      -excludes => [
          qw(
              _minimum_arguments
              _maximum_arguments
              _inline_check_arguments
              )
      ]
  };
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!Moose::Util::_STRINGLIKE0($_[0])) {',
              $self->_inline_throw_error(
                  '"The argument passed to join must be a string"',
              ) . ';',
          '}',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'join $_[0], @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_JOIN

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Array/map.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_MAP';
  package Moose::Meta::Method::Accessor::Native::Array::map;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::map::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Array::map::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader' => {
      -excludes => [
          qw(
              _minimum_arguments
              _maximum_arguments
              _inline_check_arguments
              )
      ]
  };
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!Params::Util::_CODELIKE($_[0])) {',
              $self->_inline_throw_error(
                  '"The argument passed to map must be a code reference"',
              ) . ';',
          '}',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'map { $_[0]->() } @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_MAP

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Array/natatime.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_NATATIME';
  package Moose::Meta::Method::Accessor::Native::Array::natatime;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::natatime::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Array::natatime::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use List::MoreUtils ();
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader' => {
      -excludes => [
          qw(
              _minimum_arguments
              _maximum_arguments
              _inline_check_arguments
              _inline_return_value
              )
      ]
  };
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 2 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!defined($_[0]) || $_[0] !~ /^\d+$/) {',
              $self->_inline_throw_error(
                  '"The n value passed to natatime must be an integer"',
              ) . ';',
          '}',
          'if (@_ == 2 && !Params::Util::_CODELIKE($_[1])) {',
              $self->_inline_throw_error(
                  '"The second argument passed to natatime must be a code '
                . 'reference"',
              ) . ';',
          '}',
      );
  }
  
  sub _inline_return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return (
          'my $iter = List::MoreUtils::natatime($_[0], @{ (' . $slot_access . ') });',
          'if ($_[1]) {',
              'while (my @vals = $iter->()) {',
                  '$_[1]->(@vals);',
              '}',
          '}',
          'else {',
              'return $iter;',
          '}',
      );
  }
  
  # Not called, but needed to satisfy the Reader role
  sub _return_value { }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_NATATIME

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Array/pop.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_POP';
  package Moose::Meta::Method::Accessor::Native::Array::pop;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::pop::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Array::pop::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer' => {
      -excludes => [
          qw( _maximum_arguments
              _inline_capture_return_value
              _inline_optimized_set_new_value
              _return_value )
      ]
  };
  
  sub _maximum_arguments { 0 }
  
  sub _adds_members { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '[ @{ (' . $slot_access . ') } > 1 '
               . '? @{ (' . $slot_access . ') }[0..$#{ (' . $slot_access . ') } - 1] '
               . ': () ]';
  }
  
  sub _inline_capture_return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'my $old = ' . $slot_access . '->[-1];';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return 'pop @{ (' . $slot_access . ') };';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '$old';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_POP

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Array/push.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_PUSH';
  package Moose::Meta::Method::Accessor::Native::Array::push;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::push::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Array::push::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer' => {
      -excludes => [
          qw(
              _inline_optimized_set_new_value
              _return_value
              )
      ]
  };
  
  sub _adds_members { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '[ @{ (' . $slot_access . ') }, @_ ]';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return 'push @{ (' . $slot_access . ') }, @_;';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'scalar @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_PUSH

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Array/reduce.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_REDUCE';
  package Moose::Meta::Method::Accessor::Native::Array::reduce;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::reduce::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Array::reduce::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use List::Util ();
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader' => {
      -excludes => [
          qw(
              _minimum_arguments
              _maximum_arguments
              _inline_check_arguments
              )
      ]
  };
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!Params::Util::_CODELIKE($_[0])) {',
              $self->_inline_throw_error(
                  '"The argument passed to reduce must be a code reference"',
              ) . ';',
          '}',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'List::Util::reduce { $_[0]->($a, $b) } @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_REDUCE

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Array/set.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SET';
  package Moose::Meta::Method::Accessor::Native::Array::set;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::set::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Array::set::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer' => {
      -excludes => [
          qw(
              _minimum_arguments
              _maximum_arguments
              _inline_check_arguments
              _inline_coerce_new_values
              _new_members
              _inline_optimized_set_new_value
              _return_value
              )
      ]
  };
  
  sub _minimum_arguments { 2 }
  
  sub _maximum_arguments { 2 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return $self->_inline_check_var_is_valid_index('$_[0]');
  }
  
  sub _adds_members { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my @potential = @{ (' . $slot_access . ') }; '
               . '$potential[$_[0]] = $_[1]; '
               . '\@potential; '
           . '})';
  }
  
  # We need to override this because while @_ can be written to, we cannot write
  # directly to $_[1].
  sub _inline_coerce_new_values {
      my $self = shift;
  
      return unless $self->associated_attribute->should_coerce;
  
      return unless $self->_tc_member_type_can_coerce;
  
      return '@_ = ($_[0], $member_coercion->($_[1]));';
  };
  
  sub _new_members { '$_[1]' }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . '->[$_[0]] = $_[1];';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . '->[$_[0]]';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SET

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Array/shallow_clone.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SHALLOW_CLONE';
  package Moose::Meta::Method::Accessor::Native::Array::shallow_clone;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::shallow_clone::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Array::shallow_clone::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader' => {
      -excludes => [
          qw(
              _minimum_arguments
              _maximum_arguments
              )
      ]
  };
  
  sub _minimum_arguments { 0 }
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '[ @{ (' . $slot_access . ') } ]';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SHALLOW_CLONE

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Array/shift.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SHIFT';
  package Moose::Meta::Method::Accessor::Native::Array::shift;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::shift::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Array::shift::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer' => {
      -excludes => [
          qw(
              _maximum_arguments
              _inline_capture_return_value
              _inline_optimized_set_new_value
              _return_value
              )
      ]
  };
  
  sub _maximum_arguments { 0 }
  
  sub _adds_members { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '[ @{ (' . $slot_access . ') } > 1 '
               . '? @{ (' . $slot_access . ') }[1..$#{ (' . $slot_access . ') }] '
               . ': () ]';
  }
  
  sub _inline_capture_return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'my $old = ' . $slot_access . '->[0];';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return 'shift @{ (' . $slot_access . ') };';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '$old';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SHIFT

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Array/shuffle.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SHUFFLE';
  package Moose::Meta::Method::Accessor::Native::Array::shuffle;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::shuffle::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Array::shuffle::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use List::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader' =>
      { -excludes => ['_maximum_arguments'] };
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'List::Util::shuffle @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SHUFFLE

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Array/sort.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SORT';
  package Moose::Meta::Method::Accessor::Native::Array::sort;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::sort::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Array::sort::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader' => {
      -excludes => [
          qw(
              _maximum_arguments
              _inline_check_arguments
              )
      ]
  };
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (@_ && !Params::Util::_CODELIKE($_[0])) {',
              $self->_inline_throw_error(
                  '"The argument passed to sort must be a code reference"',
              ) . ';',
          '}',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '$_[0] '
               . '? sort { $_[0]->($a, $b) } @{ (' . $slot_access . ') } '
               . ': sort @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SORT

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Array/sort_in_place.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SORT_IN_PLACE';
  package Moose::Meta::Method::Accessor::Native::Array::sort_in_place;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::sort_in_place::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Array::sort_in_place::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer' => {
      -excludes => [
          qw(
              _maximum_arguments
              _inline_check_arguments
              _return_value
              )
      ]
  };
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (@_ && !Params::Util::_CODELIKE($_[0])) {',
              $self->_inline_throw_error(
                  '"The argument passed to sort_in_place must be a code '
                . 'reference"',
              ) . ';',
          '}',
      );
  }
  
  sub _adds_members { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '[ $_[0] '
               . '? sort { $_[0]->($a, $b) } @{ (' . $slot_access . ') } '
               . ': sort @{ (' . $slot_access . ') } ]';
  }
  
  sub _return_value { '' }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SORT_IN_PLACE

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Array/splice.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SPLICE';
  package Moose::Meta::Method::Accessor::Native::Array::splice;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::splice::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Array::splice::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer' => {
      -excludes => [
          qw(
              _minimum_arguments
              _inline_process_arguments
              _inline_check_arguments
              _inline_optimized_set_new_value
              _return_value
              )
      ]
  };
  
  sub _minimum_arguments { 1 }
  
  sub _adds_members { 1 }
  
  sub _inline_process_arguments {
      return (
          'my $idx = shift;',
          'my $len = @_ ? shift : undef;',
      );
  }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          $self->_inline_check_var_is_valid_index('$idx'),
          'if (defined($len) && $len !~ /^-?\d+$/) {',
              $self->_inline_throw_error(
                  '"The length argument passed to splice must be an integer"',
              ) . ';',
          '}',
      );
  }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my @potential = @{ (' . $slot_access . ') }; '
               . '@return = defined $len '
                   . '? (splice @potential, $idx, $len, @_) '
                   . ': (splice @potential, $idx); '
                   . '\@potential;'
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return (
          '@return = defined $len',
              '? (splice @{ (' . $slot_access . ') }, $idx, $len, @_)',
              ': (splice @{ (' . $slot_access . ') }, $idx);',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'wantarray ? @return : $return[-1]';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_SPLICE

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Array/uniq.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_UNIQ';
  package Moose::Meta::Method::Accessor::Native::Array::uniq;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::uniq::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Array::uniq::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use List::MoreUtils ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader' =>
      { -excludes => ['_maximum_arguments'] };
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'List::MoreUtils::uniq @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_UNIQ

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Array/unshift.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_UNSHIFT';
  package Moose::Meta::Method::Accessor::Native::Array::unshift;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Array::unshift::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Array::unshift::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Array::Writer' => {
      -excludes => [
          qw(
              _inline_optimized_set_new_value
              _return_value
              )
      ]
  };
  
  sub _adds_members { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '[ @_, @{ (' . $slot_access . ') } ]';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return 'unshift @{ (' . $slot_access . ') }, @_;';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'scalar @{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_ARRAY_UNSHIFT

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Bool/not.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_NOT';
  package Moose::Meta::Method::Accessor::Native::Bool::not;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Bool::not::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Bool::not::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader' =>
      { -excludes => ['_maximum_arguments'] };
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '!' . $slot_access;
  }
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_NOT

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Bool/set.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_SET';
  package Moose::Meta::Method::Accessor::Native::Bool::set;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Bool::set::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Bool::set::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer' => {
      -excludes => [
          qw(
              _maximum_arguments
              _inline_optimized_set_new_value
              )
      ]
      };
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value { 1 }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = 1;';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_SET

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Bool/toggle.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_TOGGLE';
  package Moose::Meta::Method::Accessor::Native::Bool::toggle;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Bool::toggle::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Bool::toggle::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer' => {
      -excludes => [
          qw(
              _maximum_arguments
              _inline_optimized_set_new_value
              )
      ]
  };
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' ? 0 : 1';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = ' . $slot_access . ' ? 0 : 1;';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_TOGGLE

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Bool/unset.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_UNSET';
  package Moose::Meta::Method::Accessor::Native::Bool::unset;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Bool::unset::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Bool::unset::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer' => {
      -excludes => [
          qw(
              _maximum_arguments
              _inline_optimized_set_new_value
              )
      ]
  };
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value { 0 }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = 0;';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_BOOL_UNSET

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Code/execute.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_CODE_EXECUTE';
  package Moose::Meta::Method::Accessor::Native::Code::execute;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Code::execute::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Code::execute::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . '->(@_)';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_CODE_EXECUTE

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Code/execute_method.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_CODE_EXECUTE_METHOD';
  package Moose::Meta::Method::Accessor::Native::Code::execute_method;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Code::execute_method::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Code::execute_method::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader';
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . '->($self, @_)';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_CODE_EXECUTE_METHOD

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Collection.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_COLLECTION';
  package Moose::Meta::Method::Accessor::Native::Collection;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Collection::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Collection::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  requires qw( _adds_members );
  
  sub _inline_coerce_new_values {
      my $self = shift;
  
      return unless $self->associated_attribute->should_coerce;
  
      return unless $self->_tc_member_type_can_coerce;
  
      return (
          '(' . $self->_new_members . ') = map { $member_coercion->($_) }',
                                               $self->_new_members . ';',
      );
  }
  
  sub _tc_member_type_can_coerce {
      my $self = shift;
  
      my $member_tc = $self->_tc_member_type;
  
      return $member_tc && $member_tc->has_coercion;
  }
  
  sub _tc_member_type {
      my $self = shift;
  
      my $tc = $self->associated_attribute->type_constraint;
      while ($tc) {
          return $tc->type_parameter
              if $tc->can('type_parameter');
          $tc = $tc->parent;
      }
  
      return;
  }
  
  sub _writer_value_needs_copy {
      my $self = shift;
  
      return $self->_constraint_must_be_checked
          && !$self->_check_new_members_only;
  }
  
  sub _inline_tc_code {
      my $self = shift;
      my ($value, $tc, $coercion, $message, $is_lazy) = @_;
  
      return unless $self->_constraint_must_be_checked;
  
      if ($self->_check_new_members_only) {
          return unless $self->_adds_members;
  
          return $self->_inline_check_member_constraint($self->_new_members);
      }
      else {
          return (
              $self->_inline_check_coercion($value, $tc, $coercion, $is_lazy),
              $self->_inline_check_constraint($value, $tc, $message, $is_lazy),
          );
      }
  }
  
  sub _check_new_members_only {
      my $self = shift;
  
      my $attr = $self->associated_attribute;
  
      my $tc = $attr->type_constraint;
  
      # If we have a coercion, we could come up with an entirely new value after
      # coercing, so we need to check everything,
      return 0 if $attr->should_coerce && $tc->has_coercion;
  
      # If the parent is our root type (ArrayRef, HashRef, etc), that means we
      # can just check the new members of the collection, because we know that
      # we will always be generating an appropriate collection type.
      #
      # However, if this type has its own constraint (it's Parameteriz_able_,
      # not Paramet_erized_), we don't know what is being checked by the
      # constraint, so we need to check the whole value, not just the members.
      return 1
          if $self->_is_root_type( $tc->parent )
              && $tc->isa('Moose::Meta::TypeConstraint::Parameterized');
  
      return 0;
  }
  
  sub _inline_check_member_constraint {
      my $self = shift;
      my ($new_value) = @_;
  
      my $attr_name = $self->associated_attribute->name;
  
      my $check
          = $self->_tc_member_type->can_be_inlined
          ? '! (' . $self->_tc_member_type->_inline_check('$new_val') . ')'
          : ' !$member_tc->($new_val) ';
  
      return (
          'for my $new_val (' . $new_value . ') {',
              "if ($check) {",
                  $self->_inline_throw_error(
                      '"A new member value for ' . $attr_name
                    . ' does not pass its type constraint because: "' . ' . '
                    . 'do { local $_ = $new_val; $member_message->($new_val) }',
                      'data => $new_val',
                  ) . ';',
              '}',
          '}',
      );
  }
  
  sub _inline_get_old_value_for_trigger {
      my $self = shift;
      my ($instance, $old) = @_;
  
      my $attr = $self->associated_attribute;
      return unless $attr->has_trigger;
  
      return (
          'my ' . $old . ' = ' . $self->_has_value($instance),
              '? ' . $self->_copy_old_value($self->_get_value($instance)),
              ': ();',
      );
  }
  
  around _eval_environment => sub {
      my $orig = shift;
      my $self = shift;
  
      my $env = $self->$orig(@_);
  
      my $member_tc = $self->_tc_member_type;
  
      return $env unless $member_tc;
  
      $env->{'$member_tc'} = \( $member_tc->_compiled_type_constraint );
      $env->{'$member_coercion'} = \(
          $member_tc->coercion->_compiled_type_coercion
      ) if $member_tc->has_coercion;
      $env->{'$member_message'} = \(
          $member_tc->has_message
              ? $member_tc->message
              : $member_tc->_default_message
      );
  
      my $tc_env = $member_tc->inline_environment();
  
      $env = { %{$env}, %{$tc_env} };
  
      return $env;
  };
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_COLLECTION

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Counter/Writer.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_WRITER';
  package Moose::Meta::Method::Accessor::Native::Counter::Writer;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Counter::Writer::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Counter::Writer::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer';
  
  sub _constraint_must_be_checked {
      my $self = shift;
  
      my $attr = $self->associated_attribute;
  
      return $attr->has_type_constraint
          && ($attr->type_constraint->name =~ /^(?:Num|Int)$/
           || ($attr->should_coerce && $attr->type_constraint->has_coercion)
             );
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_WRITER

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Counter/dec.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_DEC';
  package Moose::Meta::Method::Accessor::Native::Counter::dec;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Counter::dec::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Counter::dec::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer' => {
      -excludes => [
          qw(
              _minimum_arguments
              _maximum_arguments
              _inline_optimized_set_new_value
              )
      ]
  };
  
  sub _minimum_arguments { 0 }
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' - (defined $_[0] ? $_[0] : 1)';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' -= defined $_[0] ? $_[0] : 1;';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_DEC

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Counter/inc.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_INC';
  package Moose::Meta::Method::Accessor::Native::Counter::inc;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Counter::inc::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Counter::inc::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer' => {
      -excludes => [
          qw(
              _minimum_arguments
              _maximum_arguments
              _inline_optimized_set_new_value
              )
      ]
  };
  
  sub _minimum_arguments { 0 }
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' + (defined $_[0] ? $_[0] : 1)';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' += defined $_[0] ? $_[0] : 1;';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_INC

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Counter/reset.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_RESET';
  package Moose::Meta::Method::Accessor::Native::Counter::reset;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Counter::reset::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Counter::reset::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer' => {
      -excludes => [
          qw(
              _maximum_arguments
              _inline_optimized_set_new_value
              )
      ]
  };
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      my $attr = $self->associated_attribute;
  
      return '(do { '
               . join(' ', $attr->_inline_generate_default(
                     '$self', '$default_for_reset'
                 )) . ' '
               . '$default_for_reset; '
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = ' . $self->_potential_value . ';';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_RESET

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Counter/set.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_SET';
  package Moose::Meta::Method::Accessor::Native::Counter::set;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Counter::set::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Counter::set::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer' => {
      -excludes => [
          qw(
              _minimum_arguments
              _maximum_arguments
              _inline_optimized_set_new_value
              )
      ]
  };
  
  sub _minimum_arguments { 1 }
  sub _maximum_arguments { 1 }
  
  sub _potential_value { '$_[0]' }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = $_[0];';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_COUNTER_SET

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Hash.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH';
  package Moose::Meta::Method::Accessor::Native::Hash;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Hash::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Hash::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  sub _inline_check_var_is_valid_key {
      my $self = shift;
      my ($var) = @_;
  
      return (
          'if (!defined(' . $var . ')) {',
              $self->_inline_throw_error(
                  '"The key passed to ' . $self->delegate_to_method
                . ' must be a defined value"',
              ) . ';',
          '}',
      );
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Hash/Writer.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_WRITER';
  package Moose::Meta::Method::Accessor::Native::Hash::Writer;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Hash::Writer::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Hash::Writer::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Class::MOP::MiniTrait;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer' => {
          -excludes => ['_inline_coerce_new_values'],
      },
      'Moose::Meta::Method::Accessor::Native::Hash',
      'Moose::Meta::Method::Accessor::Native::Collection';
  
  sub _new_values { '@values' }
  
  sub _copy_old_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '{ %{ (' . $slot_access . ') } }';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_WRITER

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Hash/accessor.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_ACCESSOR';
  package Moose::Meta::Method::Accessor::Native::Hash::accessor;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Hash::accessor::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Hash::accessor::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Hash::set' => {
      -excludes => [
          qw(
              _generate_method
              _minimum_arguments
              _maximum_arguments
              )
      ]
      },
      'Moose::Meta::Method::Accessor::Native::Hash::get' => {
      -excludes => [
          qw(
              _generate_method
              _minimum_arguments
              _maximum_arguments
              _inline_check_argument_count
              _inline_check_arguments
              _inline_process_arguments
              _return_value
              )
      ]
      };
  
  sub _generate_method {
      my $self = shift;
  
      my $inv         = '$self';
      my $slot_access = $self->_get_value($inv);
  
      return (
          'sub {',
              'my ' . $inv . ' = shift;',
              $self->_inline_curried_arguments,
              $self->_inline_check_lazy($inv, '$type_constraint', '$type_coercion', '$type_message'),
              # get
              'if (@_ == 1) {',
                  $self->_inline_check_var_is_valid_key('$_[0]'),
                  $slot_access . '->{$_[0]}',
              '}',
              # set
              'else {',
                  $self->_inline_writer_core($inv, $slot_access),
              '}',
          '}',
      );
  }
  
  sub _minimum_arguments { 1 }
  sub _maximum_arguments { 2 }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_ACCESSOR

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Hash/clear.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_CLEAR';
  package Moose::Meta::Method::Accessor::Native::Hash::clear;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Hash::clear::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Hash::clear::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Hash::Writer' => {
      -excludes => [
          qw(
              _maximum_arguments
              _inline_optimized_set_new_value
              _return_value
              )
      ]
  };
  
  sub _maximum_arguments { 0 }
  
  sub _adds_members { 0 }
  
  sub _potential_value { '{}' }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = {};';
  }
  
  sub _return_value { '' }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_CLEAR

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Hash/count.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_COUNT';
  package Moose::Meta::Method::Accessor::Native::Hash::count;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Hash::count::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Hash::count::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Scalar::Util qw( looks_like_number );
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader' =>
      { -excludes => ['_maximum_arguments'] };
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'scalar keys %{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_COUNT

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Hash/defined.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_DEFINED';
  package Moose::Meta::Method::Accessor::Native::Hash::defined;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Hash::defined::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Hash::defined::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Scalar::Util qw( looks_like_number );
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader' => {
      -excludes => [
          qw(
              _minimum_arguments
              _maximum_arguments
              _inline_check_arguments
              )
      ],
      },
      'Moose::Meta::Method::Accessor::Native::Hash';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return $self->_inline_check_var_is_valid_key('$_[0]');
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'defined ' . $slot_access . '->{ $_[0] }';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_DEFINED

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Hash/delete.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_DELETE';
  package Moose::Meta::Method::Accessor::Native::Hash::delete;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Hash::delete::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Hash::delete::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Hash::Writer' => {
      -excludes => [
          qw(
              _inline_optimized_set_new_value
              _return_value
              )
      ],
  };
  
  sub _adds_members { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my %potential = %{ (' . $slot_access . ') }; '
               . '@return = delete @potential{@_}; '
               . '\%potential; '
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return '@return = delete @{ (' . $slot_access . ') }{@_};';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'wantarray ? @return : $return[-1]';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_DELETE

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Hash/elements.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_ELEMENTS';
  package Moose::Meta::Method::Accessor::Native::Hash::elements;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Hash::elements::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Hash::elements::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Scalar::Util qw( looks_like_number );
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader' =>
      { -excludes => ['_maximum_arguments'] };
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'map { $_, ' . $slot_access . '->{$_} } '
               . 'keys %{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_ELEMENTS

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Hash/exists.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_EXISTS';
  package Moose::Meta::Method::Accessor::Native::Hash::exists;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Hash::exists::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Hash::exists::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Scalar::Util qw( looks_like_number );
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader' => {
      -excludes => [
          qw(
              _minimum_arguments
              _maximum_arguments
              _inline_check_arguments
              )
      ],
      },
      'Moose::Meta::Method::Accessor::Native::Hash';
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return $self->_inline_check_var_is_valid_key('$_[0]');
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = shift;
  
      return 'exists ' . $slot_access . '->{ $_[0] }';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_EXISTS

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Hash/get.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_GET';
  package Moose::Meta::Method::Accessor::Native::Hash::get;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Hash::get::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Hash::get::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Scalar::Util qw( looks_like_number );
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader' => {
      -excludes => [
          qw(
              _minimum_arguments
              _inline_check_arguments
              )
      ],
      },
      'Moose::Meta::Method::Accessor::Native::Hash';
  
  sub _minimum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'for (@_) {',
              $self->_inline_check_var_is_valid_key('$_'),
          '}',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '@_ > 1 '
               . '? @{ (' . $slot_access . ') }{@_} '
               . ': ' . $slot_access . '->{$_[0]}';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_GET

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Hash/is_empty.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_IS_EMPTY';
  package Moose::Meta::Method::Accessor::Native::Hash::is_empty;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Hash::is_empty::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Hash::is_empty::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Scalar::Util qw( looks_like_number );
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader' =>
      { -excludes => ['_maximum_arguments'] };
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'scalar keys %{ (' . $slot_access . ') } ? 0 : 1';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_IS_EMPTY

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Hash/keys.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_KEYS';
  package Moose::Meta::Method::Accessor::Native::Hash::keys;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Hash::keys::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Hash::keys::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Scalar::Util qw( looks_like_number );
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader' =>
      { -excludes => ['_maximum_arguments'] };
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'keys %{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_KEYS

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Hash/kv.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_KV';
  package Moose::Meta::Method::Accessor::Native::Hash::kv;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Hash::kv::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Hash::kv::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Scalar::Util qw( looks_like_number );
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader' =>
      { -excludes => ['_maximum_arguments'] };
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'map { [ $_, ' . $slot_access . '->{$_} ] } '
               . 'keys %{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_KV

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Hash/set.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_SET';
  package Moose::Meta::Method::Accessor::Native::Hash::set;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Hash::set::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Hash::set::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use List::MoreUtils ();
  use Scalar::Util qw( looks_like_number );
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Hash::Writer' => {
      -excludes => [
          qw(
              _minimum_arguments
              _maximum_arguments
              _inline_process_arguments
              _inline_check_arguments
              _inline_coerce_new_values
              _inline_optimized_set_new_value
              _return_value
              )
      ],
  };
  
  sub _minimum_arguments { 2 }
  
  sub _maximum_arguments { undef }
  
  around _inline_check_argument_count => sub {
      my $orig = shift;
      my $self = shift;
  
      return (
          $self->$orig(@_),
          'if (@_ % 2) {',
              $self->_inline_throw_error(
                  sprintf(
                      '"You must pass an even number of arguments to %s"',
                      $self->delegate_to_method,
                  ),
              ) . ';',
          '}',
      );
  };
  
  sub _inline_process_arguments {
      my $self = shift;
  
      return (
          'my @keys_idx = grep { ! ($_ % 2) } 0..$#_;',
          'my @values_idx = grep { $_ % 2 } 0..$#_;',
      );
  }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'for (@keys_idx) {',
              'if (!defined($_[$_])) {',
                  $self->_inline_throw_error(
                      sprintf(
                          '"Hash keys passed to %s must be defined"',
                          $self->delegate_to_method,
                      ),
                  ) . ';',
              '}',
          '}',
      );
  }
  
  sub _adds_members { 1 }
  
  # We need to override this because while @_ can be written to, we cannot write
  # directly to $_[1].
  sub _inline_coerce_new_values {
      my $self = shift;
  
      return unless $self->associated_attribute->should_coerce;
  
      return unless $self->_tc_member_type_can_coerce;
  
      # Is there a simpler way to do this?
      return (
          'my $iter = List::MoreUtils::natatime(2, @_);',
          '@_ = ();',
          'while (my ($key, $val) = $iter->()) {',
              'push @_, $key, $member_coercion->($val);',
          '}',
      );
  };
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '{ %{ (' . $slot_access . ') }, @_ }';
  }
  
  sub _new_members { '@_[ @values_idx ]' }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return '@{ (' . $slot_access . ') }{ @_[@keys_idx] } = @_[@values_idx];';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'wantarray '
               . '? @{ (' . $slot_access . ') }{ @_[@keys_idx] } '
               . ': ' . $slot_access . '->{ $_[$keys_idx[0]] }';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_SET

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Hash/shallow_clone.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_SHALLOW_CLONE';
  package Moose::Meta::Method::Accessor::Native::Hash::shallow_clone;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Hash::shallow_clone::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Hash::shallow_clone::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader' => {
      -excludes => [
          qw(
              _minimum_arguments
              _maximum_arguments
              )
      ]
  };
  
  sub _minimum_arguments { 0 }
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '{ %{ (' . $slot_access . ') } }';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_SHALLOW_CLONE

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Hash/values.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_VALUES';
  package Moose::Meta::Method::Accessor::Native::Hash::values;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Hash::values::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Hash::values::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Scalar::Util qw( looks_like_number );
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader' =>
      { -excludes => ['_maximum_arguments'] };
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'values %{ (' . $slot_access . ') }';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_HASH_VALUES

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Number/abs.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_ABS';
  package Moose::Meta::Method::Accessor::Native::Number::abs;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Number::abs::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Number::abs::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer' => {
      -excludes => [
          qw(
              _maximum_arguments
              _inline_optimized_set_new_value
              )
      ]
      };
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'abs(' . $slot_access . ')';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = abs(' . $slot_access . ');';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_ABS

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Number/add.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_ADD';
  package Moose::Meta::Method::Accessor::Native::Number::add;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Number::add::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Number::add::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer' => {
      -excludes => [
          qw(
              _minimum_arguments
              _maximum_arguments
              _inline_optimized_set_new_value
              )
      ]
      };
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' + $_[0]';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' += $_[0];';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_ADD

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Number/div.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_DIV';
  package Moose::Meta::Method::Accessor::Native::Number::div;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Number::div::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Number::div::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer' => {
      -excludes => [
          qw(
              _minimum_arguments
              _maximum_arguments
              _inline_optimized_set_new_value
              )
      ]
      };
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' / $_[0]';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' /= $_[0];';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_DIV

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Number/mod.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_MOD';
  package Moose::Meta::Method::Accessor::Native::Number::mod;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Number::mod::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Number::mod::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer' => {
      -excludes => [
          qw(
              _minimum_arguments
              _maximum_arguments
              _inline_optimized_set_new_value
              )
      ]
      };
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' % $_[0]';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' %= $_[0];';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_MOD

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Number/mul.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_MUL';
  package Moose::Meta::Method::Accessor::Native::Number::mul;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Number::mul::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Number::mul::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer' => {
      -excludes => [
          qw(
              _minimum_arguments
              _maximum_arguments
              _inline_optimized_set_new_value
              )
      ]
      };
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' * $_[0]';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' *= $_[0];';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_MUL

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Number/set.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_SET';
  package Moose::Meta::Method::Accessor::Native::Number::set;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Number::set::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Number::set::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer' => {
      -excludes => [
          qw(
              _minimum_arguments
              _maximum_arguments
              _inline_optimized_set_new_value
              )
      ]
      };
  
  sub _minimum_arguments { 1 }
  sub _maximum_arguments { 1 }
  
  sub _potential_value { '$_[0]' }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = $_[0];';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_SET

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Number/sub.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_SUB';
  package Moose::Meta::Method::Accessor::Native::Number::sub;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Number::sub::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Number::sub::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer' => {
      -excludes => [
          qw(
              _minimum_arguments
              _maximum_arguments
              _inline_optimized_set_new_value
              )
      ]
      };
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' - $_[0]';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' -= $_[0];';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_NUMBER_SUB

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Reader.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_READER';
  package Moose::Meta::Method::Accessor::Native::Reader;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Reader::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Reader::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native';
  
  requires '_return_value';
  
  sub _generate_method {
      my $self = shift;
  
      my $inv         = '$self';
      my $slot_access = $self->_get_value($inv);
  
      return (
          'sub {',
              'my ' . $inv . ' = shift;',
              $self->_inline_curried_arguments,
              $self->_inline_reader_core($inv, $slot_access, @_),
          '}',
      );
  }
  
  sub _inline_reader_core {
      my $self = shift;
      my ($inv, $slot_access, @extra) = @_;
  
      return (
          $self->_inline_check_argument_count,
          $self->_inline_process_arguments($inv, $slot_access),
          $self->_inline_check_arguments,
          $self->_inline_check_lazy($inv, '$type_constraint', '$type_coercion', '$type_message'),
          $self->_inline_return_value($slot_access),
      );
  }
  
  sub _inline_process_arguments { return }
  
  sub _inline_check_arguments { return }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_READER

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/String/append.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_APPEND';
  package Moose::Meta::Method::Accessor::Native::String::append;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::String::append::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::String::append::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer' => {
      -excludes => [
          qw(
              _minimum_arguments
              _maximum_arguments
              _inline_optimized_set_new_value
              )
      ]
      };
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '( ' . $slot_access . ' . $_[0] )';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' .= $_[0];';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_APPEND

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/String/chomp.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_CHOMP';
  package Moose::Meta::Method::Accessor::Native::String::chomp;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::String::chomp::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::String::chomp::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer' => {
      -excludes => [
          qw(
              _maximum_arguments
              _inline_optimized_set_new_value
              _return_value
              )
      ]
  };
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my $val = ' . $slot_access . '; '
               . '@return = chomp $val; '
               . '$val '
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return '@return = chomp ' . $slot_access . ';';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '$return[0]';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_CHOMP

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/String/chop.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_CHOP';
  package Moose::Meta::Method::Accessor::Native::String::chop;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::String::chop::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::String::chop::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer' => {
      -excludes => [
          qw(
              _maximum_arguments
              _inline_optimized_set_new_value
              _return_value
              )
      ]
  };
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my $val = ' . $slot_access . '; '
               . '@return = chop $val; '
               . '$val; '
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return '@return = chop ' . $slot_access . ';';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '$return[0]';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_CHOP

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/String/clear.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_CLEAR';
  package Moose::Meta::Method::Accessor::Native::String::clear;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::String::clear::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::String::clear::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer' => {
      -excludes => [
          qw(
              _maximum_arguments
              _inline_optimized_set_new_value
              )
      ]
  };
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value { '""' }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = "";';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_CLEAR

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/String/inc.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_INC';
  package Moose::Meta::Method::Accessor::Native::String::inc;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::String::inc::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::String::inc::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer' => {
      -excludes => [
          qw(
              _maximum_arguments
              _inline_optimized_set_new_value
              )
      ]
      };
  
  sub _maximum_arguments { 0 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my $val = ' . $slot_access . '; '
               . '$val++; '
               . '$val; '
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . '++;';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_INC

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/String/length.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_LENGTH';
  package Moose::Meta::Method::Accessor::Native::String::length;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::String::length::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::String::length::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader' =>
      { -excludes => ['_maximum_arguments'] };
  
  sub _maximum_arguments { 0 }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return 'length ' . $slot_access;
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_LENGTH

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/String/match.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_MATCH';
  package Moose::Meta::Method::Accessor::Native::String::match;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::String::match::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::String::match::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Util ();
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader' => {
      -excludes => [
          qw(
              _minimum_arguments
              _maximum_arguments
              _inline_check_arguments
              )
      ]
  };
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!Moose::Util::_STRINGLIKE0($_[0]) && !Params::Util::_REGEX($_[0])) {',
              $self->_inline_throw_error(
                  '"The argument passed to match must be a string or regexp '
                . 'reference"',
              ) . ';',
          '}',
      );
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access . ' =~ $_[0]';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_MATCH

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/String/prepend.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_PREPEND';
  package Moose::Meta::Method::Accessor::Native::String::prepend;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::String::prepend::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::String::prepend::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer' => {
      -excludes => [
          qw(
              _minimum_arguments
              _maximum_arguments
              _inline_optimized_set_new_value
              )
      ]
      };
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 1 }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '$_[0] . ' . $slot_access;
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return $slot_access . ' = $_[0] . ' . $slot_access . ';';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_PREPEND

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/String/replace.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_REPLACE';
  package Moose::Meta::Method::Accessor::Native::String::replace;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::String::replace::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::String::replace::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Util ();
  use Params::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Writer' => {
      -excludes => [
          qw(
              _minimum_arguments
              _maximum_arguments
              _inline_check_arguments
              _inline_optimized_set_new_value
              )
      ]
      };
  
  sub _minimum_arguments { 1 }
  
  sub _maximum_arguments { 2 }
  
  sub _inline_check_arguments {
      my $self = shift;
  
      return (
          'if (!Moose::Util::_STRINGLIKE0($_[0]) && !Params::Util::_REGEX($_[0])) {',
              $self->_inline_throw_error(
                  '"The first argument passed to replace must be a string or '
                . 'regexp reference"'
              ) . ';',
          '}',
          'if (!Moose::Util::_STRINGLIKE0($_[1]) && !Params::Util::_CODELIKE($_[1])) {',
              $self->_inline_throw_error(
                  '"The second argument passed to replace must be a string or '
                . 'code reference"'
              ) . ';',
          '}',
      );
  }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my $val = ' . $slot_access . '; '
               . 'ref $_[1] '
                   . '? $val =~ s/$_[0]/$_[1]->()/e '
                   . ': $val =~ s/$_[0]/$_[1]/; '
               . '$val; '
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return (
          'ref $_[1]',
              '? ' . $slot_access . ' =~ s/$_[0]/$_[1]->()/e',
              ': ' . $slot_access . ' =~ s/$_[0]/$_[1]/;',
       );
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_REPLACE

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/String/substr.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_SUBSTR';
  package Moose::Meta::Method::Accessor::Native::String::substr;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::String::substr::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::String::substr::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Util ();
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native::Reader' => {
      -excludes => [
          qw( _generate_method
              _minimum_arguments
              _maximum_arguments
              _inline_process_arguments
              _inline_check_arguments
              _return_value
              )
      ]
      },
      'Moose::Meta::Method::Accessor::Native::Writer' => {
      -excludes => [
          qw(
              _generate_method
              _minimum_arguments
              _maximum_arguments
              _inline_process_arguments
              _inline_check_arguments
              _inline_optimized_set_new_value
              _return_value
              )
      ]
      };
  
  sub _generate_method {
      my $self = shift;
  
      my $inv         = '$self';
      my $slot_access = $self->_get_value($inv);
  
      return (
          'sub {',
              'my ' . $inv . ' = shift;',
              $self->_inline_curried_arguments,
              'if (@_ == 1 || @_ == 2) {',
                  $self->_inline_reader_core($inv, $slot_access),
              '}',
              'elsif (@_ == 3) {',
                  $self->_inline_writer_core($inv, $slot_access),
              '}',
              'else {',
                  $self->_inline_check_argument_count,
              '}',
          '}',
      );
  }
  
  sub _minimum_arguments { 1 }
  sub _maximum_arguments { 3 }
  
  sub _inline_process_arguments {
      my $self = shift;
      my ($inv, $slot_access) = @_;
  
      return (
          'my $offset = shift;',
          'my $length = @_ ? shift : length ' . $slot_access . ';',
          'my $replacement = shift;',
      );
  }
  
  sub _inline_check_arguments {
      my $self = shift;
      my ($for_writer) = @_;
  
      my @code = (
          'if ($offset !~ /^-?\d+$/) {',
              $self->_inline_throw_error(
                  '"The first argument passed to substr must be an integer"'
              ) . ';',
          '}',
          'if ($length !~ /^-?\d+$/) {',
              $self->_inline_throw_error(
                  '"The second argument passed to substr must be an integer"'
              ) . ';',
          '}',
      );
  
      if ($for_writer) {
          push @code, (
              'if (!Moose::Util::_STRINGLIKE0($replacement)) {',
                  $self->_inline_throw_error(
                      '"The third argument passed to substr must be a string"'
                  ) . ';',
              '}',
          );
      }
  
      return @code;
  }
  
  sub _potential_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return '(do { '
               . 'my $potential = ' . $slot_access . '; '
               . '@return = substr $potential, $offset, $length, $replacement; '
               . '$potential; '
           . '})';
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
      my ($inv, $new, $slot_access) = @_;
  
      return '@return = substr ' . $slot_access . ', '
                             . '$offset, $length, $replacement;';
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access, $for_writer) = @_;
  
      return '$return[0]' if $for_writer;
  
      return 'substr ' . $slot_access . ', $offset, $length';
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_STRING_SUBSTR

$fatpacked{"i686-linux/Moose/Meta/Method/Accessor/Native/Writer.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_WRITER';
  package Moose::Meta::Method::Accessor::Native::Writer;
  BEGIN {
    $Moose::Meta::Method::Accessor::Native::Writer::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Accessor::Native::Writer::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use List::MoreUtils qw( any );
  
  use Moose::Role;
  
  with 'Moose::Meta::Method::Accessor::Native';
  
  requires '_potential_value';
  
  sub _generate_method {
      my $self = shift;
  
      my $inv         = '$self';
      my $slot_access = $self->_get_value($inv);
  
      return (
          'sub {',
              'my ' . $inv . ' = shift;',
              $self->_inline_curried_arguments,
              $self->_inline_writer_core($inv, $slot_access),
          '}',
      );
  }
  
  sub _inline_writer_core {
      my $self = shift;
      my ($inv, $slot_access) = @_;
  
      my $potential = $self->_potential_value($slot_access);
      my $old       = '@old';
  
      my @code;
      push @code, (
          $self->_inline_check_argument_count,
          $self->_inline_process_arguments($inv, $slot_access),
          $self->_inline_check_arguments('for writer'),
          $self->_inline_check_lazy($inv, '$type_constraint', '$type_coercion', '$type_message'),
      );
  
      if ($self->_return_value($slot_access)) {
          # some writers will save the return value in this variable when they
          # generate the potential value.
          push @code, 'my @return;'
      }
  
      push @code, (
          $self->_inline_coerce_new_values,
          $self->_inline_copy_native_value(\$potential),
          $self->_inline_tc_code($potential, '$type_constraint', '$type_coercion', '$type_message'),
          $self->_inline_get_old_value_for_trigger($inv, $old),
          $self->_inline_capture_return_value($slot_access),
          $self->_inline_set_new_value($inv, $potential, $slot_access),
          $self->_inline_trigger($inv, $slot_access, $old),
          $self->_inline_return_value($slot_access, 'for writer'),
      );
  
      return @code;
  }
  
  sub _inline_process_arguments { return }
  
  sub _inline_check_arguments { return }
  
  sub _inline_coerce_new_values { return }
  
  sub _writer_value_needs_copy {
      my $self = shift;
  
      return $self->_constraint_must_be_checked;
  }
  
  sub _constraint_must_be_checked {
      my $self = shift;
  
      my $attr = $self->associated_attribute;
  
      return $attr->has_type_constraint
          && (!$self->_is_root_type( $attr->type_constraint )
           || ( $attr->should_coerce && $attr->type_constraint->has_coercion)
             );
  }
  
  sub _is_root_type {
      my $self = shift;
      my ($type) = @_;
  
      my $name = $type->name;
  
      return any { $name eq $_ } @{ $self->root_types };
  }
  
  sub _inline_copy_native_value {
      my $self = shift;
      my ($potential_ref) = @_;
  
      return unless $self->_writer_value_needs_copy;
  
      my $code = 'my $potential = ' . ${$potential_ref} . ';';
  
      ${$potential_ref} = '$potential';
  
      return $code;
  }
  
  around _inline_tc_code => sub {
      my $orig = shift;
      my $self = shift;
      my ($value, $tc, $coercion, $message, $for_lazy) = @_;
  
      return unless $for_lazy || $self->_constraint_must_be_checked;
  
      return $self->$orig(@_);
  };
  
  around _inline_check_constraint => sub {
      my $orig = shift;
      my $self = shift;
      my ($value, $tc, $message, $for_lazy) = @_;
  
      return unless $for_lazy || $self->_constraint_must_be_checked;
  
      return $self->$orig(@_);
  };
  
  sub _inline_capture_return_value { return }
  
  sub _inline_set_new_value {
      my $self = shift;
  
      return $self->_inline_store_value(@_)
          if $self->_writer_value_needs_copy
          || !$self->_slot_access_can_be_inlined
          || !$self->_get_is_lvalue;
  
      return $self->_inline_optimized_set_new_value(@_);
  }
  
  sub _get_is_lvalue {
      my $self = shift;
  
      return $self->associated_attribute->associated_class->instance_metaclass->inline_get_is_lvalue;
  }
  
  sub _inline_optimized_set_new_value {
      my $self = shift;
  
      return $self->_inline_store_value(@_);
  }
  
  sub _return_value {
      my $self = shift;
      my ($slot_access) = @_;
  
      return $slot_access;
  }
  
  no Moose::Role;
  
  1;
I686-LINUX_MOOSE_META_METHOD_ACCESSOR_NATIVE_WRITER

$fatpacked{"i686-linux/Moose/Meta/Method/Augmented.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_AUGMENTED';
  package Moose::Meta::Method::Augmented;
  BEGIN {
    $Moose::Meta::Method::Augmented::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Augmented::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use base 'Moose::Meta::Method';
  
  sub new {
      my ( $class, %args ) = @_;
  
      # the package can be overridden by roles
      # it is really more like body's compilation stash
      # this is where we need to override the definition of super() so that the
      # body of the code can call the right overridden version
      my $name = $args{name};
      my $meta = $args{class};
  
      my $super = $meta->find_next_method_by_name($name);
  
      (defined $super)
          || $meta->throw_error("You cannot augment '$name' because it has no super method", data => $name);
  
      my $_super_package = $super->package_name;
      # BUT!,... if this is an overridden method ....
      if ($super->isa('Moose::Meta::Method::Overridden')) {
          # we need to be sure that we actually
          # find the next method, which is not
          # an 'override' method, the reason is
          # that an 'override' method will not
          # be the one calling inner()
          my $real_super = $meta->_find_next_method_by_name_which_is_not_overridden($name);
          $_super_package = $real_super->package_name;
      }
  
      my $super_body = $super->body;
  
      my $method = $args{method};
  
      my $body = sub {
          local $Moose::INNER_ARGS{$_super_package} = [ @_ ];
          local $Moose::INNER_BODY{$_super_package} = $method;
          $super_body->(@_);
      };
  
      # FIXME store additional attrs
      $class->wrap(
          $body,
          package_name => $meta->name,
          name         => $name
      );
  }
  
  1;
  
  # ABSTRACT: A Moose Method metaclass for augmented methods
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::Method::Augmented - A Moose Method metaclass for augmented methods
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This class implements method augmentation logic for the L<Moose>
  C<augment> keyword.
  
  The augmentation subroutine reference will be invoked explicitly using
  the C<inner> keyword from the parent class's method definition.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Method::Augmented> is a subclass of L<Moose::Meta::Method>.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Moose::Meta::Method::Augmented->new(%options) >>
  
  This constructs a new object. It accepts the following options:
  
  =over 8
  
  =item * class
  
  The metaclass object for the class in which the augmentation is being
  declared. This option is required.
  
  =item * name
  
  The name of the method which we are augmenting. This method must exist
  in one of the class's superclasses. This option is required.
  
  =item * method
  
  The subroutine reference which implements the augmentation. This
  option is required.
  
  =back
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_META_METHOD_AUGMENTED

$fatpacked{"i686-linux/Moose/Meta/Method/Constructor.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_CONSTRUCTOR';
  
  package Moose::Meta::Method::Constructor;
  BEGIN {
    $Moose::Meta::Method::Constructor::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Constructor::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Carp ();
  use List::MoreUtils 'any';
  use Scalar::Util 'blessed', 'weaken', 'looks_like_number', 'refaddr';
  use Try::Tiny;
  
  use base 'Moose::Meta::Method',
           'Class::MOP::Method::Constructor';
  
  sub new {
      my $class   = shift;
      my %options = @_;
  
      my $meta = $options{metaclass};
  
      (ref $options{options} eq 'HASH')
          || $class->throw_error("You must pass a hash of options", data => $options{options});
  
      ($options{package_name} && $options{name})
          || $class->throw_error("You must supply the package_name and name parameters $Class::MOP::Method::UPGRADE_ERROR_TEXT");
  
      my $self = bless {
          'body'          => undef,
          'package_name'  => $options{package_name},
          'name'          => $options{name},
          'options'       => $options{options},
          'associated_metaclass' => $meta,
          'definition_context' => $options{definition_context},
          '_expected_method_class' => $options{_expected_method_class} || 'Moose::Object',
      } => $class;
  
      # we don't want this creating
      # a cycle in the code, if not
      # needed
      weaken($self->{'associated_metaclass'});
  
      $self->_initialize_body;
  
      return $self;
  }
  
  ## method
  
  sub _initialize_body {
      my $self = shift;
      $self->{'body'} = $self->_generate_constructor_method_inline;
  }
  
  1;
  
  # ABSTRACT: Method Meta Object for constructors
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::Method::Constructor - Method Meta Object for constructors
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This class is a subclass of L<Class::MOP::Method::Constructor> that
  provides additional Moose-specific functionality
  
  To understand this class, you should read the the
  L<Class::MOP::Method::Constructor> documentation as well.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Method::Constructor> is a subclass of
  L<Moose::Meta::Method> I<and> L<Class::MOP::Method::Constructor>.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
  
I686-LINUX_MOOSE_META_METHOD_CONSTRUCTOR

$fatpacked{"i686-linux/Moose/Meta/Method/Delegation.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_DELEGATION';
  
  package Moose::Meta::Method::Delegation;
  BEGIN {
    $Moose::Meta::Method::Delegation::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Delegation::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Carp         'confess';
  use Scalar::Util 'blessed', 'weaken';
  
  use base 'Moose::Meta::Method',
           'Class::MOP::Method::Generated';
  
  
  sub new {
      my $class   = shift;
      my %options = @_;
  
      ( exists $options{attribute} )
          || confess "You must supply an attribute to construct with";
  
      ( blessed( $options{attribute} )
              && $options{attribute}->isa('Moose::Meta::Attribute') )
          || confess
          "You must supply an attribute which is a 'Moose::Meta::Attribute' instance";
  
      ( $options{package_name} && $options{name} )
          || confess
          "You must supply the package_name and name parameters $Class::MOP::Method::UPGRADE_ERROR_TEXT";
  
      ( $options{delegate_to_method} && ( !ref $options{delegate_to_method} )
              || ( 'CODE' eq ref $options{delegate_to_method} ) )
          || confess
          'You must supply a delegate_to_method which is a method name or a CODE reference';
  
      exists $options{curried_arguments}
          || ( $options{curried_arguments} = [] );
  
      ( $options{curried_arguments} &&
          ( 'ARRAY' eq ref $options{curried_arguments} ) )
          || confess 'You must supply a curried_arguments which is an ARRAY reference';
  
      my $self = $class->_new( \%options );
  
      weaken( $self->{'attribute'} );
  
      $self->_initialize_body;
  
      return $self;
  }
  
  sub _new {
      my $class = shift;
      my $options = @_ == 1 ? $_[0] : {@_};
  
      return bless $options, $class;
  }
  
  sub curried_arguments { (shift)->{'curried_arguments'} }
  
  sub associated_attribute { (shift)->{'attribute'} }
  
  sub delegate_to_method { (shift)->{'delegate_to_method'} }
  
  sub _initialize_body {
      my $self = shift;
  
      my $method_to_call = $self->delegate_to_method;
      return $self->{body} = $method_to_call
          if ref $method_to_call;
  
      my $accessor = $self->_get_delegate_accessor;
  
      my $handle_name = $self->name;
  
      # NOTE: we used to do a goto here, but the goto didn't handle
      # failure correctly (it just returned nothing), so I took that
      # out. However, the more I thought about it, the less I liked it
      # doing the goto, and I preferred the act of delegation being
      # actually represented in the stack trace.  - SL
      # not inlining this, since it won't really speed things up at
      # all... the only thing that would end up different would be
      # interpolating in $method_to_call, and a bunch of things in the
      # error handling that mostly never gets called - doy
      $self->{body} = sub {
          my $instance = shift;
          my $proxy    = $instance->$accessor();
  
          my $error
              = !defined $proxy                 ? ' is not defined'
              : ref($proxy) && !blessed($proxy) ? qq{ is not an object (got '$proxy')}
              : undef;
  
          if ($error) {
              $self->throw_error(
                  "Cannot delegate $handle_name to $method_to_call because "
                      . "the value of "
                      . $self->associated_attribute->name
                      . $error,
                  method_name => $method_to_call,
                  object      => $instance
              );
          }
          unshift @_, @{ $self->curried_arguments };
          $proxy->$method_to_call(@_);
      };
  }
  
  sub _get_delegate_accessor {
      my $self = shift;
      my $attr = $self->associated_attribute;
  
      # NOTE:
      # always use a named method when
      # possible, if you use the method
      # ref and there are modifiers on
      # the accessors then it will not
      # pick up the modifiers too. Only
      # the named method will assure that
      # we also have any modifiers run.
      # - SL
      my $accessor = $attr->has_read_method
          ? $attr->get_read_method
          : $attr->get_read_method_ref;
  
      $accessor = $accessor->body if Scalar::Util::blessed $accessor;
  
      return $accessor;
  }
  
  1;
  
  # ABSTRACT: A Moose Method metaclass for delegation methods
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::Method::Delegation - A Moose Method metaclass for delegation methods
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This is a subclass of L<Moose::Meta::Method> for delegation
  methods.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Moose::Meta::Method::Delegation->new(%options) >>
  
  This creates the delegation methods based on the provided C<%options>.
  
  =over 4
  
  =item I<attribute>
  
  This must be an instance of C<Moose::Meta::Attribute> which this
  accessor is being generated for. This options is B<required>.
  
  =item I<delegate_to_method>
  
  The method in the associated attribute's value to which we
  delegate. This can be either a method name or a code reference.
  
  =item I<curried_arguments>
  
  An array reference of arguments that will be prepended to the argument list for
  any call to the delegating method.
  
  =back
  
  =item B<< $metamethod->associated_attribute >>
  
  Returns the attribute associated with this method.
  
  =item B<< $metamethod->curried_arguments >>
  
  Return any curried arguments that will be passed to the delegated method.
  
  =item B<< $metamethod->delegate_to_method >>
  
  Returns the method to which this method delegates, as passed to the
  constructor.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_META_METHOD_DELEGATION

$fatpacked{"i686-linux/Moose/Meta/Method/Destructor.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_DESTRUCTOR';
  
  package Moose::Meta::Method::Destructor;
  BEGIN {
    $Moose::Meta::Method::Destructor::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Destructor::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Devel::GlobalDestruction ();
  use Scalar::Util 'blessed', 'weaken';
  use Try::Tiny;
  
  use base 'Moose::Meta::Method',
           'Class::MOP::Method::Inlined';
  
  sub new {
      my $class   = shift;
      my %options = @_;
  
      (ref $options{options} eq 'HASH')
          || $class->throw_error("You must pass a hash of options", data => $options{options});
  
      ($options{package_name} && $options{name})
          || $class->throw_error("You must supply the package_name and name parameters $Class::MOP::Method::UPGRADE_ERROR_TEXT");
  
      my $self = bless {
          # from our superclass
          'body'                 => undef,
          'package_name'         => $options{package_name},
          'name'                 => $options{name},
          # ...
          'options'              => $options{options},
          'definition_context'   => $options{definition_context},
          'associated_metaclass' => $options{metaclass},
      } => $class;
  
      # we don't want this creating
      # a cycle in the code, if not
      # needed
      weaken($self->{'associated_metaclass'});
  
      $self->_initialize_body;
  
      return $self;
  }
  
  ## accessors
  
  sub options              { (shift)->{'options'}              }
  
  ## method
  
  sub is_needed {
      my $self      = shift;
      my $metaclass = shift;
  
      ( blessed $metaclass && $metaclass->isa('Class::MOP::Class') )
          || $self->throw_error(
          "The is_needed method expected a metaclass object as its arugment");
  
      return $metaclass->find_method_by_name("DEMOLISHALL");
  }
  
  sub initialize_body {
      Carp::cluck('The initialize_body method has been made private.'
          . " The public version is deprecated and will be removed in a future release.\n");
      shift->_initialize_body;
  }
  
  sub _initialize_body {
      my $self = shift;
      # TODO:
      # the %options should also include a both
      # a call 'initializer' and call 'SUPER::'
      # options, which should cover approx 90%
      # of the possible use cases (even if it
      # requires some adaption on the part of
      # the author, after all, nothing is free)
  
      my $class = $self->associated_metaclass->name;
      my @source = (
          'sub {',
              'my $self = shift;',
              'return ' . $self->_generate_fallback_destructor('$self'),
                  'if Scalar::Util::blessed($self) ne \'' . $class . '\';',
              'local $?;',
              $self->_generate_DEMOLISHALL('$self'),
              'return;',
          '}',
      );
      warn join("\n", @source) if $self->options->{debug};
  
      my $code = try {
          $self->_compile_code(source => \@source);
      }
      catch {
          my $source = join("\n", @source);
          $self->throw_error(
              "Could not eval the destructor :\n\n$source\n\nbecause :\n\n$_",
              error => $_,
              data  => $source,
          );
      };
  
      $self->{'body'} = $code;
  }
  
  sub _generate_fallback_destructor {
      my $self = shift;
      my ($inv) = @_;
  
      return $inv . '->Moose::Object::DESTROY(@_)';
  }
  
  sub _generate_DEMOLISHALL {
      my $self = shift;
      my ($inv) = @_;
  
      my @methods = $self->associated_metaclass->find_all_methods_by_name('DEMOLISH');
      return unless @methods;
  
      return (
          'my $igd = Devel::GlobalDestruction::in_global_destruction;',
          'Try::Tiny::try {',
              (map { $inv . '->' . $_->{class} . '::DEMOLISH($igd);' } @methods),
          '}',
          'Try::Tiny::catch {',
              'die $_;',
          '};',
      );
  }
  
  
  1;
  
  # ABSTRACT: Method Meta Object for destructors
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::Method::Destructor - Method Meta Object for destructors
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This class is a subclass of L<Class::MOP::Class::Generated> that
  provides Moose-specific functionality for inlining destructors.
  
  To understand this class, you should read the the
  L<Class::MOP::Class::Generated> documentation as well.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Method::Destructor> is a subclass of
  L<Moose::Meta::Method> I<and> L<Class::MOP::Method::Generated>.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Moose::Meta::Method::Destructor->new(%options) >>
  
  This constructs a new object. It accepts the following options:
  
  =over 8
  
  =item * package_name
  
  The package for the class in which the destructor is being
  inlined. This option is required.
  
  =item * name
  
  The name of the destructor method. This option is required.
  
  =item * metaclass
  
  The metaclass for the class this destructor belongs to. This is
  optional, as it can be set later by calling C<<
  $metamethod->attach_to_class >>.
  
  =back
  
  =item B<< Moose::Meta;:Method::Destructor->is_needed($metaclass) >>
  
  Given a L<Moose::Meta::Class> object, this method returns a boolean
  indicating whether the class needs a destructor. If the class or any
  of its parents defines a C<DEMOLISH> method, it needs a destructor.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
  
I686-LINUX_MOOSE_META_METHOD_DESTRUCTOR

$fatpacked{"i686-linux/Moose/Meta/Method/Meta.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_META';
  
  package Moose::Meta::Method::Meta;
  BEGIN {
    $Moose::Meta::Method::Meta::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Meta::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use base 'Moose::Meta::Method',
           'Class::MOP::Method::Meta';
  
  sub _is_caller_mop_internal {
      my $self = shift;
      my ($caller) = @_;
      return 1 if $caller =~ /^Moose(?:::|$)/;
      return $self->SUPER::_is_caller_mop_internal($caller);
  }
  
  # XXX: ugh multiple inheritance
  sub wrap {
      my $class = shift;
      return $class->Class::MOP::Method::Meta::wrap(@_);
  }
  
  sub _make_compatible_with {
      my $self = shift;
      return $self->Class::MOP::Method::Meta::_make_compatible_with(@_);
  }
  
  1;
  
  # ABSTRACT: A Moose Method metaclass for C<meta> methods
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::Method::Meta - A Moose Method metaclass for C<meta> methods
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This class is a subclass of L<Class::MOP::Method::Meta> that
  provides additional Moose-specific functionality, all of which is
  private.
  
  To understand this class, you should read the the
  L<Class::MOP::Method::Meta> documentation.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_META_METHOD_META

$fatpacked{"i686-linux/Moose/Meta/Method/Overridden.pm"} = <<'I686-LINUX_MOOSE_META_METHOD_OVERRIDDEN';
  package Moose::Meta::Method::Overridden;
  BEGIN {
    $Moose::Meta::Method::Overridden::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Method::Overridden::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use base 'Moose::Meta::Method';
  
  sub new {
      my ( $class, %args ) = @_;
  
      # the package can be overridden by roles
      # it is really more like body's compilation stash
      # this is where we need to override the definition of super() so that the
      # body of the code can call the right overridden version
      my $super_package = $args{package} || $args{class}->name;
  
      my $name = $args{name};
  
      my $super = $args{class}->find_next_method_by_name($name);
  
      (defined $super)
          || $class->throw_error("You cannot override '$name' because it has no super method", data => $name);
  
      my $super_body = $super->body;
  
      my $method = $args{method};
  
      my $body = sub {
          local $Moose::SUPER_PACKAGE = $super_package;
          local @Moose::SUPER_ARGS = @_;
          local $Moose::SUPER_BODY = $super_body;
          return $method->(@_);
      };
  
      # FIXME do we need this make sure this works for next::method?
      # subname "${super_package}::${name}", $method;
  
      # FIXME store additional attrs
      $class->wrap(
          $body,
          package_name => $args{class}->name,
          name         => $name
      );
  }
  
  1;
  
  # ABSTRACT: A Moose Method metaclass for overridden methods
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::Method::Overridden - A Moose Method metaclass for overridden methods
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This class implements method overriding logic for the L<Moose>
  C<override> keyword.
  
  The overriding subroutine's parent will be invoked explicitly using
  the C<super> keyword from the parent class's method definition.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Moose::Meta::Method::Overridden->new(%options) >>
  
  This constructs a new object. It accepts the following options:
  
  =over 8
  
  =item * class
  
  The metaclass object for the class in which the override is being
  declared. This option is required.
  
  =item * name
  
  The name of the method which we are overriding. This method must exist
  in one of the class's superclasses. This option is required.
  
  =item * method
  
  The subroutine reference which implements the overriding. This option
  is required.
  
  =back
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_META_METHOD_OVERRIDDEN

$fatpacked{"i686-linux/Moose/Meta/Mixin/AttributeCore.pm"} = <<'I686-LINUX_MOOSE_META_MIXIN_ATTRIBUTECORE';
  package Moose::Meta::Mixin::AttributeCore;
  BEGIN {
    $Moose::Meta::Mixin::AttributeCore::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Mixin::AttributeCore::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use base 'Class::MOP::Mixin::AttributeCore';
  
  __PACKAGE__->meta->add_attribute(
      'isa' => (
          reader => '_isa_metadata',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'does' => (
          reader => '_does_metadata',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'is' => (
          reader => '_is_metadata',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'required' => (
          reader => 'is_required',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'lazy' => (
          reader => 'is_lazy', Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'lazy_build' => (
          reader => 'is_lazy_build',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'coerce' => (
          reader => 'should_coerce',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'weak_ref' => (
          reader => 'is_weak_ref',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'auto_deref' => (
          reader => 'should_auto_deref',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'type_constraint' => (
          reader    => 'type_constraint',
          predicate => 'has_type_constraint',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'trigger' => (
          reader    => 'trigger',
          predicate => 'has_trigger',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'handles' => (
          reader    => 'handles',
          writer    => '_set_handles',
          predicate => 'has_handles',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'documentation' => (
          reader    => 'documentation',
          predicate => 'has_documentation',
          Class::MOP::_definition_context(),
      )
  );
  
  1;
  
  # ABSTRACT: Core attributes shared by attribute metaclasses
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::Mixin::AttributeCore - Core attributes shared by attribute metaclasses
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This class implements the core attributes (aka properties) shared by all Moose
  attributes. See the L<Moose::Meta::Attribute> documentation for API details.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_META_MIXIN_ATTRIBUTECORE

$fatpacked{"i686-linux/Moose/Meta/Object/Trait.pm"} = <<'I686-LINUX_MOOSE_META_OBJECT_TRAIT';
  
  package Moose::Meta::Object::Trait;
  BEGIN {
    $Moose::Meta::Object::Trait::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Object::Trait::VERSION = '2.0401';
  }
  
  use Scalar::Util qw(blessed);
  
  sub _get_compatible_metaclass {
      my $orig = shift;
      my $self = shift;
      return $self->$orig(@_)
          || $self->_get_compatible_metaclass_by_role_reconciliation(@_);
  }
  
  sub _get_compatible_metaclass_by_role_reconciliation {
      my $self = shift;
      my ($other_name) = @_;
      my $meta_name = blessed($self) ? $self->_real_ref_name : $self;
  
      return unless Moose::Util::_classes_differ_by_roles_only(
          $meta_name, $other_name
      );
  
      return Moose::Util::_reconcile_roles_for_metaclass(
          $meta_name, $other_name
      );
  }
  
  1;
  
  # ABSTRACT: Some overrides for L<Class::MOP::Object> functionality
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::Object::Trait - Some overrides for L<Class::MOP::Object> functionality
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This module is entirely private, you shouldn't ever need to interact with
  it directly.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_META_OBJECT_TRAIT

$fatpacked{"i686-linux/Moose/Meta/Role.pm"} = <<'I686-LINUX_MOOSE_META_ROLE';
  package Moose::Meta::Role;
  BEGIN {
    $Moose::Meta::Role::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Role::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  use metaclass;
  
  use Class::Load qw(load_class);
  use Scalar::Util 'blessed';
  use Carp         'confess';
  use Devel::GlobalDestruction 'in_global_destruction';
  
  use Moose::Meta::Class;
  use Moose::Meta::Role::Attribute;
  use Moose::Meta::Role::Method;
  use Moose::Meta::Role::Method::Required;
  use Moose::Meta::Role::Method::Conflicting;
  use Moose::Meta::Method::Meta;
  use Moose::Util qw( ensure_all_roles );
  use Class::MOP::MiniTrait;
  
  use base 'Class::MOP::Module',
           'Class::MOP::Mixin::HasAttributes',
           'Class::MOP::Mixin::HasMethods';
  
  Class::MOP::MiniTrait::apply(__PACKAGE__, 'Moose::Meta::Object::Trait');
  
  ## ------------------------------------------------------------------
  ## NOTE:
  ## I normally don't do this, but I am doing
  ## a whole bunch of meta-programmin in this
  ## module, so it just makes sense. For a clearer
  ## picture of what is going on in the next
  ## several lines of code, look at the really
  ## big comment at the end of this file (right
  ## before the POD).
  ## - SL
  ## ------------------------------------------------------------------
  
  my $META = __PACKAGE__->meta;
  
  ## ------------------------------------------------------------------
  ## attributes ...
  
  # NOTE:
  # since roles are lazy, we hold all the attributes
  # of the individual role in 'stasis' until which
  # time when it is applied to a class. This means
  # keeping a lot of things in hash maps, so we are
  # using a little of that meta-programmin' magic
  # here an saving lots of extra typin. And since
  # many of these attributes above require similar
  # functionality to support them, so we again use
  # the wonders of meta-programmin' to deliver a
  # very compact solution to this normally verbose
  # problem.
  # - SL
  
  foreach my $action (
      {
          name        => 'excluded_roles_map',
          attr_reader => 'get_excluded_roles_map' ,
          methods     => {
              add       => 'add_excluded_roles',
              get_keys  => 'get_excluded_roles_list',
              existence => 'excludes_role',
          }
      },
      {
          name        => 'required_methods',
          attr_reader => 'get_required_methods_map',
          methods     => {
              remove     => 'remove_required_methods',
              get_values => 'get_required_method_list',
              existence  => 'requires_method',
          }
      },
  ) {
  
      my $attr_reader = $action->{attr_reader};
      my $methods     = $action->{methods};
  
      # create the attribute
      $META->add_attribute($action->{name} => (
          reader  => $attr_reader,
          default => sub { {} },
          Class::MOP::_definition_context(),
      ));
  
      # create some helper methods
      $META->add_method($methods->{add} => sub {
          my ($self, @values) = @_;
          $self->$attr_reader->{$_} = undef foreach @values;
      }) if exists $methods->{add};
  
      $META->add_method($methods->{get_keys} => sub {
          my ($self) = @_;
          keys %{$self->$attr_reader};
      }) if exists $methods->{get_keys};
  
      $META->add_method($methods->{get_values} => sub {
          my ($self) = @_;
          values %{$self->$attr_reader};
      }) if exists $methods->{get_values};
  
      $META->add_method($methods->{get} => sub {
          my ($self, $name) = @_;
          $self->$attr_reader->{$name}
      }) if exists $methods->{get};
  
      $META->add_method($methods->{existence} => sub {
          my ($self, $name) = @_;
          exists $self->$attr_reader->{$name} ? 1 : 0;
      }) if exists $methods->{existence};
  
      $META->add_method($methods->{remove} => sub {
          my ($self, @values) = @_;
          delete $self->$attr_reader->{$_} foreach @values;
      }) if exists $methods->{remove};
  }
  
  $META->add_attribute(
      'method_metaclass',
      reader  => 'method_metaclass',
      default => 'Moose::Meta::Role::Method',
      Class::MOP::_definition_context(),
  );
  
  $META->add_attribute(
      'required_method_metaclass',
      reader  => 'required_method_metaclass',
      default => 'Moose::Meta::Role::Method::Required',
      Class::MOP::_definition_context(),
  );
  
  $META->add_attribute(
      'conflicting_method_metaclass',
      reader  => 'conflicting_method_metaclass',
      default => 'Moose::Meta::Role::Method::Conflicting',
      Class::MOP::_definition_context(),
  );
  
  $META->add_attribute(
      'application_to_class_class',
      reader  => 'application_to_class_class',
      default => 'Moose::Meta::Role::Application::ToClass',
      Class::MOP::_definition_context(),
  );
  
  $META->add_attribute(
      'application_to_role_class',
      reader  => 'application_to_role_class',
      default => 'Moose::Meta::Role::Application::ToRole',
      Class::MOP::_definition_context(),
  );
  
  $META->add_attribute(
      'application_to_instance_class',
      reader  => 'application_to_instance_class',
      default => 'Moose::Meta::Role::Application::ToInstance',
      Class::MOP::_definition_context(),
  );
  
  $META->add_attribute(
      'applied_attribute_metaclass',
      reader  => 'applied_attribute_metaclass',
      default => 'Moose::Meta::Attribute',
      Class::MOP::_definition_context(),
  );
  
  # More or less copied from Moose::Meta::Class
  sub initialize {
      my $class = shift;
      my @args = @_;
      unshift @args, 'package' if @args % 2;
      my %opts = @args;
      my $package = delete $opts{package};
      return Class::MOP::get_metaclass_by_name($package)
          || $class->SUPER::initialize($package,
                  'attribute_metaclass' => 'Moose::Meta::Role::Attribute',
                  %opts,
              );
  }
  
  sub reinitialize {
      my $self = shift;
      my $pkg  = shift;
  
      my $meta = blessed $pkg ? $pkg : Class::MOP::class_of($pkg);
  
      my %existing_classes;
      if ($meta) {
          %existing_classes = map { $_ => $meta->$_() } qw(
              attribute_metaclass
              method_metaclass
              wrapped_method_metaclass
              required_method_metaclass
              conflicting_method_metaclass
              application_to_class_class
              application_to_role_class
              application_to_instance_class
              applied_attribute_metaclass
          );
      }
  
      my %options = @_;
      $options{weaken} = Class::MOP::metaclass_is_weak($meta->name)
          if !exists $options{weaken}
          && blessed($meta)
          && $meta->isa('Moose::Meta::Role');
  
      # don't need to remove generated metaobjects here yet, since we don't
      # yet generate anything in roles. this may change in the future though...
      # keep an eye on that
      my $new_meta = $self->SUPER::reinitialize(
          $pkg,
          %existing_classes,
          %options,
      );
      $new_meta->_restore_metaobjects_from($meta)
          if $meta && $meta->isa('Moose::Meta::Role');
      return $new_meta;
  }
  
  sub _restore_metaobjects_from {
      my $self = shift;
      my ($old_meta) = @_;
  
      $self->_restore_metamethods_from($old_meta);
      $self->_restore_metaattributes_from($old_meta);
  
      for my $role ( @{ $old_meta->get_roles } ) {
          $self->add_role($role);
      }
  }
  
  sub add_attribute {
      my $self = shift;
  
      if (blessed $_[0] && ! $_[0]->isa('Moose::Meta::Role::Attribute') ) {
          my $class = ref $_[0];
          Moose->throw_error( "Cannot add a $class as an attribute to a role" );
      }
      elsif (!blessed($_[0]) && defined($_[0]) && $_[0] =~ /^\+(.*)/) {
          Moose->throw_error( "has '+attr' is not supported in roles" );
      }
  
      return $self->SUPER::add_attribute(@_);
  }
  
  sub _attach_attribute {
      my ( $self, $attribute ) = @_;
  
      $attribute->attach_to_role($self);
  }
  
  sub add_required_methods {
      my $self = shift;
  
      for (@_) {
          my $method = $_;
          if (!blessed($method)) {
              $method = $self->required_method_metaclass->new(
                  name => $method,
              );
          }
          $self->get_required_methods_map->{$method->name} = $method;
      }
  }
  
  sub add_conflicting_method {
      my $self = shift;
  
      my $method;
      if (@_ == 1 && blessed($_[0])) {
          $method = shift;
      }
      else {
          $method = $self->conflicting_method_metaclass->new(@_);
      }
  
      $self->add_required_methods($method);
  }
  
  ## ------------------------------------------------------------------
  ## method modifiers
  
  # NOTE:
  # the before/around/after method modifiers are
  # stored by name, but there can be many methods
  # then associated with that name. So again we have
  # lots of similar functionality, so we can do some
  # meta-programmin' and save some time.
  # - SL
  
  foreach my $modifier_type (qw[ before around after ]) {
  
      my $attr_reader = "get_${modifier_type}_method_modifiers_map";
  
      # create the attribute ...
      $META->add_attribute("${modifier_type}_method_modifiers" => (
          reader  => $attr_reader,
          default => sub { {} },
          Class::MOP::_definition_context(),
      ));
  
      # and some helper methods ...
      $META->add_method("get_${modifier_type}_method_modifiers" => sub {
          my ($self, $method_name) = @_;
          #return () unless exists $self->$attr_reader->{$method_name};
          my $mm = $self->$attr_reader->{$method_name};
          $mm ? @$mm : ();
      });
  
      $META->add_method("has_${modifier_type}_method_modifiers" => sub {
          my ($self, $method_name) = @_;
          # NOTE:
          # for now we assume that if it exists,..
          # it has at least one modifier in it
          (exists $self->$attr_reader->{$method_name}) ? 1 : 0;
      });
  
      $META->add_method("add_${modifier_type}_method_modifier" => sub {
          my ($self, $method_name, $method) = @_;
  
          $self->$attr_reader->{$method_name} = []
              unless exists $self->$attr_reader->{$method_name};
  
          my $modifiers = $self->$attr_reader->{$method_name};
  
          # NOTE:
          # check to see that we aren't adding the
          # same code twice. We err in favor of the
          # first on here, this may not be as expected
          foreach my $modifier (@{$modifiers}) {
              return if $modifier == $method;
          }
  
          push @{$modifiers} => $method;
      });
  
  }
  
  ## ------------------------------------------------------------------
  ## override method mofidiers
  
  $META->add_attribute('override_method_modifiers' => (
      reader  => 'get_override_method_modifiers_map',
      default => sub { {} },
      Class::MOP::_definition_context(),
  ));
  
  # NOTE:
  # these are a little different because there
  # can only be one per name, whereas the other
  # method modifiers can have multiples.
  # - SL
  
  sub add_override_method_modifier {
      my ($self, $method_name, $method) = @_;
      (!$self->has_method($method_name))
          || Moose->throw_error("Cannot add an override of method '$method_name' " .
                     "because there is a local version of '$method_name'");
      $self->get_override_method_modifiers_map->{$method_name} = $method;
  }
  
  sub has_override_method_modifier {
      my ($self, $method_name) = @_;
      # NOTE:
      # for now we assume that if it exists,..
      # it has at least one modifier in it
      (exists $self->get_override_method_modifiers_map->{$method_name}) ? 1 : 0;
  }
  
  sub get_override_method_modifier {
      my ($self, $method_name) = @_;
      $self->get_override_method_modifiers_map->{$method_name};
  }
  
  ## general list accessor ...
  
  sub get_method_modifier_list {
      my ($self, $modifier_type) = @_;
      my $accessor = "get_${modifier_type}_method_modifiers_map";
      keys %{$self->$accessor};
  }
  
  sub _meta_method_class { 'Moose::Meta::Method::Meta' }
  
  ## ------------------------------------------------------------------
  ## subroles
  
  $META->add_attribute('roles' => (
      reader  => 'get_roles',
      default => sub { [] },
      Class::MOP::_definition_context(),
  ));
  
  sub add_role {
      my ($self, $role) = @_;
      (blessed($role) && $role->isa('Moose::Meta::Role'))
          || Moose->throw_error("Roles must be instances of Moose::Meta::Role");
      push @{$self->get_roles} => $role;
      $self->reset_package_cache_flag;
  }
  
  sub calculate_all_roles {
      my $self = shift;
      my %seen;
      grep {
          !$seen{$_->name}++
      } ($self, map {
                    $_->calculate_all_roles
                } @{ $self->get_roles });
  }
  
  sub does_role {
      my ($self, $role) = @_;
      (defined $role)
          || Moose->throw_error("You must supply a role name to look for");
      my $role_name = blessed $role ? $role->name : $role;
      # if we are it,.. then return true
      return 1 if $role_name eq $self->name;
      # otherwise.. check our children
      foreach my $role (@{$self->get_roles}) {
          return 1 if $role->does_role($role_name);
      }
      return 0;
  }
  
  sub find_method_by_name { (shift)->get_method(@_) }
  
  ## ------------------------------------------------------------------
  ## role construction
  ## ------------------------------------------------------------------
  
  sub apply {
      my ($self, $other, %args) = @_;
  
      (blessed($other))
          || Moose->throw_error("You must pass in an blessed instance");
  
      my $application_class;
      if ($other->isa('Moose::Meta::Role')) {
          $application_class = $self->application_to_role_class;
      }
      elsif ($other->isa('Moose::Meta::Class')) {
          $application_class = $self->application_to_class_class;
      }
      else {
          $application_class = $self->application_to_instance_class;
      }
  
      load_class($application_class);
  
      if ( exists $args{'-excludes'} ) {
          # I wish we had coercion here :)
          $args{'-excludes'} = (
              ref $args{'-excludes'} eq 'ARRAY'
              ? $args{'-excludes'}
              : [ $args{'-excludes'} ]
          );
      }
  
      return $application_class->new(%args)->apply($self, $other, \%args);
  }
  
  sub composition_class_roles { }
  
  sub combine {
      my ($class, @role_specs) = @_;
  
      require Moose::Meta::Role::Composite;
  
      my (@roles, %role_params);
      while (@role_specs) {
          my ($role, $params) = @{ splice @role_specs, 0, 1 };
          my $requested_role
              = blessed $role
              ? $role
              : Class::MOP::class_of($role);
  
          my $actual_role = $requested_role->_role_for_combination($params);
          push @roles => $actual_role;
  
          next unless defined $params;
          $role_params{$actual_role->name} = $params;
      }
  
      my $c = Moose::Meta::Role::Composite->new(roles => \@roles);
      return $c->apply_params(\%role_params);
  }
  
  sub _role_for_combination {
      my ($self, $params) = @_;
      return $self;
  }
  
  sub create {
      my $class = shift;
      my @args = @_;
  
      unshift @args, 'package' if @args % 2 == 1;
      my %options = @args;
  
      (ref $options{attributes} eq 'HASH')
          || confess "You must pass a HASH ref of attributes"
              if exists $options{attributes};
  
      (ref $options{methods} eq 'HASH')
          || confess "You must pass a HASH ref of methods"
              if exists $options{methods};
  
      (ref $options{roles} eq 'ARRAY')
          || confess "You must pass an ARRAY ref of roles"
              if exists $options{roles};
  
      my $package      = delete $options{package};
      my $roles        = delete $options{roles};
      my $attributes   = delete $options{attributes};
      my $methods      = delete $options{methods};
      my $meta_name    = exists $options{meta_name}
                           ? delete $options{meta_name}
                           : 'meta';
  
      my $meta = $class->SUPER::create($package => %options);
  
      $meta->_add_meta_method($meta_name)
          if defined $meta_name;
  
      if (defined $attributes) {
          foreach my $attribute_name (keys %{$attributes}) {
              my $attr = $attributes->{$attribute_name};
              $meta->add_attribute(
                  $attribute_name => blessed $attr ? $attr : %{$attr} );
          }
      }
  
      if (defined $methods) {
          foreach my $method_name (keys %{$methods}) {
              $meta->add_method($method_name, $methods->{$method_name});
          }
      }
  
      if ($roles) {
          Moose::Util::apply_all_roles($meta, @$roles);
      }
  
      return $meta;
  }
  
  sub consumers {
      my $self = shift;
      my @consumers;
      for my $meta (Class::MOP::get_all_metaclass_instances) {
          next if $meta->name eq $self->name;
          next unless $meta->isa('Moose::Meta::Class')
                   || $meta->isa('Moose::Meta::Role');
          push @consumers, $meta->name
              if $meta->does_role($self->name);
      }
      return @consumers;
  }
  
  # XXX: something more intelligent here?
  sub _anon_package_prefix { 'Moose::Meta::Role::__ANON__::SERIAL::' }
  
  sub create_anon_role { shift->create_anon(@_) }
  sub is_anon_role     { shift->is_anon(@_)     }
  
  sub _anon_cache_key {
      my $class = shift;
      my %options = @_;
  
      # XXX fix this duplication (see MMC::_anon_cache_key
      my $roles = Data::OptList::mkopt(($options{roles} || []), {
          moniker  => 'role',
          val_test => sub { ref($_[0]) eq 'HASH' },
      });
  
      my @role_keys;
      for my $role_spec (@$roles) {
          my ($role, $params) = @$role_spec;
          $params = { %$params };
  
          my $key = blessed($role) ? $role->name : $role;
  
          if ($params && %$params) {
              my $alias    = delete $params->{'-alias'}
                          || delete $params->{'alias'}
                          || {};
              my $excludes = delete $params->{'-excludes'}
                          || delete $params->{'excludes'}
                          || [];
              $excludes = [$excludes] unless ref($excludes) eq 'ARRAY';
  
              if (%$params) {
                  warn "Roles with parameters cannot be cached. Consider "
                     . "applying the parameters before calling "
                     . "create_anon_class, or using 'weaken => 0' instead";
                  return;
              }
  
              my $alias_key = join('%',
                  map { $_ => $alias->{$_} } sort keys %$alias
              );
              my $excludes_key = join('%',
                  sort @$excludes
              );
              $key .= '<' . join('+', 'a', $alias_key, 'e', $excludes_key) . '>';
          }
  
          push @role_keys, $key;
      }
  
      # Makes something like Role|Role::1
      return join('|', sort @role_keys);
  }
  
  #####################################################################
  ## NOTE:
  ## This is Moose::Meta::Role as defined by Moose (plus the use of
  ## MooseX::AttributeHelpers module). It is here as a reference to
  ## make it easier to see what is happening above with all the meta
  ## programming. - SL
  #####################################################################
  #
  # has 'roles' => (
  #     metaclass => 'Array',
  #     reader    => 'get_roles',
  #     isa       => 'ArrayRef[Moose::Meta::Role]',
  #     default   => sub { [] },
  #     provides  => {
  #         'push' => 'add_role',
  #     }
  # );
  #
  # has 'excluded_roles_map' => (
  #     metaclass => 'Hash',
  #     reader    => 'get_excluded_roles_map',
  #     isa       => 'HashRef[Str]',
  #     provides  => {
  #         # Not exactly set, cause it sets multiple
  #         'set'    => 'add_excluded_roles',
  #         'keys'   => 'get_excluded_roles_list',
  #         'exists' => 'excludes_role',
  #     }
  # );
  #
  # has 'required_methods' => (
  #     metaclass => 'Hash',
  #     reader    => 'get_required_methods_map',
  #     isa       => 'HashRef[Moose::Meta::Role::Method::Required]',
  #     provides  => {
  #         # not exactly set, or delete since it works for multiple
  #         'set'    => 'add_required_methods',
  #         'delete' => 'remove_required_methods',
  #         'keys'   => 'get_required_method_list',
  #         'exists' => 'requires_method',
  #     }
  # );
  #
  # # the before, around and after modifiers are
  # # HASH keyed by method-name, with ARRAY of
  # # CODE refs to apply in that order
  #
  # has 'before_method_modifiers' => (
  #     metaclass => 'Hash',
  #     reader    => 'get_before_method_modifiers_map',
  #     isa       => 'HashRef[ArrayRef[CodeRef]]',
  #     provides  => {
  #         'keys'   => 'get_before_method_modifiers',
  #         'exists' => 'has_before_method_modifiers',
  #         # This actually makes sure there is an
  #         # ARRAY at the given key, and pushed onto
  #         # it. It also checks for duplicates as well
  #         # 'add'  => 'add_before_method_modifier'
  #     }
  # );
  #
  # has 'after_method_modifiers' => (
  #     metaclass => 'Hash',
  #     reader    =>'get_after_method_modifiers_map',
  #     isa       => 'HashRef[ArrayRef[CodeRef]]',
  #     provides  => {
  #         'keys'   => 'get_after_method_modifiers',
  #         'exists' => 'has_after_method_modifiers',
  #         # This actually makes sure there is an
  #         # ARRAY at the given key, and pushed onto
  #         # it. It also checks for duplicates as well
  #         # 'add'  => 'add_after_method_modifier'
  #     }
  # );
  #
  # has 'around_method_modifiers' => (
  #     metaclass => 'Hash',
  #     reader    =>'get_around_method_modifiers_map',
  #     isa       => 'HashRef[ArrayRef[CodeRef]]',
  #     provides  => {
  #         'keys'   => 'get_around_method_modifiers',
  #         'exists' => 'has_around_method_modifiers',
  #         # This actually makes sure there is an
  #         # ARRAY at the given key, and pushed onto
  #         # it. It also checks for duplicates as well
  #         # 'add'  => 'add_around_method_modifier'
  #     }
  # );
  #
  # # override is similar to the other modifiers
  # # except that it is not an ARRAY of code refs
  # # but instead just a single name->code mapping
  #
  # has 'override_method_modifiers' => (
  #     metaclass => 'Hash',
  #     reader    =>'get_override_method_modifiers_map',
  #     isa       => 'HashRef[CodeRef]',
  #     provides  => {
  #         'keys'   => 'get_override_method_modifier',
  #         'exists' => 'has_override_method_modifier',
  #         'add'    => 'add_override_method_modifier', # checks for local method ..
  #     }
  # );
  #
  #####################################################################
  
  
  1;
  
  # ABSTRACT: The Moose Role metaclass
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::Role - The Moose Role metaclass
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This class is a subclass of L<Class::MOP::Module> that provides
  additional Moose-specific functionality.
  
  Its API looks a lot like L<Moose::Meta::Class>, but internally it
  implements many things differently. This may change in the future.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Role> is a subclass of L<Class::MOP::Module>.
  
  =head1 METHODS
  
  =head2 Construction
  
  =over 4
  
  =item B<< Moose::Meta::Role->initialize($role_name) >>
  
  This method creates a new role object with the provided name.
  
  =item B<< Moose::Meta::Role->combine( [ $role => { ... } ], [ $role ], ... ) >>
  
  This method accepts a list of array references. Each array reference
  should contain a role name or L<Moose::Meta::Role> object as its first element. The second element is
  an optional hash reference. The hash reference can contain C<-excludes>
  and C<-alias> keys to control how methods are composed from the role.
  
  The return value is a new L<Moose::Meta::Role::Composite> that
  represents the combined roles.
  
  =item B<< $metarole->composition_class_roles >>
  
  When combining multiple roles using C<combine>, this method is used to obtain a
  list of role names to be applied to the L<Moose::Meta::Role::Composite>
  instance returned by C<combine>. The default implementation returns an empty
  list. Extensions that need to hook into role combination may wrap this method
  to return additional role names.
  
  =item B<< Moose::Meta::Role->create($name, %options) >>
  
  This method is identical to the L<Moose::Meta::Class> C<create>
  method.
  
  =item B<< Moose::Meta::Role->create_anon_role >>
  
  This method is identical to the L<Moose::Meta::Class>
  C<create_anon_class> method.
  
  =item B<< $metarole->is_anon_role >>
  
  Returns true if the role is an anonymous role.
  
  =item B<< $metarole->consumers >>
  
  Returns a list of names of classes and roles which consume this role.
  
  =back
  
  =head2 Role application
  
  =over 4
  
  =item B<< $metarole->apply( $thing, @options ) >>
  
  This method applies a role to the given C<$thing>. That can be another
  L<Moose::Meta::Role>, object, a L<Moose::Meta::Class> object, or a
  (non-meta) object instance.
  
  The options are passed directly to the constructor for the appropriate
  L<Moose::Meta::Role::Application> subclass.
  
  Note that this will apply the role even if the C<$thing> in question already
  C<does> this role.  L<Moose::Util/does_role> is a convenient wrapper for
  finding out if role application is necessary.
  
  =back
  
  =head2 Roles and other roles
  
  =over 4
  
  =item B<< $metarole->get_roles >>
  
  This returns an array reference of roles which this role does. This
  list may include duplicates.
  
  =item B<< $metarole->calculate_all_roles >>
  
  This returns a I<unique> list of all roles that this role does, and
  all the roles that its roles do.
  
  =item B<< $metarole->does_role($role) >>
  
  Given a role I<name> or L<Moose::Meta::Role> object, returns true if this role
  does the given role.
  
  =item B<< $metarole->add_role($role) >>
  
  Given a L<Moose::Meta::Role> object, this adds the role to the list of
  roles that the role does.
  
  =item B<< $metarole->get_excluded_roles_list >>
  
  Returns a list of role names which this role excludes.
  
  =item B<< $metarole->excludes_role($role_name) >>
  
  Given a role I<name>, returns true if this role excludes the named
  role.
  
  =item B<< $metarole->add_excluded_roles(@role_names) >>
  
  Given one or more role names, adds those roles to the list of excluded
  roles.
  
  =back
  
  =head2 Methods
  
  The methods for dealing with a role's methods are all identical in API
  and behavior to the same methods in L<Class::MOP::Class>.
  
  =over 4
  
  =item B<< $metarole->method_metaclass >>
  
  Returns the method metaclass name for the role. This defaults to
  L<Moose::Meta::Role::Method>.
  
  =item B<< $metarole->get_method($name) >>
  
  =item B<< $metarole->has_method($name) >>
  
  =item B<< $metarole->add_method( $name, $body ) >>
  
  =item B<< $metarole->get_method_list >>
  
  =item B<< $metarole->find_method_by_name($name) >>
  
  These methods are all identical to the methods of the same name in
  L<Class::MOP::Package>
  
  =back
  
  =head2 Attributes
  
  As with methods, the methods for dealing with a role's attribute are
  all identical in API and behavior to the same methods in
  L<Class::MOP::Class>.
  
  However, attributes stored in this class are I<not> stored as
  objects. Rather, the attribute definition is stored as a hash
  reference. When a role is composed into a class, this hash reference
  is passed directly to the metaclass's C<add_attribute> method.
  
  This is quite likely to change in the future.
  
  =over 4
  
  =item B<< $metarole->get_attribute($attribute_name) >>
  
  =item B<< $metarole->has_attribute($attribute_name) >>
  
  =item B<< $metarole->get_attribute_list >>
  
  =item B<< $metarole->add_attribute($name, %options) >>
  
  =item B<< $metarole->remove_attribute($attribute_name) >>
  
  =back
  
  =head2 Required methods
  
  =over 4
  
  =item B<< $metarole->get_required_method_list >>
  
  Returns the list of methods required by the role.
  
  =item B<< $metarole->requires_method($name) >>
  
  Returns true if the role requires the named method.
  
  =item B<< $metarole->add_required_methods(@names) >>
  
  Adds the named methods to the role's list of required methods.
  
  =item B<< $metarole->remove_required_methods(@names) >>
  
  Removes the named methods from the role's list of required methods.
  
  =item B<< $metarole->add_conflicting_method(%params) >>
  
  Instantiate the parameters as a L<Moose::Meta::Role::Method::Conflicting>
  object, then add it to the required method list.
  
  =back
  
  =head2 Method modifiers
  
  These methods act like their counterparts in L<Class::MOP::Class> and
  L<Moose::Meta::Class>.
  
  However, method modifiers are simply stored internally, and are not
  applied until the role itself is applied to a class.
  
  =over 4
  
  =item B<< $metarole->add_after_method_modifier($method_name, $method) >>
  
  =item B<< $metarole->add_around_method_modifier($method_name, $method) >>
  
  =item B<< $metarole->add_before_method_modifier($method_name, $method) >>
  
  =item B<< $metarole->add_override_method_modifier($method_name, $method) >>
  
  These methods all add an appropriate modifier to the internal list of
  modifiers.
  
  =item B<< $metarole->has_after_method_modifiers >>
  
  =item B<< $metarole->has_around_method_modifiers >>
  
  =item B<< $metarole->has_before_method_modifiers >>
  
  =item B<< $metarole->has_override_method_modifier >>
  
  Return true if the role has any modifiers of the given type.
  
  =item B<< $metarole->get_after_method_modifiers($method_name) >>
  
  =item B<< $metarole->get_around_method_modifiers($method_name) >>
  
  =item B<< $metarole->get_before_method_modifiers($method_name) >>
  
  Given a method name, returns a list of the appropriate modifiers for
  that method.
  
  =item B<< $metarole->get_override_method_modifier($method_name) >>
  
  Given a method name, returns the override method modifier for that
  method, if it has one.
  
  =back
  
  =head2 Introspection
  
  =over 4
  
  =item B<< Moose::Meta::Role->meta >>
  
  This will return a L<Class::MOP::Class> instance for this class.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_META_ROLE

$fatpacked{"i686-linux/Moose/Meta/Role/Application.pm"} = <<'I686-LINUX_MOOSE_META_ROLE_APPLICATION';
  package Moose::Meta::Role::Application;
  BEGIN {
    $Moose::Meta::Role::Application::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Role::Application::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  use metaclass;
  
  __PACKAGE__->meta->add_attribute('method_exclusions' => (
      init_arg => '-excludes',
      reader   => 'get_method_exclusions',
      default  => sub { [] },
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('method_aliases' => (
      init_arg => '-alias',
      reader   => 'get_method_aliases',
      default  => sub { {} },
      Class::MOP::_definition_context(),
  ));
  
  sub new {
      my ($class, %params) = @_;
      $class->_new(\%params);
  }
  
  sub is_method_excluded {
      my ($self, $method_name) = @_;
      foreach (@{$self->get_method_exclusions}) {
          return 1 if $_ eq $method_name;
      }
      return 0;
  }
  
  sub is_method_aliased {
      my ($self, $method_name) = @_;
      exists $self->get_method_aliases->{$method_name} ? 1 : 0
  }
  
  sub is_aliased_method {
      my ($self, $method_name) = @_;
      my %aliased_names = reverse %{$self->get_method_aliases};
      exists $aliased_names{$method_name} ? 1 : 0;
  }
  
  sub apply {
      my $self = shift;
  
      $self->check_role_exclusions(@_);
      $self->check_required_methods(@_);
      $self->check_required_attributes(@_);
  
      $self->apply_attributes(@_);
      $self->apply_methods(@_);
  
      $self->apply_override_method_modifiers(@_);
  
      $self->apply_before_method_modifiers(@_);
      $self->apply_around_method_modifiers(@_);
      $self->apply_after_method_modifiers(@_);
  }
  
  sub check_role_exclusions           { Carp::croak "Abstract Method" }
  sub check_required_methods          { Carp::croak "Abstract Method" }
  sub check_required_attributes       { Carp::croak "Abstract Method" }
  
  sub apply_attributes                { Carp::croak "Abstract Method" }
  sub apply_methods                   { Carp::croak "Abstract Method" }
  sub apply_override_method_modifiers { Carp::croak "Abstract Method" }
  sub apply_method_modifiers          { Carp::croak "Abstract Method" }
  
  sub apply_before_method_modifiers   { (shift)->apply_method_modifiers('before' => @_) }
  sub apply_around_method_modifiers   { (shift)->apply_method_modifiers('around' => @_) }
  sub apply_after_method_modifiers    { (shift)->apply_method_modifiers('after'  => @_) }
  
  1;
  
  # ABSTRACT: A base class for role application
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::Role::Application - A base class for role application
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This is the abstract base class for role applications.
  
  The API for this class and its subclasses still needs some
  consideration, and is intentionally not yet documented.
  
  =head2 METHODS
  
  =over 4
  
  =item B<new>
  
  =item B<meta>
  
  =item B<get_method_exclusions>
  
  =item B<is_method_excluded>
  
  =item B<get_method_aliases>
  
  =item B<is_aliased_method>
  
  =item B<is_method_aliased>
  
  =item B<apply>
  
  =item B<check_role_exclusions>
  
  =item B<check_required_methods>
  
  =item B<check_required_attributes>
  
  =item B<apply_attributes>
  
  =item B<apply_methods>
  
  =item B<apply_method_modifiers>
  
  =item B<apply_before_method_modifiers>
  
  =item B<apply_after_method_modifiers>
  
  =item B<apply_around_method_modifiers>
  
  =item B<apply_override_method_modifiers>
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
  
I686-LINUX_MOOSE_META_ROLE_APPLICATION

$fatpacked{"i686-linux/Moose/Meta/Role/Application/RoleSummation.pm"} = <<'I686-LINUX_MOOSE_META_ROLE_APPLICATION_ROLESUMMATION';
  package Moose::Meta::Role::Application::RoleSummation;
  BEGIN {
    $Moose::Meta::Role::Application::RoleSummation::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Role::Application::RoleSummation::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  use metaclass;
  
  use Scalar::Util 'blessed';
  
  use Moose::Meta::Role::Composite;
  
  use base 'Moose::Meta::Role::Application';
  
  __PACKAGE__->meta->add_attribute('role_params' => (
      reader  => 'role_params',
      default => sub { {} },
      Class::MOP::_definition_context(),
  ));
  
  sub get_exclusions_for_role {
      my ($self, $role) = @_;
      $role = $role->name if blessed $role;
      my $excludes_key = exists $self->role_params->{$role}->{'-excludes'} ?
                             '-excludes' : 'excludes';
      if ($self->role_params->{$role} && defined $self->role_params->{$role}->{$excludes_key}) {
          if (ref $self->role_params->{$role}->{$excludes_key} eq 'ARRAY') {
              return $self->role_params->{$role}->{$excludes_key};
          }
          return [ $self->role_params->{$role}->{$excludes_key} ];
      }
      return [];
  }
  
  sub get_method_aliases_for_role {
      my ($self, $role) = @_;
      $role = $role->name if blessed $role;
      my $alias_key = exists $self->role_params->{$role}->{'-alias'} ?
                          '-alias' : 'alias';
      if ($self->role_params->{$role} && defined $self->role_params->{$role}->{$alias_key}) {
          return $self->role_params->{$role}->{$alias_key};
      }
      return {};
  }
  
  sub is_method_excluded {
      my ($self, $role, $method_name) = @_;
      foreach ($self->get_exclusions_for_role($role->name)) {
          return 1 if $_ eq $method_name;
      }
      return 0;
  }
  
  sub is_method_aliased {
      my ($self, $role, $method_name) = @_;
      exists $self->get_method_aliases_for_role($role->name)->{$method_name} ? 1 : 0
  }
  
  sub is_aliased_method {
      my ($self, $role, $method_name) = @_;
      my %aliased_names = reverse %{$self->get_method_aliases_for_role($role->name)};
      exists $aliased_names{$method_name} ? 1 : 0;
  }
  
  sub check_role_exclusions {
      my ($self, $c) = @_;
  
      my %excluded_roles;
      for my $role (@{ $c->get_roles }) {
          my $name = $role->name;
  
          for my $excluded ($role->get_excluded_roles_list) {
              push @{ $excluded_roles{$excluded} }, $name;
          }
      }
  
      foreach my $role (@{$c->get_roles}) {
          foreach my $excluded (keys %excluded_roles) {
              next unless $role->does_role($excluded);
  
              my @excluding = @{ $excluded_roles{$excluded} };
  
              require Moose;
              Moose->throw_error(sprintf "Conflict detected: Role%s %s exclude%s role '%s'", (@excluding == 1 ? '' : 's'), join(', ', @excluding), (@excluding == 1 ? 's' : ''), $excluded);
          }
      }
  
      $c->add_excluded_roles(keys %excluded_roles);
  }
  
  sub check_required_methods {
      my ($self, $c) = @_;
  
      my %all_required_methods =
          map { $_->name => $_ }
          map { $_->get_required_method_list }
          @{$c->get_roles};
  
      foreach my $role (@{$c->get_roles}) {
          foreach my $required (keys %all_required_methods) {
  
              delete $all_required_methods{$required}
                  if $role->has_method($required)
                  || $self->is_aliased_method($role, $required);
          }
      }
  
      $c->add_required_methods(values %all_required_methods);
  }
  
  sub check_required_attributes {
  
  }
  
  sub apply_attributes {
      my ($self, $c) = @_;
  
      my @all_attributes;
  
      for my $role ( @{ $c->get_roles } ) {
          push @all_attributes,
              map { $role->get_attribute($_) } $role->get_attribute_list;
      }
  
      my %seen;
      foreach my $attr (@all_attributes) {
          my $name = $attr->name;
  
          if ( exists $seen{$name} ) {
              next if $seen{$name}->is_same_as($attr);
  
              my $role1 = $seen{$name}->associated_role->name;
              my $role2 = $attr->associated_role->name;
  
              require Moose;
              Moose->throw_error(
                  "We have encountered an attribute conflict with '$name' "
                      . "during role composition. "
                      . " This attribute is defined in both $role1 and $role2."
                      . " This is a fatal error and cannot be disambiguated." );
          }
  
          $seen{$name} = $attr;
      }
  
      foreach my $attr (@all_attributes) {
          $c->add_attribute( $attr->clone );
      }
  }
  
  sub apply_methods {
      my ($self, $c) = @_;
  
      my @all_methods = map {
          my $role     = $_;
          my $aliases  = $self->get_method_aliases_for_role($role);
          my %excludes = map { $_ => undef } @{ $self->get_exclusions_for_role($role) };
          (
              (map {
                  exists $excludes{$_} ? () :
                  +{
                      role   => $role,
                      name   => $_,
                      method => $role->get_method($_),
                  }
              } map { $_->name }
                grep { !$_->isa('Class::MOP::Method::Meta') }
                     $role->_get_local_methods),
              (map {
                  +{
                      role   => $role,
                      name   => $aliases->{$_},
                      method => $role->get_method($_),
                  }
              } keys %$aliases)
          );
      } @{$c->get_roles};
  
      my (%seen, %method_map);
      foreach my $method (@all_methods) {
          my $seen = $seen{$method->{name}};
  
          if ($seen) {
              if ($seen->{method}->body != $method->{method}->body) {
                  $c->add_conflicting_method(
                      name  => $method->{name},
                      roles => [$method->{role}->name, $seen->{role}->name],
                  );
  
                  delete $method_map{$method->{name}};
                  next;
              }
          }
  
          $seen{$method->{name}}       = $method;
          $method_map{$method->{name}} = $method->{method};
      }
  
      $c->add_method($_ => $method_map{$_}) for keys %method_map;
  }
  
  sub apply_override_method_modifiers {
      my ($self, $c) = @_;
  
      my @all_overrides = map {
          my $role = $_;
          map {
              +{
                  name   => $_,
                  method => $role->get_override_method_modifier($_),
              }
          } $role->get_method_modifier_list('override');
      } @{$c->get_roles};
  
      my %seen;
      foreach my $override (@all_overrides) {
          if ( $c->has_method($override->{name}) ){
              require Moose;
              Moose->throw_error( "Role '" . $c->name . "' has encountered an 'override' method conflict " .
                                  "during composition (A local method of the same name as been found). This " .
                                  "is fatal error." )
          }
          if (exists $seen{$override->{name}}) {
              if ( $seen{$override->{name}} != $override->{method} ) {
                  require Moose;
                  Moose->throw_error( "We have encountered an 'override' method conflict during " .
                                      "composition (Two 'override' methods of the same name encountered). " .
                                      "This is fatal error.")
              }
          }
          $seen{$override->{name}} = $override->{method};
      }
  
      $c->add_override_method_modifier(
          $_->{name}, $_->{method}
      ) for @all_overrides;
  
  }
  
  sub apply_method_modifiers {
      my ($self, $modifier_type, $c) = @_;
      my $add = "add_${modifier_type}_method_modifier";
      my $get = "get_${modifier_type}_method_modifiers";
      foreach my $role (@{$c->get_roles}) {
          foreach my $method_name ($role->get_method_modifier_list($modifier_type)) {
              $c->$add(
                  $method_name,
                  $_
              ) foreach $role->$get($method_name);
          }
      }
  }
  
  1;
  
  # ABSTRACT: Combine two or more roles
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::Role::Application::RoleSummation - Combine two or more roles
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  Summation composes two traits, forming the union of non-conflicting
  bindings and 'disabling' the conflicting bindings
  
  =head2 METHODS
  
  =over 4
  
  =item B<new>
  
  =item B<meta>
  
  =item B<role_params>
  
  =item B<get_exclusions_for_role>
  
  =item B<get_method_aliases_for_role>
  
  =item B<is_aliased_method>
  
  =item B<is_method_aliased>
  
  =item B<is_method_excluded>
  
  =item B<apply>
  
  =item B<check_role_exclusions>
  
  =item B<check_required_methods>
  
  =item B<check_required_attributes>
  
  =item B<apply_attributes>
  
  =item B<apply_methods>
  
  =item B<apply_method_modifiers>
  
  =item B<apply_override_method_modifiers>
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
  
I686-LINUX_MOOSE_META_ROLE_APPLICATION_ROLESUMMATION

$fatpacked{"i686-linux/Moose/Meta/Role/Application/ToClass.pm"} = <<'I686-LINUX_MOOSE_META_ROLE_APPLICATION_TOCLASS';
  package Moose::Meta::Role::Application::ToClass;
  BEGIN {
    $Moose::Meta::Role::Application::ToClass::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Role::Application::ToClass::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  use metaclass;
  
  use List::MoreUtils 'firstval';
  use Moose::Util  'english_list';
  use Scalar::Util 'weaken', 'blessed';
  
  use base 'Moose::Meta::Role::Application';
  
  __PACKAGE__->meta->add_attribute('role' => (
      reader => 'role',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('class' => (
      accessor => 'class',
      Class::MOP::_definition_context(),
  ));
  
  sub apply {
      my ($self, $role, $class) = @_;
  
      # We need weak_ref in CMOP :(
      weaken($self->{role}  = $role);
      weaken($self->{class} = $class);
  
      $self->SUPER::apply($role, $class);
  
      $class->add_role($role);
      $class->add_role_application($self);
  }
  
  sub check_role_exclusions {
      my ($self, $role, $class) = @_;
      if ($class->excludes_role($role->name)) {
          $class->throw_error("Conflict detected: " . $class->name . " excludes role '" . $role->name . "'");
      }
      foreach my $excluded_role_name ($role->get_excluded_roles_list) {
          if ($class->does_role($excluded_role_name)) {
              $class->throw_error("The class " . $class->name . " does the excluded role '$excluded_role_name'");
          }
      }
  }
  
  sub check_required_methods {
      my ($self, $role, $class) = @_;
  
      my @missing;
      my @is_attr;
  
      # NOTE:
      # we might need to move this down below the
      # the attributes so that we can require any
      # attribute accessors. However I am thinking
      # that maybe those are somehow exempt from
      # the require methods stuff.
      foreach my $required_method ($role->get_required_method_list) {
          my $required_method_name = $required_method->name;
  
          if (!$class->find_method_by_name($required_method_name)) {
  
              next if $self->is_aliased_method($required_method_name);
  
              push @missing, $required_method;
          }
      }
  
      return unless @missing;
  
      my $error = '';
  
      @missing = sort { $a->name cmp $b->name } @missing;
      my @conflicts = grep { $_->isa('Moose::Meta::Role::Method::Conflicting') } @missing;
  
      if (@conflicts) {
          my $conflict = $conflicts[0];
          my $roles = $conflict->roles_as_english_list;
  
          my @same_role_conflicts = grep { $_->roles_as_english_list eq $roles } @conflicts;
  
          if (@same_role_conflicts == 1) {
              $error
                  .= "Due to a method name conflict in roles "
                  .  $roles
                  . ", the method '"
                  . $conflict->name
                  . "' must be implemented or excluded by '"
                  . $class->name
                  . q{'};
          }
          else {
              my $methods
                  = Moose::Util::english_list( map { q{'} . $_->name . q{'} } @same_role_conflicts );
  
              $error
                  .= "Due to method name conflicts in roles "
                  .  $roles
                  . ", the methods "
                  . $methods
                  . " must be implemented or excluded by '"
                  . $class->name
                  . q{'};
          }
      }
      elsif (@missing) {
          my $noun = @missing == 1 ? 'method' : 'methods';
  
          my $list
              = Moose::Util::english_list( map { q{'} . $_ . q{'} } @missing );
  
          $error
              .= q{'}
              . $role->name
              . "' requires the $noun $list "
              . "to be implemented by '"
              . $class->name . q{'};
  
          if (my $meth = firstval { $class->name->can($_) } @missing) {
              $error .= ". If you imported functions intending to use them as "
                      . "methods, you need to explicitly mark them as such, via "
                      . $class->name . "->meta->add_method($meth => \\\&$meth)";
          }
      }
  
      $class->throw_error($error);
  }
  
  sub check_required_attributes {
  
  }
  
  sub apply_attributes {
      my ($self, $role, $class) = @_;
  
      foreach my $attribute_name ($role->get_attribute_list) {
          # it if it has one already
          if ($class->has_attribute($attribute_name) &&
              # make sure we haven't seen this one already too
              $class->get_attribute($attribute_name) != $role->get_attribute($attribute_name)) {
              next;
          }
          else {
              $class->add_attribute(
                  $role->get_attribute($attribute_name)->attribute_for_class
              );
          }
      }
  }
  
  sub apply_methods {
      my ( $self, $role, $class ) = @_;
  
      foreach my $method ( $role->_get_local_methods ) {
          my $method_name = $method->name;
  
          next if $method->isa('Class::MOP::Method::Meta');
  
          unless ( $self->is_method_excluded($method_name) ) {
  
              my $class_method = $class->get_method($method_name);
  
              next if $class_method && $class_method->body != $method->body;
  
              $class->add_method(
                  $method_name,
                  $method,
              );
          }
  
          next unless $self->is_method_aliased($method_name);
  
          my $aliased_method_name = $self->get_method_aliases->{$method_name};
  
          my $class_method = $class->get_method($aliased_method_name);
  
          if ( $class_method && $class_method->body != $method->body ) {
              $class->throw_error(
                  "Cannot create a method alias if a local method of the same name exists"
              );
          }
  
          $class->add_method(
              $aliased_method_name,
              $method,
          );
      }
  
      # we must reset the cache here since
      # we are just aliasing methods, otherwise
      # the modifiers go wonky.
      $class->reset_package_cache_flag;
  }
  
  sub apply_override_method_modifiers {
      my ($self, $role, $class) = @_;
      foreach my $method_name ($role->get_method_modifier_list('override')) {
          # it if it has one already then ...
          if ($class->has_method($method_name)) {
              next;
          }
          else {
              # if this is not a role, then we need to
              # find the original package of the method
              # so that we can tell the class were to
              # find the right super() method
              my $method = $role->get_override_method_modifier($method_name);
              my ($package) = Class::MOP::get_code_info($method);
              # if it is a class, we just add it
              $class->add_override_method_modifier($method_name, $method, $package);
          }
      }
  }
  
  sub apply_method_modifiers {
      my ($self, $modifier_type, $role, $class) = @_;
      my $add = "add_${modifier_type}_method_modifier";
      my $get = "get_${modifier_type}_method_modifiers";
      foreach my $method_name ($role->get_method_modifier_list($modifier_type)) {
          $class->$add(
              $method_name,
              $_
          ) foreach $role->$get($method_name);
      }
  }
  
  1;
  
  # ABSTRACT: Compose a role into a class
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::Role::Application::ToClass - Compose a role into a class
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  =head2 METHODS
  
  =over 4
  
  =item B<new>
  
  =item B<meta>
  
  =item B<apply>
  
  =item B<check_role_exclusions>
  
  =item B<check_required_methods>
  
  =item B<check_required_attributes>
  
  =item B<apply_attributes>
  
  =item B<apply_methods>
  
  =item B<apply_method_modifiers>
  
  =item B<apply_override_method_modifiers>
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
  
I686-LINUX_MOOSE_META_ROLE_APPLICATION_TOCLASS

$fatpacked{"i686-linux/Moose/Meta/Role/Application/ToInstance.pm"} = <<'I686-LINUX_MOOSE_META_ROLE_APPLICATION_TOINSTANCE';
  package Moose::Meta::Role::Application::ToInstance;
  BEGIN {
    $Moose::Meta::Role::Application::ToInstance::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Role::Application::ToInstance::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  use metaclass;
  
  use Scalar::Util 'blessed';
  use List::MoreUtils 'all';
  
  use base 'Moose::Meta::Role::Application';
  
  __PACKAGE__->meta->add_attribute('rebless_params' => (
      reader  => 'rebless_params',
      default => sub { {} },
      Class::MOP::_definition_context(),
  ));
  
  sub apply {
      my ( $self, $role, $object, $args ) = @_;
  
      my $obj_meta = Class::MOP::class_of($object) || 'Moose::Meta::Class';
  
      # This is a special case to handle the case where the object's metaclass
      # is a Class::MOP::Class, but _not_ a Moose::Meta::Class (for example,
      # when applying a role to a Moose::Meta::Attribute object).
      $obj_meta = 'Moose::Meta::Class'
          unless $obj_meta->isa('Moose::Meta::Class');
  
      my $class = $obj_meta->create_anon_class(
          superclasses => [ blessed($object) ],
          roles => [ $role, keys(%$args) ? ($args) : () ],
          cache => (all { $_ eq '-alias' || $_ eq '-excludes' } keys %$args),
      );
  
      $class->rebless_instance( $object, %{ $self->rebless_params } );
  }
  
  1;
  
  # ABSTRACT: Compose a role into an instance
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::Role::Application::ToInstance - Compose a role into an instance
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  =head2 METHODS
  
  =over 4
  
  =item B<new>
  
  =item B<meta>
  
  =item B<apply>
  
  =item B<rebless_params>
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
  
I686-LINUX_MOOSE_META_ROLE_APPLICATION_TOINSTANCE

$fatpacked{"i686-linux/Moose/Meta/Role/Application/ToRole.pm"} = <<'I686-LINUX_MOOSE_META_ROLE_APPLICATION_TOROLE';
  package Moose::Meta::Role::Application::ToRole;
  BEGIN {
    $Moose::Meta::Role::Application::ToRole::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Role::Application::ToRole::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  use metaclass;
  
  use Scalar::Util    'blessed';
  
  use base 'Moose::Meta::Role::Application';
  
  sub apply {
      my ($self, $role1, $role2) = @_;
      $self->SUPER::apply($role1, $role2);
      $role2->add_role($role1);
  }
  
  sub check_role_exclusions {
      my ($self, $role1, $role2) = @_;
      if ( $role2->excludes_role($role1->name) ) {
          require Moose;
          Moose->throw_error("Conflict detected: " . $role2->name . " excludes role '" . $role1->name . "'");
      }
      foreach my $excluded_role_name ($role1->get_excluded_roles_list) {
          if ( $role2->does_role($excluded_role_name) ) {
              require Moose;
              Moose->throw_error("The class " . $role2->name . " does the excluded role '$excluded_role_name'");
          }
          $role2->add_excluded_roles($excluded_role_name);
      }
  }
  
  sub check_required_methods {
      my ($self, $role1, $role2) = @_;
      foreach my $required_method ($role1->get_required_method_list) {
          my $required_method_name = $required_method->name;
  
          next if $self->is_aliased_method($required_method_name);
  
          $role2->add_required_methods($required_method)
              unless $role2->find_method_by_name($required_method_name);
      }
  }
  
  sub check_required_attributes {
  
  }
  
  sub apply_attributes {
      my ($self, $role1, $role2) = @_;
      foreach my $attribute_name ($role1->get_attribute_list) {
          # it if it has one already
          if ($role2->has_attribute($attribute_name) &&
              # make sure we haven't seen this one already too
              $role2->get_attribute($attribute_name) != $role1->get_attribute($attribute_name)) {
  
              my $role2_name = $role2->name;
  
              require Moose;
              Moose->throw_error( "Role '"
                      . $role1->name
                      . "' has encountered an attribute conflict"
                      . " while being composed into '$role2_name'."
                      . " This is a fatal error and cannot be disambiguated."
                      . " The conflicting attribute is named '$attribute_name'." );
          }
          else {
              $role2->add_attribute(
                  $role1->get_attribute($attribute_name)->clone
              );
          }
      }
  }
  
  sub apply_methods {
      my ( $self, $role1, $role2 ) = @_;
      foreach my $method ( $role1->_get_local_methods ) {
  
          my $method_name = $method->name;
  
          next if $method->isa('Class::MOP::Method::Meta');
  
          unless ( $self->is_method_excluded($method_name) ) {
  
              my $role2_method = $role2->get_method($method_name);
              if (   $role2_method
                  && $role2_method->body != $method->body ) {
  
                  # method conflicts between roles result in the method becoming
                  # a requirement
                  $role2->add_conflicting_method(
                      name  => $method_name,
                      roles => [ $role1->name, $role2->name ],
                  );
              }
              else {
                  $role2->add_method(
                      $method_name,
                      $method,
                  );
              }
          }
  
          next unless $self->is_method_aliased($method_name);
  
          my $aliased_method_name = $self->get_method_aliases->{$method_name};
  
          my $role2_method = $role2->get_method($aliased_method_name);
  
          if (   $role2_method
              && $role2_method->body != $method->body ) {
  
              require Moose;
              Moose->throw_error(
                  "Cannot create a method alias if a local method of the same name exists"
              );
          }
  
          $role2->add_method(
              $aliased_method_name,
              $role1->get_method($method_name)
          );
  
          if ( !$role2->has_method($method_name) ) {
              $role2->add_required_methods($method_name)
                  unless $self->is_method_excluded($method_name);
          }
      }
  }
  
  sub apply_override_method_modifiers {
      my ($self, $role1, $role2) = @_;
      foreach my $method_name ($role1->get_method_modifier_list('override')) {
          # it if it has one already then ...
          if ($role2->has_method($method_name)) {
              # if it is being composed into another role
              # we have a conflict here, because you cannot
              # combine an overridden method with a locally
              # defined one
              require Moose;
              Moose->throw_error("Role '" . $role1->name . "' has encountered an 'override' method conflict " .
                      "during composition (A local method of the same name as been found). This " .
                      "is fatal error.");
          }
          else {
              # if we are a role, we need to make sure
              # we dont have a conflict with the role
              # we are composing into
              if ($role2->has_override_method_modifier($method_name) &&
                  $role2->get_override_method_modifier($method_name) != $role2->get_override_method_modifier($method_name)) {
  
                  require Moose;
                  Moose->throw_error("Role '" . $role1->name . "' has encountered an 'override' method conflict " .
                          "during composition (Two 'override' methods of the same name encountered). " .
                          "This is fatal error.");
              }
              else {
                  # if there is no conflict,
                  # just add it to the role
                  $role2->add_override_method_modifier(
                      $method_name,
                      $role1->get_override_method_modifier($method_name)
                  );
              }
          }
      }
  }
  
  sub apply_method_modifiers {
      my ($self, $modifier_type, $role1, $role2) = @_;
      my $add = "add_${modifier_type}_method_modifier";
      my $get = "get_${modifier_type}_method_modifiers";
      foreach my $method_name ($role1->get_method_modifier_list($modifier_type)) {
          $role2->$add(
              $method_name,
              $_
          ) foreach $role1->$get($method_name);
      }
  }
  
  
  1;
  
  # ABSTRACT: Compose a role into another role
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::Role::Application::ToRole - Compose a role into another role
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  =head2 METHODS
  
  =over 4
  
  =item B<new>
  
  =item B<meta>
  
  =item B<apply>
  
  =item B<check_role_exclusions>
  
  =item B<check_required_methods>
  
  =item B<check_required_attributes>
  
  =item B<apply_attributes>
  
  =item B<apply_methods>
  
  =item B<apply_method_modifiers>
  
  =item B<apply_override_method_modifiers>
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
  
I686-LINUX_MOOSE_META_ROLE_APPLICATION_TOROLE

$fatpacked{"i686-linux/Moose/Meta/Role/Attribute.pm"} = <<'I686-LINUX_MOOSE_META_ROLE_ATTRIBUTE';
  package Moose::Meta::Role::Attribute;
  BEGIN {
    $Moose::Meta::Role::Attribute::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Role::Attribute::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Carp 'confess';
  use List::MoreUtils 'all';
  use Scalar::Util 'blessed', 'weaken';
  
  use base 'Moose::Meta::Mixin::AttributeCore', 'Class::MOP::Object';
  
  __PACKAGE__->meta->add_attribute(
      'metaclass' => (
          reader => 'metaclass',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'associated_role' => (
          reader => 'associated_role',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      '_original_role' => (
          reader => '_original_role',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'is' => (
          reader => 'is',
          Class::MOP::_definition_context(),
      )
  );
  
  __PACKAGE__->meta->add_attribute(
      'original_options' => (
          reader => 'original_options',
          Class::MOP::_definition_context(),
      )
  );
  
  sub new {
      my ( $class, $name, %options ) = @_;
  
      (defined $name)
          || confess "You must provide a name for the attribute";
  
      my $role = delete $options{_original_role};
  
      return bless {
          name             => $name,
          original_options => \%options,
          _original_role   => $role,
          %options,
      }, $class;
  }
  
  sub attach_to_role {
      my ( $self, $role ) = @_;
  
      ( blessed($role) && $role->isa('Moose::Meta::Role') )
          || confess
          "You must pass a Moose::Meta::Role instance (or a subclass)";
  
      weaken( $self->{'associated_role'} = $role );
  }
  
  sub original_role {
      my $self = shift;
  
      return $self->_original_role || $self->associated_role;
  }
  
  sub attribute_for_class {
      my $self = shift;
  
      my $metaclass = $self->original_role->applied_attribute_metaclass;
  
      return $metaclass->interpolate_class_and_new(
          $self->name => %{ $self->original_options } );
  }
  
  sub clone {
      my $self = shift;
  
      my $role = $self->original_role;
  
      return ( ref $self )->new(
          $self->name,
          %{ $self->original_options },
          _original_role => $role,
      );
  }
  
  sub is_same_as {
      my $self = shift;
      my $attr = shift;
  
      my $self_options = $self->original_options;
      my $other_options = $attr->original_options;
  
      return 0
          unless ( join q{|}, sort keys %{$self_options} ) eq ( join q{|}, sort keys %{$other_options} );
  
      for my $key ( keys %{$self_options} ) {
          return 0 if defined $self_options->{$key} && ! defined $other_options->{$key};
          return 0 if ! defined $self_options->{$key} && defined $other_options->{$key};
  
          next if all { ! defined } $self_options->{$key}, $other_options->{$key};
  
          return 0 unless $self_options->{$key} eq $other_options->{$key};
      }
  
      return 1;
  }
  
  1;
  
  # ABSTRACT: The Moose attribute metaclass for Roles
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::Role::Attribute - The Moose attribute metaclass for Roles
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This class implements the API for attributes in roles. Attributes in roles are
  more like attribute prototypes than full blown attributes. While they are
  introspectable, they have very little behavior.
  
  =head1 METHODS
  
  This class provides the following methods:
  
  =over 4
  
  =item B<< Moose::Meta::Role::Attribute->new(...) >>
  
  This method accepts all the options that would be passed to the constructor
  for L<Moose::Meta::Attribute>.
  
  =item B<< $attr->metaclass >>
  
  =item B<< $attr->is >>
  
  Returns the option as passed to the constructor.
  
  =item B<< $attr->associated_role >>
  
  Returns the L<Moose::Meta::Role> to which this attribute belongs, if any.
  
  =item B<< $attr->original_role >>
  
  Returns the L<Moose::Meta::Role> in which this attribute was first
  defined. This may not be the same as the value C<associated_role()> in the
  case of composite role, or the case where one role consumes other roles.
  
  =item B<< $attr->original_options >>
  
  Returns a hash reference of options passed to the constructor. This is used
  when creating a L<Moose::Meta::Attribute> object from this object.
  
  =item B<< $attr->attach_to_role($role) >>
  
  Attaches the attribute to the given L<Moose::Meta::Role>.
  
  =item B<< $attr->attribute_for_class($metaclass) >>
  
  Given an attribute metaclass name, this method calls C<<
  $metaclass->interpolate_class_and_new >> to construct an attribute object
  which can be added to a L<Moose::Meta::Class>.
  
  =item B<< $attr->clone >>
  
  Creates a new object identical to the object on which the method is called.
  
  =item B<< $attr->is_same_as($other_attr) >>
  
  Compares two role attributes and returns true if they are identical.
  
  =back
  
  In addition, this class implements all informational predicates implements by
  L<Moose::Meta::Attribute> (and L<Class::MOP::Attribute>).
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_META_ROLE_ATTRIBUTE

$fatpacked{"i686-linux/Moose/Meta/Role/Composite.pm"} = <<'I686-LINUX_MOOSE_META_ROLE_COMPOSITE';
  package Moose::Meta::Role::Composite;
  BEGIN {
    $Moose::Meta::Role::Composite::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Role::Composite::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  use metaclass;
  
  use Class::Load qw(load_class);
  use Scalar::Util 'blessed';
  
  use base 'Moose::Meta::Role';
  
  # NOTE:
  # we need to override the ->name
  # method from Class::MOP::Package
  # since we don't have an actual
  # package for this.
  # - SL
  __PACKAGE__->meta->add_attribute('name' => (
      reader => 'name',
      Class::MOP::_definition_context(),
  ));
  
  # NOTE:
  # Again, since we don't have a real
  # package to store our methods in,
  # we use a HASH ref instead.
  # - SL
  __PACKAGE__->meta->add_attribute('_methods' => (
      reader  => '_method_map',
      default => sub { {} },
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute(
      'application_role_summation_class',
      reader  => 'application_role_summation_class',
      default => 'Moose::Meta::Role::Application::RoleSummation',
      Class::MOP::_definition_context(),
  );
  
  sub new {
      my ($class, %params) = @_;
  
      # the roles param is required ...
      foreach ( @{$params{roles}} ) {
          unless ( $_->isa('Moose::Meta::Role') ) {
              require Moose;
              Moose->throw_error("The list of roles must be instances of Moose::Meta::Role, not $_");
          }
      }
  
      my @composition_roles = map {
          $_->composition_class_roles
      } @{ $params{roles} };
  
      if (@composition_roles) {
          my $meta = Moose::Meta::Class->create_anon_class(
              superclasses => [ $class ],
              roles        => [ @composition_roles ],
              cache        => 1,
          );
          $class = $meta->name;
      }
  
      # and the name is created from the
      # roles if one has not been provided
      $params{name} ||= (join "|" => map { $_->name } @{$params{roles}});
      $class->_new(\%params);
  }
  
  # This is largely a cope of what's in Moose::Meta::Role (itself
  # largely a copy of Class::MOP::Class). However, we can't actually
  # call add_package_symbol, because there's no package to which which
  # add the symbol.
  sub add_method {
      my ($self, $method_name, $method) = @_;
  
      unless ( defined $method_name && $method_name ) {
          Moose->throw_error("You must define a method name");
      }
  
      my $body;
      if (blessed($method)) {
          $body = $method->body;
          if ($method->package_name ne $self->name) {
              $method = $method->clone(
                  package_name => $self->name,
                  name         => $method_name
              ) if $method->can('clone');
          }
      }
      else {
          $body = $method;
          $method = $self->wrap_method_body( body => $body, name => $method_name );
      }
  
      $self->_method_map->{$method_name} = $method;
  }
  
  sub get_method_list {
      my $self = shift;
      return keys %{ $self->_method_map };
  }
  
  sub _get_local_methods {
      my $self = shift;
      return values %{ $self->_method_map };
  }
  
  sub has_method {
      my ($self, $method_name) = @_;
  
      return exists $self->_method_map->{$method_name};
  }
  
  sub get_method {
      my ($self, $method_name) = @_;
  
      return $self->_method_map->{$method_name};
  }
  
  sub apply_params {
      my ($self, $role_params) = @_;
      load_class($self->application_role_summation_class);
  
      $self->application_role_summation_class->new(
          role_params => $role_params,
      )->apply($self);
  
      return $self;
  }
  
  sub reinitialize {
      my ( $class, $old_meta, @args ) = @_;
  
      Moose->throw_error(
          'Moose::Meta::Role::Composite instances can only be reinitialized from an existing metaclass instance'
          )
          if !blessed $old_meta
              || !$old_meta->isa('Moose::Meta::Role::Composite');
  
      my %existing_classes = map { $_ => $old_meta->$_() } qw(
          application_role_summation_class
      );
  
      return $old_meta->meta->clone_object( $old_meta, %existing_classes, @args );
  }
  
  1;
  
  # ABSTRACT: An object to represent the set of roles
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::Role::Composite - An object to represent the set of roles
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  A composite is a role that consists of a set of two or more roles.
  
  The API of a composite role is almost identical to that of a regular
  role.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Role::Composite> is a subclass of L<Moose::Meta::Role>.
  
  =head2 METHODS
  
  =over 4
  
  =item B<< Moose::Meta::Role::Composite->new(%options) >>
  
  This returns a new composite role object. It accepts the same
  options as its parent class, with a few changes:
  
  =over 8
  
  =item * roles
  
  This option is an array reference containing a list of
  L<Moose::Meta::Role> object. This is a required option.
  
  =item * name
  
  If a name is not given, one is generated from the roles provided.
  
  =item * apply_params(\%role_params)
  
  Creates a new RoleSummation role application with C<%role_params> and applies
  the composite role to it. The RoleSummation role application class used is
  determined by the composite role's C<application_role_summation_class>
  attribute.
  
  =item * reinitialize($metaclass)
  
  Like C<< Class::MOP::Package->reinitialize >>, but doesn't allow passing a
  string with the package name, as there is no real package for composite roles.
  
  =back
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_META_ROLE_COMPOSITE

$fatpacked{"i686-linux/Moose/Meta/Role/Method.pm"} = <<'I686-LINUX_MOOSE_META_ROLE_METHOD';
  
  package Moose::Meta::Role::Method;
  BEGIN {
    $Moose::Meta::Role::Method::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Role::Method::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use base 'Moose::Meta::Method';
  
  sub _make_compatible_with {
      my $self = shift;
      my ($other) = @_;
  
      # XXX: this is pretty gross. the issue here is blah blah blah
      # see the comments in CMOP::Method::Meta and CMOP::Method::Wrapped
      return $self unless $other->_is_compatible_with($self->_real_ref_name);
  
      return $self->SUPER::_make_compatible_with(@_);
  }
  
  1;
  
  # ABSTRACT: A Moose Method metaclass for Roles
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::Role::Method - A Moose Method metaclass for Roles
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This is primarily used to mark methods coming from a role
  as being different. Right now it is nothing but a subclass
  of L<Moose::Meta::Method>.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_META_ROLE_METHOD

$fatpacked{"i686-linux/Moose/Meta/Role/Method/Conflicting.pm"} = <<'I686-LINUX_MOOSE_META_ROLE_METHOD_CONFLICTING';
  
  package Moose::Meta::Role::Method::Conflicting;
  BEGIN {
    $Moose::Meta::Role::Method::Conflicting::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Role::Method::Conflicting::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Moose::Util;
  
  use base qw(Moose::Meta::Role::Method::Required);
  
  __PACKAGE__->meta->add_attribute('roles' => (
      reader   => 'roles',
      required => 1,
      Class::MOP::_definition_context(),
  ));
  
  sub roles_as_english_list {
      my $self = shift;
      Moose::Util::english_list( map { q{'} . $_ . q{'} } @{ $self->roles } );
  }
  
  1;
  
  # ABSTRACT: A Moose metaclass for conflicting methods in Roles
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::Role::Method::Conflicting - A Moose metaclass for conflicting methods in Roles
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Role::Method::Conflicting> is a subclass of
  L<Moose::Meta::Role::Method::Required>.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Moose::Meta::Role::Method::Conflicting->new(%options) >>
  
  This creates a new type constraint based on the provided C<%options>:
  
  =over 8
  
  =item * name
  
  The method name. This is required.
  
  =item * roles
  
  The list of role names that generated the conflict. This is required.
  
  =back
  
  =item B<< $method->name >>
  
  Returns the conflicting method's name, as provided to the constructor.
  
  =item B<< $method->roles >>
  
  Returns the roles that generated this conflicting method, as provided to the
  constructor.
  
  =item B<< $method->roles_as_english_list >>
  
  Returns the roles that generated this conflicting method as an English list.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_META_ROLE_METHOD_CONFLICTING

$fatpacked{"i686-linux/Moose/Meta/Role/Method/Required.pm"} = <<'I686-LINUX_MOOSE_META_ROLE_METHOD_REQUIRED';
  
  package Moose::Meta::Role::Method::Required;
  BEGIN {
    $Moose::Meta::Role::Method::Required::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::Role::Method::Required::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  use metaclass;
  
  use overload '""'     => sub { shift->name },   # stringify to method name
               fallback => 1;
  
  use base qw(Class::MOP::Object);
  
  # This is not a Moose::Meta::Role::Method because it has no implementation, it
  # is just a name
  
  __PACKAGE__->meta->add_attribute('name' => (
      reader   => 'name',
      required => 1,
      Class::MOP::_definition_context(),
  ));
  
  sub new { shift->_new(@_) }
  
  1;
  
  # ABSTRACT: A Moose metaclass for required methods in Roles
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::Role::Method::Required - A Moose metaclass for required methods in Roles
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  =head1 INHERITANCE
  
  C<Moose::Meta::Role::Method::Required> is a subclass of L<Class::MOP::Object>.
  It is B<not> a subclass of C<Moose::Meta::Role::Method> since it does not
  provide an implementation of the method.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Moose::Meta::Role::Method::Required->new(%options) >>
  
  This creates a new type constraint based on the provided C<%options>:
  
  =over 8
  
  =item * name
  
  The method name. This is required.
  
  =back
  
  =item B<< $method->name >>
  
  Returns the required method's name, as provided to the constructor.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_META_ROLE_METHOD_REQUIRED

$fatpacked{"i686-linux/Moose/Meta/TypeCoercion.pm"} = <<'I686-LINUX_MOOSE_META_TYPECOERCION';
  
  package Moose::Meta::TypeCoercion;
  BEGIN {
    $Moose::Meta::TypeCoercion::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::TypeCoercion::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  use metaclass;
  
  use Moose::Meta::Attribute;
  use Moose::Util::TypeConstraints ();
  
  __PACKAGE__->meta->add_attribute('type_coercion_map' => (
      reader  => 'type_coercion_map',
      default => sub { [] },
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute(
      Moose::Meta::Attribute->new('type_constraint' => (
          reader   => 'type_constraint',
          weak_ref => 1,
          Class::MOP::_definition_context(),
      ))
  );
  
  # private accessor
  __PACKAGE__->meta->add_attribute('compiled_type_coercion' => (
      accessor => '_compiled_type_coercion',
      Class::MOP::_definition_context(),
  ));
  
  sub new {
      my $class = shift;
      my $self  = Class::MOP::class_of($class)->new_object(@_);
      $self->compile_type_coercion;
      return $self;
  }
  
  sub compile_type_coercion {
      my $self = shift;
      my @coercion_map = @{$self->type_coercion_map};
      my @coercions;
      while (@coercion_map) {
          my ($constraint_name, $action) = splice(@coercion_map, 0, 2);
          my $type_constraint = ref $constraint_name ? $constraint_name : Moose::Util::TypeConstraints::find_or_parse_type_constraint($constraint_name);
  
          unless ( defined $type_constraint ) {
              require Moose;
              Moose->throw_error("Could not find the type constraint ($constraint_name) to coerce from");
          }
  
          push @coercions => [
              $type_constraint->_compiled_type_constraint,
              $action
          ];
      }
      $self->_compiled_type_coercion(sub {
          my $thing = shift;
          foreach my $coercion (@coercions) {
              my ($constraint, $converter) = @$coercion;
              if ($constraint->($thing)) {
                  local $_ = $thing;
                  return $converter->($thing);
              }
          }
          return $thing;
      });
  }
  
  sub has_coercion_for_type {
      my ($self, $type_name) = @_;
      my %coercion_map = @{$self->type_coercion_map};
      exists $coercion_map{$type_name} ? 1 : 0;
  }
  
  sub add_type_coercions {
      my ($self, @new_coercion_map) = @_;
  
      my $coercion_map = $self->type_coercion_map;
      my %has_coercion = @$coercion_map;
  
      while (@new_coercion_map) {
          my ($constraint_name, $action) = splice(@new_coercion_map, 0, 2);
  
          if ( exists $has_coercion{$constraint_name} ) {
              require Moose;
              Moose->throw_error("A coercion action already exists for '$constraint_name'")
          }
  
          push @{$coercion_map} => ($constraint_name, $action);
      }
  
      # and re-compile ...
      $self->compile_type_coercion;
  }
  
  sub coerce { $_[0]->_compiled_type_coercion->($_[1]) }
  
  
  1;
  
  # ABSTRACT: The Moose Type Coercion metaclass
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::TypeCoercion - The Moose Type Coercion metaclass
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  A type coercion object is basically a mapping of one or more type
  constraints and the associated coercions subroutines.
  
  It's unlikely that you will need to instantiate an object of this
  class directly, as it's part of the deep internals of Moose.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Moose::Meta::TypeCoercion->new(%options) >>
  
  Creates a new type coercion object, based on the options provided.
  
  =over 8
  
  =item * type_constraint
  
  This is the L<Moose::Meta::TypeConstraint> object for the type that is
  being coerced I<to>.
  
  =back
  
  =item B<< $coercion->type_coercion_map >>
  
  This returns the map of type constraints to coercions as an array
  reference. The values of the array alternate between type names and
  subroutine references which implement the coercion.
  
  The value is an array reference because coercions are tried in the
  order they are added.
  
  =item B<< $coercion->type_constraint >>
  
  This returns the L<Moose::Meta::TypeConstraint> that was passed to the
  constructor.
  
  =item B<< $coercion->has_coercion_for_type($type_name) >>
  
  Returns true if the coercion can coerce the named type.
  
  =item B<< $coercion->add_type_coercions( $type_name => $sub, ... ) >>
  
  This method takes a list of type names and subroutine references. If
  the coercion already has a mapping for a given type, it throws an
  exception.
  
  Coercions are actually
  
  =item B<< $coercion->coerce($value) >>
  
  This method takes a value and applies the first valid coercion it
  finds.
  
  This means that if the value could belong to more than type in the
  coercion object, the first coercion added is used.
  
  =item B<< Moose::Meta::TypeCoercion->meta >>
  
  This will return a L<Class::MOP::Class> instance for this class.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_META_TYPECOERCION

$fatpacked{"i686-linux/Moose/Meta/TypeCoercion/Union.pm"} = <<'I686-LINUX_MOOSE_META_TYPECOERCION_UNION';
  
  package Moose::Meta::TypeCoercion::Union;
  BEGIN {
    $Moose::Meta::TypeCoercion::Union::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::TypeCoercion::Union::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  use metaclass;
  
  use Scalar::Util 'blessed';
  
  use base 'Moose::Meta::TypeCoercion';
  
  sub compile_type_coercion {
      my $self            = shift;
      my $type_constraint = $self->type_constraint;
  
      (blessed $type_constraint && $type_constraint->isa('Moose::Meta::TypeConstraint::Union'))
       || Moose->throw_error("You can only create a Moose::Meta::TypeCoercion::Union for a " .
                  "Moose::Meta::TypeConstraint::Union, not a $type_constraint");
  
      $self->_compiled_type_coercion(
          sub {
              my $value = shift;
  
              foreach my $type ( grep { $_->has_coercion }
                  @{ $type_constraint->type_constraints } ) {
                  my $temp = $type->coerce($value);
                  return $temp if $type_constraint->check($temp);
              }
  
              return $value;
          }
      );
  }
  
  sub has_coercion_for_type { 0 }
  
  sub add_type_coercions {
      require Moose;
      Moose->throw_error("Cannot add additional type coercions to Union types");
  }
  
  1;
  
  # ABSTRACT: The Moose Type Coercion metaclass for Unions
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::TypeCoercion::Union - The Moose Type Coercion metaclass for Unions
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This is a subclass of L<Moose::Meta::TypeCoercion> that is used for
  L<Moose::Meta::TypeConstraint::Union> objects.
  =head1 METHODS
  
  =over 4
  
  =item B<< $coercion->has_coercion_for_type >>
  
  This method always returns false.
  
  =item B<< $coercion->add_type_coercions >>
  
  This method always throws an error. You cannot add coercions to a
  union type coercion.
  
  =item B<< $coercion->coerce($value) >>
  
  This method will coerce by trying the coercions for each type in the
  union.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_META_TYPECOERCION_UNION

$fatpacked{"i686-linux/Moose/Meta/TypeConstraint.pm"} = <<'I686-LINUX_MOOSE_META_TYPECONSTRAINT';
  
  package Moose::Meta::TypeConstraint;
  BEGIN {
    $Moose::Meta::TypeConstraint::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::TypeConstraint::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  use metaclass;
  
  use overload '0+'     => sub { refaddr(shift) }, # id an object
               '""'     => sub { shift->name },   # stringify to tc name
               bool     => sub { 1 },
               fallback => 1;
  
  use Carp qw(confess);
  use Class::Load qw(load_class);
  use Eval::Closure;
  use Scalar::Util qw(blessed refaddr);
  use Sub::Name qw(subname);
  use Try::Tiny;
  
  use base qw(Class::MOP::Object);
  
  __PACKAGE__->meta->add_attribute('name'       => (
      reader => 'name',
      Class::MOP::_definition_context(),
  ));
  __PACKAGE__->meta->add_attribute('parent'     => (
      reader    => 'parent',
      predicate => 'has_parent',
      Class::MOP::_definition_context(),
  ));
  
  my $null_constraint = sub { 1 };
  __PACKAGE__->meta->add_attribute('constraint' => (
      reader  => 'constraint',
      writer  => '_set_constraint',
      default => sub { $null_constraint },
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('message'   => (
      accessor  => 'message',
      predicate => 'has_message',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('_default_message' => (
      accessor  => '_default_message',
      Class::MOP::_definition_context(),
  ));
  
  # can't make this a default because it has to close over the type name, and
  # cmop attributes don't have lazy
  my $_default_message_generator = sub {
      my $name = shift;
      sub {
          my $value = shift;
          # have to load it late like this, since it uses Moose itself
          my $can_partialdump = try {
              # versions prior to 0.14 had a potential infinite loop bug
              load_class('Devel::PartialDump', { -version => 0.14 });
              1;
          };
          if ($can_partialdump) {
              $value = Devel::PartialDump->new->dump($value);
          }
          else {
              $value = (defined $value ? overload::StrVal($value) : 'undef');
          }
          return "Validation failed for '" . $name . "' with value $value";
      }
  };
  __PACKAGE__->meta->add_attribute('coercion'   => (
      accessor  => 'coercion',
      predicate => 'has_coercion',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('hand_optimized_type_constraint' => (
      init_arg  => 'optimized',
      accessor  => 'hand_optimized_type_constraint',
      predicate => 'has_hand_optimized_type_constraint',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('inlined' => (
      init_arg  => 'inlined',
      accessor  => 'inlined',
      predicate => '_has_inlined_type_constraint',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('inline_environment' => (
      init_arg => 'inline_environment',
      accessor => '_inline_environment',
      default  => sub { {} },
      Class::MOP::_definition_context(),
  ));
  
  sub parents {
      my $self = shift;
      $self->parent;
  }
  
  # private accessors
  
  __PACKAGE__->meta->add_attribute('compiled_type_constraint' => (
      accessor  => '_compiled_type_constraint',
      predicate => '_has_compiled_type_constraint',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('package_defined_in' => (
      accessor => '_package_defined_in',
      Class::MOP::_definition_context(),
  ));
  
  sub new {
      my $class = shift;
      my ($first, @rest) = @_;
      my %args = ref $first ? %$first : $first ? ($first, @rest) : ();
      $args{name} = $args{name} ? "$args{name}" : "__ANON__";
  
      if ( $args{optimized} ) {
          Moose::Deprecated::deprecated(
              feature => 'optimized type constraint sub ref',
              message =>
                  'Providing an optimized subroutine ref for type constraints is deprecated.'
                  . ' Use the inlining feature (inline_as) instead.'
          );
      }
  
      if ( exists $args{message}
        && (!ref($args{message}) || ref($args{message}) ne 'CODE') ) {
          confess("The 'message' parameter must be a coderef");
      }
  
      my $self  = $class->_new(%args);
      $self->compile_type_constraint()
          unless $self->_has_compiled_type_constraint;
      $self->_default_message($_default_message_generator->($self->name))
          unless $self->has_message;
      return $self;
  }
  
  
  
  sub coerce {
      my $self = shift;
  
      my $coercion = $self->coercion;
  
      unless ($coercion) {
          require Moose;
          Moose->throw_error("Cannot coerce without a type coercion");
      }
  
      return $_[0] if $self->check($_[0]);
  
      return $coercion->coerce(@_);
  }
  
  sub assert_coerce {
      my $self = shift;
  
      my $coercion = $self->coercion;
  
      unless ($coercion) {
          require Moose;
          Moose->throw_error("Cannot coerce without a type coercion");
      }
  
      return $_[0] if $self->check($_[0]);
  
      my $result = $coercion->coerce(@_);
  
      $self->assert_valid($result);
  
      return $result;
  }
  
  sub check {
      my ($self, @args) = @_;
      my $constraint_subref = $self->_compiled_type_constraint;
      return $constraint_subref->(@args) ? 1 : undef;
  }
  
  sub validate {
      my ($self, $value) = @_;
      if ($self->_compiled_type_constraint->($value)) {
          return undef;
      }
      else {
          $self->get_message($value);
      }
  }
  
  sub can_be_inlined {
      my $self = shift;
  
      if ( $self->has_parent && $self->constraint == $null_constraint ) {
          return $self->parent->can_be_inlined;
      }
  
      return $self->_has_inlined_type_constraint;
  }
  
  sub _inline_check {
      my $self = shift;
  
      unless ( $self->can_be_inlined ) {
          require Moose;
          Moose->throw_error( 'Cannot inline a type constraint check for ' . $self->name );
      }
  
      if ( $self->has_parent && $self->constraint == $null_constraint ) {
          return $self->parent->_inline_check(@_);
      }
  
      return '( do { ' . $self->inlined->( $self, @_ ) . ' } )';
  }
  
  sub inline_environment {
      my $self = shift;
  
      if ( $self->has_parent && $self->constraint == $null_constraint ) {
          return $self->parent->inline_environment;
      }
  
      return $self->_inline_environment;
  }
  
  sub assert_valid {
      my ($self, $value) = @_;
  
      my $error = $self->validate($value);
      return 1 if ! defined $error;
  
      require Moose;
      Moose->throw_error($error);
  }
  
  sub get_message {
      my ($self, $value) = @_;
      my $msg = $self->has_message
          ? $self->message
          : $self->_default_message;
      local $_ = $value;
      return $msg->($value);
  }
  
  ## type predicates ...
  
  sub equals {
      my ( $self, $type_or_name ) = @_;
  
      my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name) or return;
  
      return 1 if $self == $other;
  
      if ( $self->has_hand_optimized_type_constraint and $other->has_hand_optimized_type_constraint ) {
          return 1 if $self->hand_optimized_type_constraint == $other->hand_optimized_type_constraint;
      }
  
      return unless $self->constraint == $other->constraint;
  
      if ( $self->has_parent ) {
          return unless $other->has_parent;
          return unless $self->parent->equals( $other->parent );
      } else {
          return if $other->has_parent;
      }
  
      return;
  }
  
  sub is_a_type_of {
      my ($self, $type_or_name) = @_;
  
      my $type = Moose::Util::TypeConstraints::find_type_constraint($type_or_name) or return;
  
      ($self->equals($type) || $self->is_subtype_of($type));
  }
  
  sub is_subtype_of {
      my ($self, $type_or_name) = @_;
  
      my $type = Moose::Util::TypeConstraints::find_type_constraint($type_or_name) or return;
  
      my $current = $self;
  
      while (my $parent = $current->parent) {
          return 1 if $parent->equals($type);
          $current = $parent;
      }
  
      return 0;
  }
  
  ## compiling the type constraint
  
  sub compile_type_constraint {
      my $self = shift;
      $self->_compiled_type_constraint($self->_actually_compile_type_constraint);
  }
  
  ## type compilers ...
  
  sub _actually_compile_type_constraint {
      my $self = shift;
  
      return $self->_compile_hand_optimized_type_constraint
          if $self->has_hand_optimized_type_constraint;
  
      if ( $self->can_be_inlined ) {
          return eval_closure(
              source      => 'sub { ' . $self->_inline_check('$_[0]') . ' }',
              environment => $self->inline_environment,
          );
      }
  
      my $check = $self->constraint;
      unless ( defined $check ) {
          require Moose;
          Moose->throw_error( "Could not compile type constraint '"
                  . $self->name
                  . "' because no constraint check" );
      }
  
      return $self->_compile_subtype($check)
          if $self->has_parent;
  
      return $self->_compile_type($check);
  }
  
  sub _compile_hand_optimized_type_constraint {
      my $self = shift;
  
      my $type_constraint = $self->hand_optimized_type_constraint;
  
      unless ( ref $type_constraint ) {
          require Moose;
          Moose->throw_error("Hand optimized type constraint is not a code reference");
      }
  
      return $type_constraint;
  }
  
  sub _compile_subtype {
      my ($self, $check) = @_;
  
      # gather all the parent constraintss in order
      my @parents;
      my $optimized_parent;
      foreach my $parent ($self->_collect_all_parents) {
          # if a parent is optimized, the optimized constraint already includes
          # all of its parents tcs, so we can break the loop
          if ($parent->has_hand_optimized_type_constraint) {
              push @parents => $optimized_parent = $parent->hand_optimized_type_constraint;
              last;
          }
          else {
              push @parents => $parent->constraint;
          }
      }
  
      @parents = grep { $_ != $null_constraint } reverse @parents;
  
      unless ( @parents ) {
          return $self->_compile_type($check);
      } elsif( $optimized_parent and @parents == 1 ) {
          # the case of just one optimized parent is optimized to prevent
          # looping and the unnecessary localization
          if ( $check == $null_constraint ) {
              return $optimized_parent;
          } else {
              return subname($self->name, sub {
                  return undef unless $optimized_parent->($_[0]);
                  my (@args) = @_;
                  local $_ = $args[0];
                  $check->(@args);
              });
          }
      } else {
          # general case, check all the constraints, from the first parent to ourselves
          my @checks = @parents;
          push @checks, $check if $check != $null_constraint;
          return subname($self->name => sub {
              my (@args) = @_;
              local $_ = $args[0];
              foreach my $check (@checks) {
                  return undef unless $check->(@args);
              }
              return 1;
          });
      }
  }
  
  sub _compile_type {
      my ($self, $check) = @_;
  
      return $check if $check == $null_constraint; # Item, Any
  
      return subname($self->name => sub {
          my (@args) = @_;
          local $_ = $args[0];
          $check->(@args);
      });
  }
  
  ## other utils ...
  
  sub _collect_all_parents {
      my $self = shift;
      my @parents;
      my $current = $self->parent;
      while (defined $current) {
          push @parents => $current;
          $current = $current->parent;
      }
      return @parents;
  }
  
  sub create_child_type {
      my ($self, %opts) = @_;
      my $class = ref $self;
      return $class->new(%opts, parent => $self);
  }
  
  1;
  
  # ABSTRACT: The Moose Type Constraint metaclass
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint - The Moose Type Constraint metaclass
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This class represents a single type constraint. Moose's built-in type
  constraints, as well as constraints you define, are all stored in a
  L<Moose::Meta::TypeConstraint::Registry> object as objects of this
  class.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint> is a subclass of L<Class::MOP::Object>.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Moose::Meta::TypeConstraint->new(%options) >>
  
  This creates a new type constraint based on the provided C<%options>:
  
  =over 8
  
  =item * name
  
  The constraint name. If a name is not provided, it will be set to
  "__ANON__".
  
  =item * parent
  
  A C<Moose::Meta::TypeConstraint> object which is the parent type for
  the type being created. This is optional.
  
  =item * constraint
  
  This is the subroutine reference that implements the actual constraint
  check. This defaults to a subroutine which always returns true.
  
  =item * message
  
  A subroutine reference which is used to generate an error message when
  the constraint fails. This is optional.
  
  =item * coercion
  
  A L<Moose::Meta::TypeCoercion> object representing the coercions to
  the type. This is optional.
  
  =item * inlined
  
  A subroutine which returns a string suitable for inlining this type
  constraint. It will be called as a method on the type constraint object, and
  will receive a single additional parameter, a variable name to be tested
  (usually C<"$_"> or C<"$_[0]">.
  
  This is optional.
  
  =item * inline_environment
  
  A hash reference of variables to close over. The keys are variables names, and
  the values are I<references> to the variables.
  
  =item * optimized
  
  B<This option is deprecated.>
  
  This is a variant of the C<constraint> parameter that is somehow
  optimized. Typically, this means incorporating both the type's
  constraint and all of its parents' constraints into a single
  subroutine reference.
  
  =back
  
  =item B<< $constraint->equals($type_name_or_object) >>
  
  Returns true if the supplied name or type object is the same as the
  current type.
  
  =item B<< $constraint->is_subtype_of($type_name_or_object) >>
  
  Returns true if the supplied name or type object is a parent of the
  current type.
  
  =item B<< $constraint->is_a_type_of($type_name_or_object) >>
  
  Returns true if the given type is the same as the current type, or is
  a parent of the current type. This is a shortcut for checking
  C<equals> and C<is_subtype_of>.
  
  =item B<< $constraint->coerce($value) >>
  
  This will attempt to coerce the value to the type. If the type does not
  have any defined coercions this will throw an error.
  
  If no coercion can produce a value matching C<$constraint>, the original
  value is returned.
  
  =item B<< $constraint->assert_coerce($value) >>
  
  This method behaves just like C<coerce>, but if the result is not valid
  according to C<$constraint>, an error is thrown.
  
  =item B<< $constraint->check($value) >>
  
  Returns true if the given value passes the constraint for the type.
  
  =item B<< $constraint->validate($value) >>
  
  This is similar to C<check>. However, if the type I<is valid> then the
  method returns an explicit C<undef>. If the type is not valid, we call
  C<< $self->get_message($value) >> internally to generate an error
  message.
  
  =item B<< $constraint->assert_valid($value) >>
  
  Like C<check> and C<validate>, this method checks whether C<$value> is
  valid under the constraint.  If it is, it will return true.  If it is not,
  an exception will be thrown with the results of
  C<< $self->get_message($value) >>.
  
  =item B<< $constraint->name >>
  
  Returns the type's name, as provided to the constructor.
  
  =item B<< $constraint->parent >>
  
  Returns the type's parent, as provided to the constructor, if any.
  
  =item B<< $constraint->has_parent >>
  
  Returns true if the type has a parent type.
  
  =item B<< $constraint->parents >>
  
  Returns all of the types parents as an list of type constraint objects.
  
  =item B<< $constraint->constraint >>
  
  Returns the type's constraint, as provided to the constructor.
  
  =item B<< $constraint->get_message($value) >>
  
  This generates a method for the given value. If the type does not have
  an explicit message, we generate a default message.
  
  =item B<< $constraint->has_message >>
  
  Returns true if the type has a message.
  
  =item B<< $constraint->message >>
  
  Returns the type's message as a subroutine reference.
  
  =item B<< $constraint->coercion >>
  
  Returns the type's L<Moose::Meta::TypeCoercion> object, if one
  exists.
  
  =item B<< $constraint->has_coercion >>
  
  Returns true if the type has a coercion.
  
  =item B<< $constraint->can_be_inlined >>
  
  Returns true if this type constraint can be inlined. A type constraint which
  subtypes an inlinable constraint and does not add an additional constraint
  "inherits" its parent type's inlining.
  
  =item B<< $constraint->hand_optimized_type_constraint >>
  
  B<This method is deprecated.>
  
  Returns the type's hand optimized constraint, as provided to the
  constructor via the C<optimized> option.
  
  =item B<< $constraint->has_hand_optimized_type_constraint >>
  
  B<This method is deprecated.>
  
  Returns true if the type has an optimized constraint.
  
  =item B<< $constraint->create_child_type(%options) >>
  
  This returns a new type constraint of the same class using the
  provided C<%options>. The C<parent> option will be the current type.
  
  This method exists so that subclasses of this class can override this
  behavior and change how child types are created.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_META_TYPECONSTRAINT

$fatpacked{"i686-linux/Moose/Meta/TypeConstraint/Class.pm"} = <<'I686-LINUX_MOOSE_META_TYPECONSTRAINT_CLASS';
  package Moose::Meta::TypeConstraint::Class;
  BEGIN {
    $Moose::Meta::TypeConstraint::Class::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::TypeConstraint::Class::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  use metaclass;
  
  use B;
  use Scalar::Util 'blessed';
  use Moose::Util::TypeConstraints ();
  
  use base 'Moose::Meta::TypeConstraint';
  
  __PACKAGE__->meta->add_attribute('class' => (
      reader => 'class',
      Class::MOP::_definition_context(),
  ));
  
  my $inliner = sub {
      my $self = shift;
      my $val  = shift;
  
      return 'Scalar::Util::blessed(' . $val . ')'
               . ' && ' . $val . '->isa(' . B::perlstring($self->class) . ')';
  };
  
  sub new {
      my ( $class, %args ) = @_;
  
      $args{parent}
          = Moose::Util::TypeConstraints::find_type_constraint('Object');
  
      my $class_name = $args{class};
      $args{constraint} = sub { $_[0]->isa($class_name) };
  
      $args{inlined} = $inliner;
  
      my $self = $class->SUPER::new( \%args );
  
      $self->compile_type_constraint();
  
      return $self;
  }
  
  sub parents {
      my $self = shift;
      return (
          $self->parent,
          map {
              # FIXME find_type_constraint might find a TC named after the class but that isn't really it
              # I did this anyway since it's a convention that preceded TypeConstraint::Class, and it should DWIM
              # if anybody thinks this problematic please discuss on IRC.
              # a possible fix is to add by attr indexing to the type registry to find types of a certain property
              # regardless of their name
              Moose::Util::TypeConstraints::find_type_constraint($_)
                  ||
              __PACKAGE__->new( class => $_, name => "__ANON__" )
          } Class::MOP::class_of($self->class)->superclasses,
      );
  }
  
  sub equals {
      my ( $self, $type_or_name ) = @_;
  
      my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
  
      if (!defined($other)) {
          if (!ref($type_or_name)) {
              return $self->class eq $type_or_name;
          }
          return;
      }
  
      return unless $other->isa(__PACKAGE__);
  
      return $self->class eq $other->class;
  }
  
  sub is_a_type_of {
      my ($self, $type_or_name) = @_;
  
      ($self->equals($type_or_name) || $self->is_subtype_of($type_or_name));
  }
  
  sub is_subtype_of {
      my ($self, $type_or_name_or_class ) = @_;
  
      my $type = Moose::Util::TypeConstraints::find_type_constraint($type_or_name_or_class);
  
      if ( not defined $type ) {
          if ( not ref $type_or_name_or_class ) {
              # it might be a class
              my $class = $self->class;
              return 1 if $class ne $type_or_name_or_class
                       && $class->isa( $type_or_name_or_class );
          }
          return;
      }
  
      if ( $type->isa(__PACKAGE__) && $type->class ne $self->class) {
          # if $type_or_name_or_class isn't a class, it might be the TC name of another ::Class type
          # or it could also just be a type object in this branch
          return $self->class->isa( $type->class );
      } else {
          # the only other thing we are a subtype of is Object
          $self->SUPER::is_subtype_of($type);
      }
  }
  
  # This is a bit counter-intuitive, but a child type of a Class type
  # constraint is not itself a Class type constraint (it has no class
  # attribute). This whole create_child_type thing needs some changing
  # though, probably making MMC->new a factory or something.
  sub create_child_type {
      my ($self, @args) = @_;
      return Moose::Meta::TypeConstraint->new(@args, parent => $self);
  }
  
  sub get_message {
      my $self = shift;
      my ($value) = @_;
  
      if ($self->has_message) {
          return $self->SUPER::get_message(@_);
      }
  
      $value = (defined $value ? overload::StrVal($value) : 'undef');
      return "Validation failed for '" . $self->name . "' with value $value (not isa " . $self->class . ")";
  }
  
  1;
  
  # ABSTRACT: Class/TypeConstraint parallel hierarchy
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint::Class - Class/TypeConstraint parallel hierarchy
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This class represents type constraints for a class.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint::Class> is a subclass of
  L<Moose::Meta::TypeConstraint>.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Moose::Meta::TypeConstraint::Class->new(%options) >>
  
  This creates a new class type constraint based on the given
  C<%options>.
  
  It takes the same options as its parent, with two exceptions. First,
  it requires an additional option, C<class>, which is name of the
  constraint's class.  Second, it automatically sets the parent to the
  C<Object> type.
  
  The constructor also overrides the hand optimized type constraint with
  one it creates internally.
  
  =item B<< $constraint->class >>
  
  Returns the class name associated with the constraint.
  
  =item B<< $constraint->parents >>
  
  Returns all the type's parent types, corresponding to its parent
  classes.
  
  =item B<< $constraint->is_subtype_of($type_name_or_object) >>
  
  If the given type is also a class type, then this checks that the
  type's class is a subclass of the other type's class.
  
  Otherwise it falls back to the implementation in
  L<Moose::Meta::TypeConstraint>.
  
  =item B<< $constraint->create_child_type(%options) >>
  
  This returns a new L<Moose::Meta::TypeConstraint> object with the type
  as its parent.
  
  Note that it does I<not> return a
  C<Moose::Meta::TypeConstraint::Class> object!
  
  =item B<< $constraint->get_message($value) >>
  
  This is the same as L<Moose::Meta::TypeConstraint/get_message> except
  that it explicitly says C<isa> was checked. This is to help users deal
  with accidentally autovivified type constraints.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_META_TYPECONSTRAINT_CLASS

$fatpacked{"i686-linux/Moose/Meta/TypeConstraint/DuckType.pm"} = <<'I686-LINUX_MOOSE_META_TYPECONSTRAINT_DUCKTYPE';
  package Moose::Meta::TypeConstraint::DuckType;
  BEGIN {
    $Moose::Meta::TypeConstraint::DuckType::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::TypeConstraint::DuckType::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  use metaclass;
  
  use B;
  use Scalar::Util 'blessed';
  use List::MoreUtils qw(all);
  use Moose::Util 'english_list';
  
  use Moose::Util::TypeConstraints ();
  
  use base 'Moose::Meta::TypeConstraint';
  
  __PACKAGE__->meta->add_attribute('methods' => (
      accessor => 'methods',
      Class::MOP::_definition_context(),
  ));
  
  my $inliner = sub {
      my $self = shift;
      my $val  = shift;
  
      return $self->parent->_inline_check($val)
           . ' && do {' . "\n"
               . 'my $val = ' . $val . ';' . "\n"
               . '&List::MoreUtils::all(' . "\n"
                   . 'sub { $val->can($_) },' . "\n"
                   . join(', ', map { B::perlstring($_) } @{ $self->methods })
               . ');' . "\n"
           . '}';
  };
  
  sub new {
      my ( $class, %args ) = @_;
  
      $args{parent}
          = Moose::Util::TypeConstraints::find_type_constraint('Object');
  
      my @methods = @{ $args{methods} };
      $args{constraint} = sub {
          my $val = $_[0];
          return all { $val->can($_) } @methods;
      };
  
      $args{inlined} = $inliner;
  
      my $self = $class->SUPER::new(\%args);
  
      $self->compile_type_constraint()
          unless $self->_has_compiled_type_constraint;
  
      return $self;
  }
  
  sub equals {
      my ( $self, $type_or_name ) = @_;
  
      my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
  
      return unless $other->isa(__PACKAGE__);
  
      my @self_methods  = sort @{ $self->methods };
      my @other_methods = sort @{ $other->methods };
  
      return unless @self_methods == @other_methods;
  
      while ( @self_methods ) {
          my $method = shift @self_methods;
          my $other_method = shift @other_methods;
  
          return unless $method eq $other_method;
      }
  
      return 1;
  }
  
  sub create_child_type {
      my ($self, @args) = @_;
      return Moose::Meta::TypeConstraint->new(@args, parent => $self);
  }
  
  sub get_message {
      my $self = shift;
      my ($value) = @_;
  
      if ($self->has_message) {
          return $self->SUPER::get_message(@_);
      }
  
      return $self->SUPER::get_message($value) unless blessed($value);
  
      my @methods = grep { !$value->can($_) } @{ $self->methods };
      my $class = blessed $value;
      $class ||= $value;
  
      return $class
           . " is missing methods "
           . english_list(map { "'$_'" } @methods);
  }
  
  1;
  
  # ABSTRACT: Type constraint for duck typing
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint::DuckType - Type constraint for duck typing
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This class represents type constraints based on an enumerated list of
  required methods.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint::DuckType> is a subclass of
  L<Moose::Meta::TypeConstraint>.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Moose::Meta::TypeConstraint::DuckType->new(%options) >>
  
  This creates a new duck type constraint based on the given
  C<%options>.
  
  It takes the same options as its parent, with several
  exceptions. First, it requires an additional option, C<methods>. This
  should be an array reference containing a list of required method
  names. Second, it automatically sets the parent to the C<Object> type.
  
  Finally, it ignores any provided C<constraint> option. The constraint
  is generated automatically based on the provided C<methods>.
  
  =item B<< $constraint->methods >>
  
  Returns the array reference of required methods provided to the
  constructor.
  
  =item B<< $constraint->create_child_type >>
  
  This returns a new L<Moose::Meta::TypeConstraint> object with the type
  as its parent.
  
  Note that it does I<not> return a C<Moose::Meta::TypeConstraint::DuckType>
  object!
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
  
I686-LINUX_MOOSE_META_TYPECONSTRAINT_DUCKTYPE

$fatpacked{"i686-linux/Moose/Meta/TypeConstraint/Enum.pm"} = <<'I686-LINUX_MOOSE_META_TYPECONSTRAINT_ENUM';
  package Moose::Meta::TypeConstraint::Enum;
  BEGIN {
    $Moose::Meta::TypeConstraint::Enum::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::TypeConstraint::Enum::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  use metaclass;
  
  use B;
  use Moose::Util::TypeConstraints ();
  
  use base 'Moose::Meta::TypeConstraint';
  
  __PACKAGE__->meta->add_attribute('values' => (
      accessor => 'values',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('_inline_var_name' => (
      accessor => '_inline_var_name',
      Class::MOP::_definition_context(),
  ));
  
  my $inliner = sub {
      my $self = shift;
      my $val  = shift;
  
      return 'defined(' . $val . ') '
               . '&& !ref(' . $val . ') '
               . '&& $' . $self->_inline_var_name . '{' . $val . '}';
  };
  
  my $var_suffix = 0;
  
  sub new {
      my ( $class, %args ) = @_;
  
      $args{parent} = Moose::Util::TypeConstraints::find_type_constraint('Str');
      $args{inlined} = $inliner;
  
      if ( scalar @{ $args{values} } < 1 ) {
          require Moose;
          Moose->throw_error("You must have at least one value to enumerate through");
      }
  
      for (@{ $args{values} }) {
          if (!defined($_)) {
              require Moose;
              Moose->throw_error("Enum values must be strings, not undef");
          }
          elsif (ref($_)) {
              require Moose;
              Moose->throw_error("Enum values must be strings, not '$_'");
          }
      }
  
      my %values = map { $_ => 1 } @{ $args{values} };
      $args{constraint} = sub { $values{ $_[0] } };
  
      my $var_name = 'enums' . $var_suffix++;;
      $args{_inline_var_name} = $var_name;
      $args{inline_environment} = { '%' . $var_name => \%values };
  
      my $self = $class->SUPER::new(\%args);
  
      $self->compile_type_constraint()
          unless $self->_has_compiled_type_constraint;
  
      return $self;
  }
  
  sub equals {
      my ( $self, $type_or_name ) = @_;
  
      my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
  
      return unless $other->isa(__PACKAGE__);
  
      my @self_values  = sort @{ $self->values };
      my @other_values = sort @{ $other->values };
  
      return unless @self_values == @other_values;
  
      while ( @self_values ) {
          my $value = shift @self_values;
          my $other_value = shift @other_values;
  
          return unless $value eq $other_value;
      }
  
      return 1;
  }
  
  sub constraint {
      my $self = shift;
  
      my %values = map { $_ => undef } @{ $self->values };
  
      return sub { exists $values{$_[0]} };
  }
  
  sub create_child_type {
      my ($self, @args) = @_;
      return Moose::Meta::TypeConstraint->new(@args, parent => $self);
  }
  
  1;
  
  # ABSTRACT: Type constraint for enumerated values.
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint::Enum - Type constraint for enumerated values.
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This class represents type constraints based on an enumerated list of
  acceptable values.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint::Enum> is a subclass of
  L<Moose::Meta::TypeConstraint>.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Moose::Meta::TypeConstraint::Enum->new(%options) >>
  
  This creates a new enum type constraint based on the given
  C<%options>.
  
  It takes the same options as its parent, with several
  exceptions. First, it requires an additional option, C<values>. This
  should be an array reference containing a list of valid string
  values. Second, it automatically sets the parent to the C<Str> type.
  
  Finally, it ignores any provided C<constraint> option. The constraint
  is generated automatically based on the provided C<values>.
  
  =item B<< $constraint->values >>
  
  Returns the array reference of acceptable values provided to the
  constructor.
  
  =item B<< $constraint->create_child_type >>
  
  This returns a new L<Moose::Meta::TypeConstraint> object with the type
  as its parent.
  
  Note that it does I<not> return a C<Moose::Meta::TypeConstraint::Enum>
  object!
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
  
  
I686-LINUX_MOOSE_META_TYPECONSTRAINT_ENUM

$fatpacked{"i686-linux/Moose/Meta/TypeConstraint/Parameterizable.pm"} = <<'I686-LINUX_MOOSE_META_TYPECONSTRAINT_PARAMETERIZABLE';
  package Moose::Meta::TypeConstraint::Parameterizable;
  BEGIN {
    $Moose::Meta::TypeConstraint::Parameterizable::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::TypeConstraint::Parameterizable::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  use metaclass;
  
  use base 'Moose::Meta::TypeConstraint';
  use Moose::Meta::TypeConstraint::Parameterized;
  use Moose::Util::TypeConstraints ();
  
  use Carp 'confess';
  
  __PACKAGE__->meta->add_attribute('constraint_generator' => (
      accessor  => 'constraint_generator',
      predicate => 'has_constraint_generator',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('inline_generator' => (
      accessor  => 'inline_generator',
      predicate => 'has_inline_generator',
      Class::MOP::_definition_context(),
  ));
  
  sub generate_constraint_for {
      my ($self, $type) = @_;
  
      return unless $self->has_constraint_generator;
  
      return $self->constraint_generator->($type->type_parameter)
          if $type->is_subtype_of($self->name);
  
      return $self->_can_coerce_constraint_from($type)
          if $self->has_coercion
          && $self->coercion->has_coercion_for_type($type->parent->name);
  
      return;
  }
  
  sub _can_coerce_constraint_from {
      my ($self, $type) = @_;
      my $coercion   = $self->coercion;
      my $constraint = $self->constraint_generator->($type->type_parameter);
      return sub {
          local $_ = $coercion->coerce($_);
          $constraint->(@_);
      };
  }
  
  sub generate_inline_for {
      my ($self, $type, $val) = @_;
  
      confess "Can't generate an inline constraint for $type, since none "
            . "was defined"
          unless $self->has_inline_generator;
  
      return '( do { ' . $self->inline_generator->( $self, $type, $val ) . ' } )';
  }
  
  sub _parse_type_parameter {
      my ($self, $type_parameter) = @_;
      return Moose::Util::TypeConstraints::find_or_create_isa_type_constraint($type_parameter);
  }
  
  sub parameterize {
      my ($self, $type_parameter) = @_;
  
      my $contained_tc = $self->_parse_type_parameter($type_parameter);
  
      ## The type parameter should be a subtype of the parent's type parameter
      ## if there is one.
  
      if(my $parent = $self->parent) {
          if($parent->can('type_parameter')) {
              unless ( $contained_tc->is_a_type_of($parent->type_parameter) ) {
                  require Moose;
                  Moose->throw_error("$type_parameter is not a subtype of ".$parent->type_parameter);
              }
          }
      }
  
      if ( $contained_tc->isa('Moose::Meta::TypeConstraint') ) {
          my $tc_name = $self->name . '[' . $contained_tc->name . ']';
          return Moose::Meta::TypeConstraint::Parameterized->new(
              name               => $tc_name,
              parent             => $self,
              type_parameter     => $contained_tc,
              parameterized_from => $self,
          );
      }
      else {
          require Moose;
          Moose->throw_error("The type parameter must be a Moose meta type");
      }
  }
  
  
  1;
  
  # ABSTRACT: Type constraints which can take a parameter (ArrayRef)
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint::Parameterizable - Type constraints which can take a parameter (ArrayRef)
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This class represents a parameterizable type constraint. This is a
  type constraint like C<ArrayRef> or C<HashRef>, that can be
  parameterized and made more specific by specifying a contained
  type. For example, instead of just an C<ArrayRef> of anything, you can
  specify that is an C<ArrayRef[Int]>.
  
  A parameterizable constraint should not be used as an attribute type
  constraint. Instead, when parameterized it creates a
  L<Moose::Meta::TypeConstraint::Parameterized> which should be used.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint::Parameterizable> is a subclass of
  L<Moose::Meta::TypeConstraint>.
  
  =head1 METHODS
  
  This class is intentionally not documented because the API is
  confusing and needs some work.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
  
I686-LINUX_MOOSE_META_TYPECONSTRAINT_PARAMETERIZABLE

$fatpacked{"i686-linux/Moose/Meta/TypeConstraint/Parameterized.pm"} = <<'I686-LINUX_MOOSE_META_TYPECONSTRAINT_PARAMETERIZED';
  package Moose::Meta::TypeConstraint::Parameterized;
  BEGIN {
    $Moose::Meta::TypeConstraint::Parameterized::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::TypeConstraint::Parameterized::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  use metaclass;
  
  use Scalar::Util 'blessed';
  use Moose::Util::TypeConstraints;
  use Moose::Meta::TypeConstraint::Parameterizable;
  
  use base 'Moose::Meta::TypeConstraint';
  
  __PACKAGE__->meta->add_attribute('type_parameter' => (
      accessor  => 'type_parameter',
      predicate => 'has_type_parameter',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('parameterized_from' => (
      accessor   => 'parameterized_from',
      predicate  => 'has_parameterized_from',
      Class::MOP::_definition_context(),
  ));
  
  sub equals {
      my ( $self, $type_or_name ) = @_;
  
      my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
  
      return unless $other->isa(__PACKAGE__);
  
      return (
          $self->type_parameter->equals( $other->type_parameter )
              and
          $self->parent->equals( $other->parent )
      );
  }
  
  sub compile_type_constraint {
      my $self = shift;
  
      unless ( $self->has_type_parameter ) {
          require Moose;
          Moose->throw_error("You cannot create a Higher Order type without a type parameter");
      }
  
      my $type_parameter = $self->type_parameter;
  
      unless ( blessed $type_parameter && $type_parameter->isa('Moose::Meta::TypeConstraint') ) {
          require Moose;
          Moose->throw_error("The type parameter must be a Moose meta type");
      }
  
      foreach my $type (Moose::Util::TypeConstraints::get_all_parameterizable_types()) {
          if (my $constraint = $type->generate_constraint_for($self)) {
              $self->_set_constraint($constraint);
              return $self->SUPER::compile_type_constraint;
          }
      }
  
      # if we get here, then we couldn't
      # find a way to parameterize this type
      require Moose;
      Moose->throw_error("The " . $self->name . " constraint cannot be used, because "
            . $self->parent->name . " doesn't subtype or coerce from a parameterizable type.");
  }
  
  sub can_be_inlined {
      my $self = shift;
  
      return
             $self->has_parameterized_from
          && $self->parameterized_from->has_inline_generator
          && $self->type_parameter->can_be_inlined;
  }
  
  sub inline_environment {
      my $self = shift;
  
      return {
          ($self->has_parameterized_from
              ? (%{ $self->parameterized_from->inline_environment })
              : ()),
          ($self->has_type_parameter
              ? (%{ $self->type_parameter->inline_environment })
              : ()),
      };
  }
  
  sub _inline_check {
      my $self = shift;
  
      return unless $self->can_be_inlined;
  
      return $self->parameterized_from->generate_inline_for( $self->type_parameter, @_ );
  }
  
  sub create_child_type {
      my ($self, %opts) = @_;
      return Moose::Meta::TypeConstraint::Parameterizable->new(%opts, parent=>$self);
  }
  
  1;
  
  # ABSTRACT: Type constraints with a bound parameter (ArrayRef[Int])
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint::Parameterized - Type constraints with a bound parameter (ArrayRef[Int])
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 METHODS
  
  This class is intentionally not documented because the API is
  confusing and needs some work.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint::Parameterized> is a subclass of
  L<Moose::Meta::TypeConstraint>.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
  
I686-LINUX_MOOSE_META_TYPECONSTRAINT_PARAMETERIZED

$fatpacked{"i686-linux/Moose/Meta/TypeConstraint/Registry.pm"} = <<'I686-LINUX_MOOSE_META_TYPECONSTRAINT_REGISTRY';
  
  package Moose::Meta::TypeConstraint::Registry;
  BEGIN {
    $Moose::Meta::TypeConstraint::Registry::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::TypeConstraint::Registry::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  use metaclass;
  
  use Scalar::Util 'blessed';
  
  use base 'Class::MOP::Object';
  
  __PACKAGE__->meta->add_attribute('parent_registry' => (
      reader    => 'get_parent_registry',
      writer    => 'set_parent_registry',
      predicate => 'has_parent_registry',
      Class::MOP::_definition_context(),
  ));
  
  __PACKAGE__->meta->add_attribute('type_constraints' => (
      reader  => 'type_constraints',
      default => sub { {} },
      Class::MOP::_definition_context(),
  ));
  
  sub new {
      my $class = shift;
      my $self  = $class->_new(@_);
      return $self;
  }
  
  sub has_type_constraint {
      my ($self, $type_name) = @_;
      ($type_name and exists $self->type_constraints->{$type_name}) ? 1 : 0
  }
  
  sub get_type_constraint {
      my ($self, $type_name) = @_;
      return unless defined $type_name;
      $self->type_constraints->{$type_name}
  }
  
  sub add_type_constraint {
      my ($self, $type) = @_;
  
      unless ( $type && blessed $type && $type->isa('Moose::Meta::TypeConstraint') ) {
          require Moose;
          Moose->throw_error("No type supplied / type is not a valid type constraint");
      }
  
      $self->type_constraints->{$type->name} = $type;
  }
  
  sub find_type_constraint {
      my ($self, $type_name) = @_;
      return $self->get_type_constraint($type_name)
          if $self->has_type_constraint($type_name);
      return $self->get_parent_registry->find_type_constraint($type_name)
          if $self->has_parent_registry;
      return;
  }
  
  1;
  
  # ABSTRACT: registry for type constraints
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint::Registry - registry for type constraints
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This class is a registry that maps type constraint names to
  L<Moose::Meta::TypeConstraint> objects.
  
  Currently, it is only used internally by
  L<Moose::Util::TypeConstraints>, which creates a single global
  registry.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint::Registry> is a subclass of
  L<Class::MOP::Object>.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Moose::Meta::TypeConstraint::Registry->new(%options) >>
  
  This creates a new registry object based on the provided C<%options>:
  
  =over 8
  
  =item * parent_registry
  
  This is an optional L<Moose::Meta::TypeConstraint::Registry>
  object.
  
  =item * type_constraints
  
  This is hash reference of type names to type objects. This is
  optional. Constraints can be added to the registry after it is
  created.
  
  =back
  
  =item B<< $registry->get_parent_registry >>
  
  Returns the registry's parent registry, if it has one.
  
  =item B<< $registry->has_parent_registry >>
  
  Returns true if the registry has a parent.
  
  =item B<< $registry->set_parent_registry($registry) >>
  
  Sets the parent registry.
  
  =item B<< $registry->get_type_constraint($type_name) >>
  
  This returns the L<Moose::Meta::TypeConstraint> object from the
  registry for the given name, if one exists.
  
  =item B<< $registry->has_type_constraint($type_name) >>
  
  Returns true if the registry has a type of the given name.
  
  =item B<< $registry->add_type_constraint($type) >>
  
  Adds a new L<Moose::Meta::TypeConstraint> object to the registry.
  
  =item B<< $registry->find_type_constraint($type_name) >>
  
  This method looks in the current registry for the named type. If the
  type is not found, then this method will look in the registry's
  parent, if it has one.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
  
I686-LINUX_MOOSE_META_TYPECONSTRAINT_REGISTRY

$fatpacked{"i686-linux/Moose/Meta/TypeConstraint/Role.pm"} = <<'I686-LINUX_MOOSE_META_TYPECONSTRAINT_ROLE';
  package Moose::Meta::TypeConstraint::Role;
  BEGIN {
    $Moose::Meta::TypeConstraint::Role::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::TypeConstraint::Role::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  use metaclass;
  
  use B;
  use Scalar::Util 'blessed';
  use Moose::Util::TypeConstraints ();
  
  use base 'Moose::Meta::TypeConstraint';
  
  __PACKAGE__->meta->add_attribute('role' => (
      reader => 'role',
      Class::MOP::_definition_context(),
  ));
  
  my $inliner = sub {
      my $self = shift;
      my $val  = shift;
  
      return 'Moose::Util::does_role('
               . $val . ', '
               . B::perlstring($self->role)
           . ')';
  };
  
  sub new {
      my ( $class, %args ) = @_;
  
      $args{parent} = Moose::Util::TypeConstraints::find_type_constraint('Object');
  
      my $role_name = $args{role};
      $args{constraint} = sub { Moose::Util::does_role( $_[0], $role_name ) };
  
      $args{inlined} = $inliner;
  
      my $self = $class->SUPER::new( \%args );
  
      $self->_create_hand_optimized_type_constraint;
      $self->compile_type_constraint();
  
      return $self;
  }
  
  sub _create_hand_optimized_type_constraint {
      my $self = shift;
      my $role = $self->role;
      $self->hand_optimized_type_constraint(
          sub { Moose::Util::does_role($_[0], $role) }
      );
  }
  
  sub parents {
      my $self = shift;
      return (
          $self->parent,
          map {
              # FIXME find_type_constraint might find a TC named after the role but that isn't really it
              # I did this anyway since it's a convention that preceded TypeConstraint::Role, and it should DWIM
              # if anybody thinks this problematic please discuss on IRC.
              # a possible fix is to add by attr indexing to the type registry to find types of a certain property
              # regardless of their name
              Moose::Util::TypeConstraints::find_type_constraint($_)
                  ||
              __PACKAGE__->new( role => $_, name => "__ANON__" )
          } @{ Class::MOP::class_of($self->role)->get_roles },
      );
  }
  
  sub equals {
      my ( $self, $type_or_name ) = @_;
  
      my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
  
      return unless defined $other;
      return unless $other->isa(__PACKAGE__);
  
      return $self->role eq $other->role;
  }
  
  sub is_a_type_of {
      my ($self, $type_or_name) = @_;
  
      my $type = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
  
      ($self->equals($type) || $self->is_subtype_of($type_or_name));
  }
  
  sub is_subtype_of {
      my ($self, $type_or_name_or_role ) = @_;
  
      if ( not ref $type_or_name_or_role ) {
          # it might be a role
          return 1 if Class::MOP::class_of($self->role)->does_role( $type_or_name_or_role );
      }
  
      my $type = Moose::Util::TypeConstraints::find_type_constraint($type_or_name_or_role);
  
      return unless defined $type;
  
      if ( $type->isa(__PACKAGE__) ) {
          # if $type_or_name_or_role isn't a role, it might be the TC name of another ::Role type
          # or it could also just be a type object in this branch
          return Class::MOP::class_of($self->role)->does_role( $type->role );
      } else {
          # the only other thing we are a subtype of is Object
          $self->SUPER::is_subtype_of($type);
      }
  }
  
  sub create_child_type {
      my ($self, @args) = @_;
      return Moose::Meta::TypeConstraint->new(@args, parent => $self);
  }
  
  1;
  
  # ABSTRACT: Role/TypeConstraint parallel hierarchy
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint::Role - Role/TypeConstraint parallel hierarchy
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This class represents type constraints for a role.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint::Role> is a subclass of
  L<Moose::Meta::TypeConstraint>.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Moose::Meta::TypeConstraint::Role->new(%options) >>
  
  This creates a new role type constraint based on the given
  C<%options>.
  
  It takes the same options as its parent, with two exceptions. First,
  it requires an additional option, C<role>, which is name of the
  constraint's role.  Second, it automatically sets the parent to the
  C<Object> type.
  
  The constructor also overrides the hand optimized type constraint with
  one it creates internally.
  
  =item B<< $constraint->role >>
  
  Returns the role name associated with the constraint.
  
  =item B<< $constraint->parents >>
  
  Returns all the type's parent types, corresponding to the roles that
  its role does.
  
  =item B<< $constraint->is_subtype_of($type_name_or_object) >>
  
  If the given type is also a role type, then this checks that the
  type's role does the other type's role.
  
  Otherwise it falls back to the implementation in
  L<Moose::Meta::TypeConstraint>.
  
  =item B<< $constraint->create_child_type(%options) >>
  
  This returns a new L<Moose::Meta::TypeConstraint> object with the type
  as its parent.
  
  Note that it does I<not> return a C<Moose::Meta::TypeConstraint::Role>
  object!
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_META_TYPECONSTRAINT_ROLE

$fatpacked{"i686-linux/Moose/Meta/TypeConstraint/Union.pm"} = <<'I686-LINUX_MOOSE_META_TYPECONSTRAINT_UNION';
  
  package Moose::Meta::TypeConstraint::Union;
  BEGIN {
    $Moose::Meta::TypeConstraint::Union::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Meta::TypeConstraint::Union::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  use metaclass;
  
  use Moose::Meta::TypeCoercion::Union;
  
  use List::MoreUtils qw(all);
  use List::Util qw(first);
  
  use base 'Moose::Meta::TypeConstraint';
  
  __PACKAGE__->meta->add_attribute('type_constraints' => (
      accessor  => 'type_constraints',
      default   => sub { [] },
      Class::MOP::_definition_context(),
  ));
  
  sub new {
      my ($class, %options) = @_;
  
      my $name = join '|' => sort { $a cmp $b }
          map { $_->name } @{ $options{type_constraints} };
  
      my $self = $class->SUPER::new(
          name => $name,
          %options,
      );
  
      $self->_set_constraint(sub { $self->check($_[0]) });
  
      return $self;
  }
  
  # XXX - this is a rather gross implementation of laziness for the benefit of
  # MX::Types. If we try to call ->has_coercion on the objects during object
  # construction, this does not work when defining a recursive constraint with
  # MX::Types.
  sub coercion {
      my $self = shift;
  
      return $self->{coercion} if exists $self->{coercion};
  
      # Using any instead of grep here causes a weird error with some corner
      # cases when MX::Types is in use. See RT #61001.
      if ( grep { $_->has_coercion } @{ $self->type_constraints } ) {
          return $self->{coercion} = Moose::Meta::TypeCoercion::Union->new(
              type_constraint => $self );
      }
      else {
          return $self->{coercion} = undef;
      }
  }
  
  sub has_coercion {
      return defined $_[0]->coercion;
  }
  
  sub _actually_compile_type_constraint {
      my $self = shift;
  
      my @constraints = @{ $self->type_constraints };
  
      return sub {
          my $value = shift;
          foreach my $type (@constraints) {
              return 1 if $type->check($value);
          }
          return undef;
      };
  }
  
  sub can_be_inlined {
      my $self = shift;
  
      # This was originally done with all() from List::MoreUtils, but that
      # caused some sort of bizarro parsing failure under 5.10.
      for my $tc ( @{ $self->type_constraints } ) {
          return 0 unless $tc->can_be_inlined;
      }
  
      return 1;
  }
  
  sub _inline_check {
      my $self = shift;
      my $val  = shift;
  
      return '('
                 . (
                    join ' || ', map { '(' . $_->_inline_check($val) . ')' }
                    @{ $self->type_constraints }
                   )
             . ')';
  }
  
  sub inline_environment {
      my $self = shift;
  
      return { map { %{ $_->inline_environment } }
              @{ $self->type_constraints } };
  }
  
  sub equals {
      my ( $self, $type_or_name ) = @_;
  
      my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
  
      return unless $other->isa(__PACKAGE__);
  
      my @self_constraints  = @{ $self->type_constraints };
      my @other_constraints = @{ $other->type_constraints };
  
      return unless @self_constraints == @other_constraints;
  
      # FIXME presort type constraints for efficiency?
      constraint: foreach my $constraint ( @self_constraints ) {
          for ( my $i = 0; $i < @other_constraints; $i++ ) {
              if ( $constraint->equals($other_constraints[$i]) ) {
                  splice @other_constraints, $i, 1;
                  next constraint;
              }
          }
      }
  
      return @other_constraints == 0;
  }
  
  sub parent {
      my $self = shift;
  
      my ($first, @rest) = @{ $self->type_constraints };
  
      for my $parent ( $first->_collect_all_parents ) {
          return $parent if all { $_->is_a_type_of($parent) } @rest;
      }
  
      return;
  }
  
  sub validate {
      my ($self, $value) = @_;
      my $message;
      foreach my $type (@{$self->type_constraints}) {
          my $err = $type->validate($value);
          return unless defined $err;
          $message .= ($message ? ' and ' : '') . $err
              if defined $err;
      }
      return ($message . ' in (' . $self->name . ')') ;
  }
  
  sub find_type_for {
      my ($self, $value) = @_;
  
      return first { $_->check($value) } @{ $self->type_constraints };
  }
  
  sub is_a_type_of {
      my ($self, $type_name) = @_;
  
      return all { $_->is_a_type_of($type_name) } @{ $self->type_constraints };
  }
  
  sub is_subtype_of {
      my ($self, $type_name) = @_;
  
      return all { $_->is_subtype_of($type_name) } @{ $self->type_constraints };
  }
  
  sub create_child_type {
      my ( $self, %opts ) = @_;
  
      my $constraint
          = Moose::Meta::TypeConstraint->new( %opts, parent => $self );
  
      # if we have a type constraint union, and no
      # type check, this means we are just aliasing
      # the union constraint, which means we need to
      # handle this differently.
      # - SL
      if ( not( defined $opts{constraint} )
          && $self->has_coercion ) {
          $constraint->coercion(
              Moose::Meta::TypeCoercion::Union->new(
                  type_constraint => $self,
              )
          );
      }
  
      return $constraint;
  }
  
  1;
  
  # ABSTRACT: A union of Moose type constraints
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Meta::TypeConstraint::Union - A union of Moose type constraints
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This metaclass represents a union of type constraints. A union takes
  multiple type constraints, and is true if any one of its member
  constraints is true.
  
  =head1 INHERITANCE
  
  C<Moose::Meta::TypeConstraint::Union> is a subclass of
  L<Moose::Meta::TypeConstraint>.
  
  =over 4
  
  =item B<< Moose::Meta::TypeConstraint::Union->new(%options) >>
  
  This creates a new class type constraint based on the given
  C<%options>.
  
  It takes the same options as its parent. It also requires an
  additional option, C<type_constraints>. This is an array reference
  containing the L<Moose::Meta::TypeConstraint> objects that are the
  members of the union type. The C<name> option defaults to the names
  all of these member types sorted and then joined by a pipe (|).
  
  The constructor sets the implementation of the constraint so that is
  simply calls C<check> on the newly created object.
  
  Finally, the constructor also makes sure that the object's C<coercion>
  attribute is a L<Moose::Meta::TypeCoercion::Union> object.
  
  =item B<< $constraint->type_constraints >>
  
  This returns the array reference of C<type_constraints> provided to
  the constructor.
  
  =item B<< $constraint->parent >>
  
  This returns the nearest common ancestor of all the components of the union.
  
  =item B<< $constraint->check($value) >>
  
  =item B<< $constraint->validate($value) >>
  
  These two methods simply call the relevant method on each of the
  member type constraints in the union. If any type accepts the value,
  the value is valid.
  
  With C<validate> the error message returned includes all of the error
  messages returned by the member type constraints.
  
  =item B<< $constraint->equals($type_name_or_object) >>
  
  A type is considered equal if it is also a union type, and the two
  unions have the same member types.
  
  =item B<< $constraint->find_type_for($value) >>
  
  This returns the first member type constraint for which C<check($value)> is
  true, allowing you to determine which of the Union's member type constraints
  a given value matches.
  
  =item B<< $constraint->is_a_type_of($type_name_or_object) >>
  
  This returns true if all of the member type constraints return true
  for the C<is_a_type_of> method.
  
  =item B<< $constraint->is_subtype_of >>
  
  This returns true if all of the member type constraints return true
  for the C<is_a_subtype_of> method.
  
  =item B<< $constraint->create_child_type(%options) >>
  
  This returns a new L<Moose::Meta::TypeConstraint> object with the type
  as its parent.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_META_TYPECONSTRAINT_UNION

$fatpacked{"i686-linux/Moose/Object.pm"} = <<'I686-LINUX_MOOSE_OBJECT';
  
  package Moose::Object;
  BEGIN {
    $Moose::Object::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Object::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Carp ();
  use Devel::GlobalDestruction ();
  use MRO::Compat ();
  use Scalar::Util ();
  use Try::Tiny ();
  
  use if ( not our $__mx_is_compiled ), 'Moose::Meta::Class';
  use if ( not our $__mx_is_compiled ), metaclass => 'Moose::Meta::Class';
  
  sub new {
      my $class = shift;
      my $real_class = Scalar::Util::blessed($class) || $class;
  
      my $params = $real_class->BUILDARGS(@_);
  
      return Class::MOP::Class->initialize($real_class)->new_object($params);
  }
  
  sub BUILDARGS {
      my $class = shift;
      if ( scalar @_ == 1 ) {
          unless ( defined $_[0] && ref $_[0] eq 'HASH' ) {
              Class::MOP::class_of($class)->throw_error(
                  "Single parameters to new() must be a HASH ref",
                  data => $_[0] );
          }
          return { %{ $_[0] } };
      }
      elsif ( @_ % 2 ) {
          Carp::carp(
              "The new() method for $class expects a hash reference or a key/value list."
                  . " You passed an odd number of arguments" );
          return { @_, undef };
      }
      else {
          return {@_};
      }
  }
  
  sub BUILDALL {
      # NOTE: we ask Perl if we even
      # need to do this first, to avoid
      # extra meta level calls
      return unless $_[0]->can('BUILD');
      my ($self, $params) = @_;
      foreach my $method (reverse Class::MOP::class_of($self)->find_all_methods_by_name('BUILD')) {
          $method->{code}->execute($self, $params);
      }
  }
  
  sub DEMOLISHALL {
      my $self = shift;
      my ($in_global_destruction) = @_;
  
      # NOTE: we ask Perl if we even
      # need to do this first, to avoid
      # extra meta level calls
      return unless $self->can('DEMOLISH');
  
      my @isa;
      if ( my $meta = Class::MOP::class_of($self ) ) {
          @isa = $meta->linearized_isa;
      } else {
          # We cannot count on being able to retrieve a previously made
          # metaclass, _or_ being able to make a new one during global
          # destruction. However, we should still be able to use mro at
          # that time (at least tests suggest so ;)
          my $class_name = ref $self;
          @isa = @{ mro::get_linear_isa($class_name) }
      }
  
      foreach my $class (@isa) {
          no strict 'refs';
          my $demolish = *{"${class}::DEMOLISH"}{CODE};
          $self->$demolish($in_global_destruction)
              if defined $demolish;
      }
  }
  
  sub DESTROY {
      my $self = shift;
  
      local $?;
  
      Try::Tiny::try {
          $self->DEMOLISHALL(Devel::GlobalDestruction::in_global_destruction);
      }
      Try::Tiny::catch {
          die $_;
      };
  
      return;
  }
  
  # support for UNIVERSAL::DOES ...
  BEGIN {
      my $does = UNIVERSAL->can("DOES") ? "SUPER::DOES" : "isa";
      eval 'sub DOES {
          my ( $self, $class_or_role_name ) = @_;
          return $self->'.$does.'($class_or_role_name)
              || $self->does($class_or_role_name);
      }';
  }
  
  # new does() methods will be created
  # as appropiate see Moose::Meta::Role
  sub does {
      my ($self, $role_name) = @_;
      my $class = Scalar::Util::blessed($self) || $self;
      my $meta = Class::MOP::Class->initialize($class);
      (defined $role_name)
          || $meta->throw_error("You must supply a role name to does()");
      return 1 if $meta->can('does_role') && $meta->does_role($role_name);
      return 0;
  }
  
  sub dump {
      my $self = shift;
      require Data::Dumper;
      local $Data::Dumper::Maxdepth = shift if @_;
      Data::Dumper::Dumper $self;
  }
  
  1;
  
  # ABSTRACT: The base object for Moose
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Object - The base object for Moose
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 DESCRIPTION
  
  This class is the default base class for all Moose-using classes. When
  you C<use Moose> in this class, your class will inherit from this
  class.
  
  It provides a default constructor and destructor, which run all of the
  C<BUILD> and C<DEMOLISH> methods in the inheritance hierarchy,
  respectively.
  
  You don't actually I<need> to inherit from this in order to use Moose,
  but it makes it easier to take advantage of all of Moose's features.
  
  =head1 METHODS
  
  =over 4
  
  =item B<< Moose::Object->new(%params|$params) >>
  
  This method calls C<< $class->BUILDARGS(@_) >>, and then creates a new
  instance of the appropriate class. Once the instance is created, it
  calls C<< $instance->BUILD($params) >> for each C<BUILD> method in the
  inheritance hierarchy.
  
  =item B<< Moose::Object->BUILDARGS(%params|$params) >>
  
  The default implementation of this method accepts a hash or hash
  reference of named parameters. If it receives a single argument that
  I<isn't> a hash reference it throws an error.
  
  You can override this method in your class to handle other types of
  options passed to the constructor.
  
  This method should always return a hash reference of named options.
  
  =item B<< $object->does($role_name) >>
  
  This returns true if the object does the given role.
  
  =item B<< $object->DOES($class_or_role_name) >>
  
  This is a a Moose role-aware implementation of L<UNIVERSAL/DOES>.
  
  This is effectively the same as writing:
  
    $object->does($name) || $object->isa($name)
  
  This method will work with Perl 5.8, which did not implement
  C<UNIVERSAL::DOES>.
  
  =item B<< $object->dump($maxdepth) >>
  
  This is a handy utility for C<Data::Dumper>ing an object. By default,
  the maximum depth is 1, to avoid making a mess.
  
  =item B<< $object->DESTROY >>
  
  A default destructor is provided, which calls
  C<< $instance->DEMOLISH($in_global_destruction) >> for each C<DEMOLISH>
  method in the inheritance hierarchy.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_OBJECT

$fatpacked{"i686-linux/Moose/Role.pm"} = <<'I686-LINUX_MOOSE_ROLE';
  package Moose::Role;
  BEGIN {
    $Moose::Role::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Role::VERSION = '2.0401';
  }
  use strict;
  use warnings;
  
  use Scalar::Util 'blessed';
  use Carp         'croak';
  use Class::Load  'is_class_loaded';
  
  use Sub::Exporter;
  
  use Moose       ();
  use Moose::Util ();
  
  use Moose::Exporter;
  use Moose::Meta::Role;
  use Moose::Util::TypeConstraints;
  
  sub extends {
      croak "Roles do not support 'extends' (you can use 'with' to specialize a role)";
  }
  
  sub with {
      Moose::Util::apply_all_roles( shift, @_ );
  }
  
  sub requires {
      my $meta = shift;
      croak "Must specify at least one method" unless @_;
      $meta->add_required_methods(@_);
  }
  
  sub excludes {
      my $meta = shift;
      croak "Must specify at least one role" unless @_;
      $meta->add_excluded_roles(@_);
  }
  
  sub has {
      my $meta = shift;
      my $name = shift;
      croak 'Usage: has \'name\' => ( key => value, ... )' if @_ == 1;
      my %options = ( definition_context => Moose::Util::_caller_info(), @_ );
      my $attrs = ( ref($name) eq 'ARRAY' ) ? $name : [ ($name) ];
      $meta->add_attribute( $_, %options ) for @$attrs;
  }
  
  sub _add_method_modifier {
      my $type = shift;
      my $meta = shift;
  
      if ( ref($_[0]) eq 'Regexp' ) {
          croak "Roles do not currently support regex "
              . " references for $type method modifiers";
      }
  
      Moose::Util::add_method_modifier($meta, $type, \@_);
  }
  
  sub before { _add_method_modifier('before', @_) }
  
  sub after  { _add_method_modifier('after',  @_) }
  
  sub around { _add_method_modifier('around', @_) }
  
  # see Moose.pm for discussion
  sub super {
      return unless $Moose::SUPER_BODY;
      $Moose::SUPER_BODY->(@Moose::SUPER_ARGS);
  }
  
  sub override {
      my $meta = shift;
      my ( $name, $code ) = @_;
      $meta->add_override_method_modifier( $name, $code );
  }
  
  sub inner {
      croak "Roles cannot support 'inner'";
  }
  
  sub augment {
      croak "Roles cannot support 'augment'";
  }
  
  Moose::Exporter->setup_import_methods(
      with_meta => [
          qw( with requires excludes has before after around override )
      ],
      as_is => [
          qw( extends super inner augment ),
          \&Carp::confess,
          \&Scalar::Util::blessed,
      ],
  );
  
  sub init_meta {
      shift;
      my %args = @_;
  
      my $role = $args{for_class};
  
      unless ($role) {
          require Moose;
          Moose->throw_error("Cannot call init_meta without specifying a for_class");
      }
  
      my $metaclass = $args{metaclass} || "Moose::Meta::Role";
      my $meta_name = exists $args{meta_name} ? $args{meta_name} : 'meta';
  
      Moose->throw_error("The Metaclass $metaclass must be loaded. (Perhaps you forgot to 'use $metaclass'?)")
          unless is_class_loaded($metaclass);
  
      Moose->throw_error("The Metaclass $metaclass must be a subclass of Moose::Meta::Role.")
          unless $metaclass->isa('Moose::Meta::Role');
  
      # make a subtype for each Moose role
      role_type $role unless find_type_constraint($role);
  
      my $meta;
      if ( $meta = Class::MOP::get_metaclass_by_name($role) ) {
          unless ( $meta->isa("Moose::Meta::Role") ) {
              my $error_message = "$role already has a metaclass, but it does not inherit $metaclass ($meta).";
              if ( $meta->isa('Moose::Meta::Class') ) {
                  Moose->throw_error($error_message . ' You cannot make the same thing a role and a class. Remove either Moose or Moose::Role.');
              } else {
                  Moose->throw_error($error_message);
              }
          }
      }
      else {
          $meta = $metaclass->initialize($role);
      }
  
      if (defined $meta_name) {
          # also check for inherited non moose 'meta' method?
          my $existing = $meta->get_method($meta_name);
          if ($existing && !$existing->isa('Class::MOP::Method::Meta')) {
              Carp::cluck "Moose::Role is overwriting an existing method named "
                        . "$meta_name in role $role with a method "
                        . "which returns the class's metaclass. If this is "
                        . "actually what you want, you should remove the "
                        . "existing method, otherwise, you should rename or "
                        . "disable this generated method using the "
                        . "'-meta_name' option to 'use Moose::Role'.";
          }
          $meta->_add_meta_method($meta_name);
      }
  
      return $meta;
  }
  
  1;
  
  # ABSTRACT: The Moose Role
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Role - The Moose Role
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 SYNOPSIS
  
    package Eq;
    use Moose::Role; # automatically turns on strict and warnings
  
    requires 'equal';
  
    sub no_equal {
        my ($self, $other) = @_;
        !$self->equal($other);
    }
  
    # ... then in your classes
  
    package Currency;
    use Moose; # automatically turns on strict and warnings
  
    with 'Eq';
  
    sub equal {
        my ($self, $other) = @_;
        $self->as_float == $other->as_float;
    }
  
    # ... and also
  
    package Comparator;
    use Moose;
  
    has compare_to => (
        is      => 'ro',
        does    => 'Eq',
        handles => 'Eq',
    );
  
    # ... which allows
  
    my $currency1 = Currency->new(...);
    my $currency2 = Currency->new(...);
    Comparator->new(compare_to => $currency1)->equal($currency2);
  
  =head1 DESCRIPTION
  
  The concept of roles is documented in L<Moose::Manual::Roles>. This document
  serves as API documentation.
  
  =head1 EXPORTED FUNCTIONS
  
  Moose::Role currently supports all of the functions that L<Moose> exports, but
  differs slightly in how some items are handled (see L</CAVEATS> below for
  details).
  
  Moose::Role also offers two role-specific keyword exports:
  
  =over 4
  
  =item B<requires (@method_names)>
  
  Roles can require that certain methods are implemented by any class which
  C<does> the role.
  
  Note that attribute accessors also count as methods for the purposes
  of satisfying the requirements of a role.
  
  =item B<excludes (@role_names)>
  
  Roles can C<exclude> other roles, in effect saying "I can never be combined
  with these C<@role_names>". This is a feature which should not be used
  lightly.
  
  =back
  
  =head2 B<unimport>
  
  Moose::Role offers a way to remove the keywords it exports, through the
  C<unimport> method. You simply have to say C<no Moose::Role> at the bottom of
  your code for this to work.
  
  =head1 METACLASS
  
  When you use Moose::Role, you can specify traits which will be applied to your
  role metaclass:
  
      use Moose::Role -traits => 'My::Trait';
  
  This is very similar to the attribute traits feature. When you do
  this, your class's C<meta> object will have the specified traits
  applied to it. See L<Moose/Metaclass and Trait Name Resolution> for more
  details.
  
  =head1 APPLYING ROLES
  
  In addition to being applied to a class using the 'with' syntax (see
  L<Moose::Manual::Roles>) and using the L<Moose::Util> 'apply_all_roles'
  method, roles may also be applied to an instance of a class using
  L<Moose::Util> 'apply_all_roles' or the role's metaclass:
  
     MyApp::Test::SomeRole->meta->apply( $instance );
  
  Doing this creates a new, mutable, anonymous subclass, applies the role to that,
  and reblesses. In a debugger, for example, you will see class names of the
  form C< Moose::Meta::Class::__ANON__::SERIAL::6 >, which means that doing a
  'ref' on your instance may not return what you expect. See L<Moose::Object> for
  'DOES'.
  
  Additional params may be added to the new instance by providing
  'rebless_params'. See L<Moose::Meta::Role::Application::ToInstance>.
  
  =head1 CAVEATS
  
  Role support has only a few caveats:
  
  =over 4
  
  =item *
  
  Roles cannot use the C<extends> keyword; it will throw an exception for now.
  The same is true of the C<augment> and C<inner> keywords (not sure those
  really make sense for roles). All other Moose keywords will be I<deferred>
  so that they can be applied to the consuming class.
  
  =item *
  
  Role composition does its best to B<not> be order-sensitive when it comes to
  conflict resolution and requirements detection. However, it is order-sensitive
  when it comes to method modifiers. All before/around/after modifiers are
  included whenever a role is composed into a class, and then applied in the order
  in which the roles are used. This also means that there is no conflict for
  before/around/after modifiers.
  
  In most cases, this will be a non-issue; however, it is something to keep in
  mind when using method modifiers in a role. You should never assume any
  ordering.
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_ROLE

$fatpacked{"i686-linux/Moose/Util.pm"} = <<'I686-LINUX_MOOSE_UTIL';
  package Moose::Util;
  BEGIN {
    $Moose::Util::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Util::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Class::Load qw(load_class load_first_existing_class);
  use Data::OptList;
  use Params::Util qw( _STRING );
  use Sub::Exporter;
  use Scalar::Util 'blessed';
  use List::Util qw(first);
  use List::MoreUtils qw(any all);
  use overload ();
  use Try::Tiny;
  use Class::MOP;
  
  my @exports = qw[
      find_meta
      does_role
      search_class_by_role
      ensure_all_roles
      apply_all_roles
      with_traits
      get_all_init_args
      get_all_attribute_values
      resolve_metatrait_alias
      resolve_metaclass_alias
      add_method_modifier
      english_list
      meta_attribute_alias
      meta_class_alias
  ];
  
  Sub::Exporter::setup_exporter({
      exports => \@exports,
      groups  => { all => \@exports }
  });
  
  ## some utils for the utils ...
  
  sub find_meta { Class::MOP::class_of(@_) }
  
  ## the functions ...
  
  sub does_role {
      my ($class_or_obj, $role) = @_;
  
      if (try { $class_or_obj->isa('Moose::Object') }) {
          return $class_or_obj->does($role);
      }
  
      my $meta = find_meta($class_or_obj);
  
      return unless defined $meta;
      return unless $meta->can('does_role');
      return 1 if $meta->does_role($role);
      return;
  }
  
  sub search_class_by_role {
      my ($class_or_obj, $role) = @_;
  
      my $meta = find_meta($class_or_obj);
  
      return unless defined $meta;
  
      my $role_name = blessed $role ? $role->name : $role;
  
      foreach my $class ($meta->class_precedence_list) {
  
          my $_meta = find_meta($class);
  
          next unless defined $_meta;
  
          foreach my $role (@{ $_meta->roles || [] }) {
              return $class if $role->name eq $role_name;
          }
      }
  
      return;
  }
  
  # this can possibly behave in unexpected ways because the roles being composed
  # before being applied could differ from call to call; I'm not sure if or how
  # to document this possible quirk.
  sub ensure_all_roles {
      my $applicant = shift;
      _apply_all_roles($applicant, sub { !does_role($applicant, $_) }, @_);
  }
  
  sub apply_all_roles {
      my $applicant = shift;
      _apply_all_roles($applicant, undef, @_);
  }
  
  sub _apply_all_roles {
      my $applicant = shift;
      my $role_filter = shift;
  
      unless (@_) {
          require Moose;
          Moose->throw_error("Must specify at least one role to apply to $applicant");
      }
  
      # If @_ contains role meta objects, mkopt will think that they're values,
      # because they're references.  In other words (roleobj1, roleobj2,
      # roleobj3) will become [ [ roleobj1, roleobj2 ], [ roleobj3, undef ] ]
      # -- this is no good.  We'll preprocess @_ first to eliminate the potential
      # bug.
      # -- rjbs, 2011-04-08
      my $roles = Data::OptList::mkopt( [@_], {
        moniker   => 'role',
        name_test => sub {
          ! ref $_[0] or blessed($_[0]) && $_[0]->isa('Moose::Meta::Role')
        }
      });
  
      my @role_metas;
      foreach my $role (@$roles) {
          my $meta;
  
          if ( blessed $role->[0] ) {
              $meta = $role->[0];
          }
          else {
              load_class( $role->[0] , $role->[1] );
              $meta = find_meta( $role->[0] );
          }
  
          unless ($meta && $meta->isa('Moose::Meta::Role') ) {
              require Moose;
              Moose->throw_error( "You can only consume roles, "
                      . $role->[0]
                      . " is not a Moose role" );
          }
  
          push @role_metas, [ $meta, $role->[1] ];
      }
  
      if ( defined $role_filter ) {
          @role_metas = grep { local $_ = $_->[0]; $role_filter->() } @role_metas;
      }
  
      return unless @role_metas;
  
      load_class($applicant)
          unless blessed($applicant)
              || Class::MOP::class_of($applicant);
  
      my $meta = ( blessed $applicant ? $applicant : Moose::Meta::Class->initialize($applicant) );
  
      if ( scalar @role_metas == 1 ) {
          my ( $role, $params ) = @{ $role_metas[0] };
          $role->apply( $meta, ( defined $params ? %$params : () ) );
      }
      else {
          Moose::Meta::Role->combine(@role_metas)->apply($meta);
      }
  }
  
  sub with_traits {
      my ($class, @roles) = @_;
      return $class unless @roles;
      return Moose::Meta::Class->create_anon_class(
          superclasses => [$class],
          roles        => \@roles,
          cache        => 1,
      )->name;
  }
  
  # instance deconstruction ...
  
  sub get_all_attribute_values {
      my ($class, $instance) = @_;
      return +{
          map { $_->name => $_->get_value($instance) }
              grep { $_->has_value($instance) }
                  $class->get_all_attributes
      };
  }
  
  sub get_all_init_args {
      my ($class, $instance) = @_;
      return +{
          map { $_->init_arg => $_->get_value($instance) }
              grep { $_->has_value($instance) }
                  grep { defined($_->init_arg) }
                      $class->get_all_attributes
      };
  }
  
  sub resolve_metatrait_alias {
      return resolve_metaclass_alias( @_, trait => 1 );
  }
  
  sub _build_alias_package_name {
      my ($type, $name, $trait) = @_;
      return 'Moose::Meta::'
           . $type
           . '::Custom::'
           . ( $trait ? 'Trait::' : '' )
           . $name;
  }
  
  {
      my %cache;
  
      sub resolve_metaclass_alias {
          my ( $type, $metaclass_name, %options ) = @_;
  
          my $cache_key = $type . q{ } . ( $options{trait} ? '-Trait' : '' );
          return $cache{$cache_key}{$metaclass_name}
              if $cache{$cache_key}{$metaclass_name};
  
          my $possible_full_name = _build_alias_package_name(
              $type, $metaclass_name, $options{trait}
          );
  
          my $loaded_class = load_first_existing_class(
              $possible_full_name,
              $metaclass_name
          );
  
          return $cache{$cache_key}{$metaclass_name}
              = $loaded_class->can('register_implementation')
              ? $loaded_class->register_implementation
              : $loaded_class;
      }
  }
  
  sub add_method_modifier {
      my ( $class_or_obj, $modifier_name, $args ) = @_;
      my $meta
          = $class_or_obj->can('add_before_method_modifier')
          ? $class_or_obj
          : find_meta($class_or_obj);
      my $code                = pop @{$args};
      my $add_modifier_method = 'add_' . $modifier_name . '_method_modifier';
      if ( my $method_modifier_type = ref( @{$args}[0] ) ) {
          if ( $method_modifier_type eq 'Regexp' ) {
              my @all_methods = $meta->get_all_methods;
              my @matched_methods
                  = grep { $_->name =~ @{$args}[0] } @all_methods;
              $meta->$add_modifier_method( $_->name, $code )
                  for @matched_methods;
          }
          elsif ($method_modifier_type eq 'ARRAY') {
              $meta->$add_modifier_method( $_, $code ) for @{$args->[0]};
          }
          else {
              $meta->throw_error(
                  sprintf(
                      "Methods passed to %s must be provided as a list, arrayref or regex, not %s",
                      $modifier_name,
                      $method_modifier_type,
                  )
              );
          }
      }
      else {
          $meta->$add_modifier_method( $_, $code ) for @{$args};
      }
  }
  
  sub english_list {
      my @items = sort @_;
  
      return $items[0] if @items == 1;
      return "$items[0] and $items[1]" if @items == 2;
  
      my $tail = pop @items;
      my $list = join ', ', @items;
      $list .= ', and ' . $tail;
  
      return $list;
  }
  
  sub _caller_info {
      my $level = @_ ? ($_[0] + 1) : 2;
      my %info;
      @info{qw(package file line)} = caller($level);
      return \%info;
  }
  
  sub _create_alias {
      my ($type, $name, $trait, $for) = @_;
      my $package = _build_alias_package_name($type, $name, $trait);
      Class::MOP::Class->initialize($package)->add_method(
          register_implementation => sub { $for }
      );
  }
  
  sub meta_attribute_alias {
      my ($to, $from) = @_;
      $from ||= caller;
      my $meta = Class::MOP::class_of($from);
      my $trait = $meta->isa('Moose::Meta::Role');
      _create_alias('Attribute', $to, $trait, $from);
  }
  
  sub meta_class_alias {
      my ($to, $from) = @_;
      $from ||= caller;
      my $meta = Class::MOP::class_of($from);
      my $trait = $meta->isa('Moose::Meta::Role');
      _create_alias('Class', $to, $trait, $from);
  }
  
  # XXX - this should be added to Params::Util
  sub _STRINGLIKE0 ($) {
      return _STRING( $_[0] )
          || ( defined $_[0]
          && $_[0] eq q{} )
          || ( blessed $_[0]
          && overload::Method( $_[0], q{""} )
          && length "$_[0]" );
  }
  
  sub _reconcile_roles_for_metaclass {
      my ($class_meta_name, $super_meta_name) = @_;
  
      my @role_differences = _role_differences(
          $class_meta_name, $super_meta_name,
      );
  
      # handle the case where we need to fix compatibility between a class and
      # its parent, but all roles in the class are already also done by the
      # parent
      # see t/metaclasses/metaclass_compat_no_fixing_bug.t
      return $super_meta_name
          unless @role_differences;
  
      return Moose::Meta::Class->create_anon_class(
          superclasses => [$super_meta_name],
          roles        => [map { $_->name } @role_differences],
          cache        => 1,
      )->name;
  }
  
  sub _role_differences {
      my ($class_meta_name, $super_meta_name) = @_;
      my @super_role_metas
          = grep { !$_->isa('Moose::Meta::Role::Composite') }
                 $super_meta_name->meta->can('calculate_all_roles_with_inheritance')
                     ? $super_meta_name->meta->calculate_all_roles_with_inheritance
                     : $super_meta_name->meta->can('calculate_all_roles')
                     ? $super_meta_name->meta->calculate_all_roles
                     : ();
      my @role_metas
          = grep { !$_->isa('Moose::Meta::Role::Composite') }
                 $class_meta_name->meta->can('calculate_all_roles_with_inheritance')
                     ? $class_meta_name->meta->calculate_all_roles_with_inheritance
                     : $class_meta_name->meta->can('calculate_all_roles')
                     ? $class_meta_name->meta->calculate_all_roles
                     : ();
      my @differences;
      for my $role_meta (@role_metas) {
          push @differences, $role_meta
              unless any { $_->name eq $role_meta->name } @super_role_metas;
      }
      return @differences;
  }
  
  sub _classes_differ_by_roles_only {
      my ( $self_meta_name, $super_meta_name ) = @_;
  
      my $common_base_name
          = _find_common_base( $self_meta_name, $super_meta_name );
  
      return unless defined $common_base_name;
  
      my @super_meta_name_ancestor_names
          = _get_ancestors_until( $super_meta_name, $common_base_name );
      my @class_meta_name_ancestor_names
          = _get_ancestors_until( $self_meta_name, $common_base_name );
  
      return
          unless all { _is_role_only_subclass($_) }
          @super_meta_name_ancestor_names,
          @class_meta_name_ancestor_names;
  
      return 1;
  }
  
  sub _find_common_base {
      my ($meta1, $meta2) = map { Class::MOP::class_of($_) } @_;
      return unless defined $meta1 && defined $meta2;
  
      # FIXME? This doesn't account for multiple inheritance (not sure
      # if it needs to though). For example, if somewhere in $meta1's
      # history it inherits from both ClassA and ClassB, and $meta2
      # inherits from ClassB & ClassA, does it matter? And what crazy
      # fool would do that anyway?
  
      my %meta1_parents = map { $_ => 1 } $meta1->linearized_isa;
  
      return first { $meta1_parents{$_} } $meta2->linearized_isa;
  }
  
  sub _get_ancestors_until {
      my ($start_name, $until_name) = @_;
  
      my @ancestor_names;
      for my $ancestor_name (Class::MOP::class_of($start_name)->linearized_isa) {
          last if $ancestor_name eq $until_name;
          push @ancestor_names, $ancestor_name;
      }
      return @ancestor_names;
  }
  
  sub _is_role_only_subclass {
      my ($meta_name) = @_;
      my $meta = Class::MOP::Class->initialize($meta_name);
      my @parent_names = $meta->superclasses;
  
      # XXX: don't feel like messing with multiple inheritance here... what would
      # that even do?
      return unless @parent_names == 1;
      my ($parent_name) = @parent_names;
      my $parent_meta = Class::MOP::Class->initialize($parent_name);
  
      # only get the roles attached to this particular class, don't look at
      # superclasses
      my @roles = $meta->can('calculate_all_roles')
                      ? $meta->calculate_all_roles
                      : ();
  
      # it's obviously not a role-only subclass if it doesn't do any roles
      return unless @roles;
  
      # loop over all methods that are a part of the current class
      # (not inherited)
      for my $method ( $meta->_get_local_methods ) {
          # always ignore meta
          next if $method->isa('Class::MOP::Method::Meta');
          # we'll deal with attributes below
          next if $method->can('associated_attribute');
          # if the method comes from a role we consumed, ignore it
          next if $meta->can('does_role')
               && $meta->does_role($method->original_package_name);
          # FIXME - this really isn't right. Just because a modifier is
          # defined in a role doesn't mean it isn't _also_ defined in the
          # subclass.
          next if $method->isa('Class::MOP::Method::Wrapped')
               && (
                   (!scalar($method->around_modifiers)
                 || any { $_->has_around_method_modifiers($method->name) } @roles)
                && (!scalar($method->before_modifiers)
                 || any { $_->has_before_method_modifiers($method->name) } @roles)
                && (!scalar($method->after_modifiers)
                 || any { $_->has_after_method_modifiers($method->name) } @roles)
                  );
  
          return 0;
      }
  
      # loop over all attributes that are a part of the current class
      # (not inherited)
      # FIXME - this really isn't right. Just because an attribute is
      # defined in a role doesn't mean it isn't _also_ defined in the
      # subclass.
      for my $attr (map { $meta->get_attribute($_) } $meta->get_attribute_list) {
          next if any { $_->has_attribute($attr->name) } @roles;
  
          return 0;
      }
  
      return 1;
  }
  
  1;
  
  # ABSTRACT: Utilities for working with Moose classes
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Util - Utilities for working with Moose classes
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 SYNOPSIS
  
    use Moose::Util qw/find_meta does_role search_class_by_role/;
  
    my $meta = find_meta($object) || die "No metaclass found";
  
    if (does_role($object, $role)) {
      print "The object can do $role!\n";
    }
  
    my $class = search_class_by_role($object, 'FooRole');
    print "Nearest class with 'FooRole' is $class\n";
  
  =head1 DESCRIPTION
  
  This module provides a set of utility functions. Many of these
  functions are intended for use in Moose itself or MooseX modules, but
  some of them may be useful for use in your own code.
  
  =head1 EXPORTED FUNCTIONS
  
  =over 4
  
  =item B<find_meta($class_or_obj)>
  
  This method takes a class name or object and attempts to find a
  metaclass for the class, if one exists. It will B<not> create one if it
  does not yet exist.
  
  =item B<does_role($class_or_obj, $role_or_obj)>
  
  Returns true if C<$class_or_obj> does the given C<$role_or_obj>. The role can
  be provided as a name or a L<Moose::Meta::Role> object.
  
  The class must already have a metaclass for this to work. If it doesn't, this
  function simply returns false.
  
  =item B<search_class_by_role($class_or_obj, $role_or_obj)>
  
  Returns the first class in the class's precedence list that does
  C<$role_or_obj>, if any. The role can be either a name or a
  L<Moose::Meta::Role> object.
  
  The class must already have a metaclass for this to work.
  
  =item B<apply_all_roles($applicant, @roles)>
  
  This function applies one or more roles to the given C<$applicant> The
  applicant can be a role name, class name, or object.
  
  The C<$applicant> must already have a metaclass object.
  
  The list of C<@roles> should a list of names or L<Moose::Meta::Role> objects,
  each of which can be followed by an optional hash reference of options
  (C<-excludes> and C<-alias>).
  
  =item B<ensure_all_roles($applicant, @roles)>
  
  This function is similar to L</apply_all_roles>, but only applies roles that
  C<$applicant> does not already consume.
  
  =item B<with_traits($class_name, @role_names)>
  
  This function creates a new class from C<$class_name> with each of
  C<@role_names> applied. It returns the name of the new class.
  
  =item B<get_all_attribute_values($meta, $instance)>
  
  Returns a hash reference containing all of the C<$instance>'s
  attributes. The keys are attribute names.
  
  =item B<get_all_init_args($meta, $instance)>
  
  Returns a hash reference containing all of the C<init_arg> values for
  the instance's attributes. The values are the associated attribute
  values. If an attribute does not have a defined C<init_arg>, it is
  skipped.
  
  This could be useful in cloning an object.
  
  =item B<resolve_metaclass_alias($category, $name, %options)>
  
  =item B<resolve_metatrait_alias($category, $name, %options)>
  
  Resolves a short name to a full class name. Short names are often used
  when specifying the C<metaclass> or C<traits> option for an attribute:
  
      has foo => (
          metaclass => "Bar",
      );
  
  The name resolution mechanism is covered in
  L<Moose/Metaclass and Trait Name Resolution>.
  
  =item B<meta_class_alias($to[, $from])>
  
  =item B<meta_attribute_alias($to[, $from])>
  
  Create an alias from the class C<$from> (or the current package, if
  C<$from> is unspecified), so that
  L<Moose/Metaclass and Trait Name Resolution> works properly.
  
  =item B<english_list(@items)>
  
  Given a list of scalars, turns them into a proper list in English
  ("one and two", "one, two, three, and four"). This is used to help us
  make nicer error messages.
  
  =back
  
  =head1 TODO
  
  Here is a list of possible functions to write
  
  =over 4
  
  =item discovering original method from modified method
  
  =item search for origin class of a method or attribute
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
  
I686-LINUX_MOOSE_UTIL

$fatpacked{"i686-linux/Moose/Util/MetaRole.pm"} = <<'I686-LINUX_MOOSE_UTIL_METAROLE';
  package Moose::Util::MetaRole;
  BEGIN {
    $Moose::Util::MetaRole::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Util::MetaRole::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  use Scalar::Util 'blessed';
  
  use Carp qw( croak );
  use List::MoreUtils qw( all );
  use List::Util qw( first );
  use Moose::Deprecated;
  use Scalar::Util qw( blessed );
  
  sub apply_metaroles {
      my %args = @_;
  
      my $for = _metathing_for( $args{for} );
  
      if ( $for->isa('Moose::Meta::Role') ) {
          return _make_new_metaclass( $for, $args{role_metaroles}, 'role' );
      }
      else {
          return _make_new_metaclass( $for, $args{class_metaroles}, 'class' );
      }
  }
  
  sub _metathing_for {
      my $passed = shift;
  
      my $found
          = blessed $passed
          ? $passed
          : Class::MOP::class_of($passed);
  
      return $found
          if defined $found
              && blessed $found
              && (   $found->isa('Moose::Meta::Role')
                  || $found->isa('Moose::Meta::Class') );
  
      local $Carp::CarpLevel = $Carp::CarpLevel + 1;
  
      my $error_start
          = 'When using Moose::Util::MetaRole, you must pass a Moose class name,'
          . ' role name, metaclass object, or metarole object.';
  
      if ( defined $found && blessed $found ) {
          croak $error_start
              . " You passed $passed, and we resolved this to a "
              . ( blessed $found )
              . ' object.';
      }
  
      if ( defined $passed && !defined $found ) {
          croak $error_start
              . " You passed $passed, and this did not resolve to a metaclass or metarole."
              . ' Maybe you need to call Moose->init_meta to initialize the metaclass first?';
      }
  
      if ( !defined $passed ) {
          croak $error_start
              . " You passed an undef."
              . ' Maybe you need to call Moose->init_meta to initialize the metaclass first?';
      }
  }
  
  sub _make_new_metaclass {
      my $for     = shift;
      my $roles   = shift;
      my $primary = shift;
  
      return $for unless keys %{$roles};
  
      my $new_metaclass
          = exists $roles->{$primary}
          ? _make_new_class( ref $for, $roles->{$primary} )
          : blessed $for;
  
      my %classes;
  
      for my $key ( grep { $_ ne $primary } keys %{$roles} ) {
          my $attr = first {$_}
              map { $for->meta->find_attribute_by_name($_) } (
              $key . '_metaclass',
              $key . '_class'
          );
  
          my $reader = $attr->get_read_method;
  
          $classes{ $attr->init_arg }
              = _make_new_class( $for->$reader(), $roles->{$key} );
      }
  
      my $new_meta = $new_metaclass->reinitialize( $for, %classes );
  
      return $new_meta;
  }
  
  sub apply_base_class_roles {
      my %args = @_;
  
      my $meta = _metathing_for( $args{for} || $args{for_class} );
      croak 'You can only apply base class roles to a Moose class, not a role.'
          if $meta->isa('Moose::Meta::Role');
  
      my $new_base = _make_new_class(
          $meta->name,
          $args{roles},
          [ $meta->superclasses() ],
      );
  
      $meta->superclasses($new_base)
          if $new_base ne $meta->name();
  }
  
  sub _make_new_class {
      my $existing_class = shift;
      my $roles          = shift;
      my $superclasses   = shift || [$existing_class];
  
      return $existing_class unless $roles;
  
      my $meta = Class::MOP::Class->initialize($existing_class);
  
      return $existing_class
          if $meta->can('does_role') && all  { $meta->does_role($_) }
                                        grep { !ref $_ } @{$roles};
  
      return Moose::Meta::Class->create_anon_class(
          superclasses => $superclasses,
          roles        => $roles,
          cache        => 1,
      )->name();
  }
  
  1;
  
  # ABSTRACT: Apply roles to any metaclass, as well as the object base class
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Util::MetaRole - Apply roles to any metaclass, as well as the object base class
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 SYNOPSIS
  
    package MyApp::Moose;
  
    use Moose ();
    use Moose::Exporter;
    use Moose::Util::MetaRole;
  
    use MyApp::Role::Meta::Class;
    use MyApp::Role::Meta::Method::Constructor;
    use MyApp::Role::Object;
  
    Moose::Exporter->setup_import_methods( also => 'Moose' );
  
    sub init_meta {
        shift;
        my %args = @_;
  
        Moose->init_meta(%args);
  
        Moose::Util::MetaRole::apply_metaroles(
            for             => $args{for_class},
            class_metaroles => {
                class => => ['MyApp::Role::Meta::Class'],
                constructor => ['MyApp::Role::Meta::Method::Constructor'],
            },
        );
  
        Moose::Util::MetaRole::apply_base_class_roles(
            for   => $args{for_class},
            roles => ['MyApp::Role::Object'],
        );
  
        return $args{for_class}->meta();
    }
  
  =head1 DESCRIPTION
  
  This utility module is designed to help authors of Moose extensions
  write extensions that are able to cooperate with other Moose
  extensions. To do this, you must write your extensions as roles, which
  can then be dynamically applied to the caller's metaclasses.
  
  This module makes sure to preserve any existing superclasses and roles
  already set for the meta objects, which means that any number of
  extensions can apply roles in any order.
  
  =head1 USAGE
  
  The easiest way to use this module is through L<Moose::Exporter>, which can
  generate the appropriate C<init_meta> method for you, and make sure it is
  called when imported.
  
  =head1 FUNCTIONS
  
  This module provides two functions.
  
  =head2 apply_metaroles( ... )
  
  This function will apply roles to one or more metaclasses for the specified
  class. It will return a new metaclass object for the class or role passed in
  the "for" parameter.
  
  It accepts the following parameters:
  
  =over 4
  
  =item * for => $name
  
  This specifies the class or for which to alter the meta classes. This can be a
  package name, or an appropriate meta-object (a L<Moose::Meta::Class> or
  L<Moose::Meta::Role>).
  
  =item * class_metaroles => \%roles
  
  This is a hash reference specifying which metaroles will be applied to the
  class metaclass and its contained metaclasses and helper classes.
  
  Each key should in turn point to an array reference of role names.
  
  It accepts the following keys:
  
  =over 8
  
  =item class
  
  =item attribute
  
  =item method
  
  =item wrapped_method
  
  =item instance
  
  =item constructor
  
  =item destructor
  
  =item error
  
  =back
  
  =item * role_metaroles => \%roles
  
  This is a hash reference specifying which metaroles will be applied to the
  role metaclass and its contained metaclasses and helper classes.
  
  It accepts the following keys:
  
  =over 8
  
  =item role
  
  =item attribute
  
  =item method
  
  =item required_method
  
  =item conflicting_method
  
  =item application_to_class
  
  =item application_to_role
  
  =item application_to_instance
  
  =item application_role_summation
  
  =item applied_attribute
  
  =back
  
  =back
  
  =head2 apply_base_class_roles( for => $class, roles => \@roles )
  
  This function will apply the specified roles to the object's base class.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_UTIL_METAROLE

$fatpacked{"i686-linux/Moose/Util/TypeConstraints.pm"} = <<'I686-LINUX_MOOSE_UTIL_TYPECONSTRAINTS';
  
  package Moose::Util::TypeConstraints;
  BEGIN {
    $Moose::Util::TypeConstraints::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Util::TypeConstraints::VERSION = '2.0401';
  }
  
  use Carp ();
  use List::MoreUtils qw( all any );
  use Scalar::Util qw( blessed reftype );
  use Moose::Exporter;
  
  ## --------------------------------------------------------
  # Prototyped subs must be predeclared because we have a
  # circular dependency with Moose::Meta::Attribute et. al.
  # so in case of us being use'd first the predeclaration
  # ensures the prototypes are in scope when consumers are
  # compiled.
  
  # dah sugah!
  sub where (&);
  sub via (&);
  sub message (&);
  sub optimize_as (&);
  sub inline_as (&);
  
  ## --------------------------------------------------------
  
  use Moose::Deprecated;
  use Moose::Meta::TypeConstraint;
  use Moose::Meta::TypeConstraint::Union;
  use Moose::Meta::TypeConstraint::Parameterized;
  use Moose::Meta::TypeConstraint::Parameterizable;
  use Moose::Meta::TypeConstraint::Class;
  use Moose::Meta::TypeConstraint::Role;
  use Moose::Meta::TypeConstraint::Enum;
  use Moose::Meta::TypeConstraint::DuckType;
  use Moose::Meta::TypeCoercion;
  use Moose::Meta::TypeCoercion::Union;
  use Moose::Meta::TypeConstraint::Registry;
  
  Moose::Exporter->setup_import_methods(
      as_is => [
          qw(
              type subtype class_type role_type maybe_type duck_type
              as where message optimize_as inline_as
              coerce from via
              enum union
              find_type_constraint
              register_type_constraint
              match_on_type )
      ],
  );
  
  ## --------------------------------------------------------
  ## type registry and some useful functions for it
  ## --------------------------------------------------------
  
  my $REGISTRY = Moose::Meta::TypeConstraint::Registry->new;
  
  sub get_type_constraint_registry {$REGISTRY}
  sub list_all_type_constraints    { keys %{ $REGISTRY->type_constraints } }
  
  sub export_type_constraints_as_functions {
      my $pkg = caller();
      no strict 'refs';
      foreach my $constraint ( keys %{ $REGISTRY->type_constraints } ) {
          my $tc = $REGISTRY->get_type_constraint($constraint)
              ->_compiled_type_constraint;
          *{"${pkg}::${constraint}"}
              = sub { $tc->( $_[0] ) ? 1 : undef };    # the undef is for compat
      }
  }
  
  sub create_type_constraint_union {
      _create_type_constraint_union(\@_);
  }
  
  sub create_named_type_constraint_union {
      my $name = shift;
      _create_type_constraint_union($name, \@_);
  }
  
  sub _create_type_constraint_union {
      my $name;
      $name = shift if @_ > 1;
      my @tcs = @{ shift() };
  
      my @type_constraint_names;
  
      if ( scalar @tcs == 1 && _detect_type_constraint_union( $tcs[0] ) ) {
          @type_constraint_names = _parse_type_constraint_union( $tcs[0] );
      }
      else {
          @type_constraint_names = @tcs;
      }
  
      ( scalar @type_constraint_names >= 2 )
          || __PACKAGE__->_throw_error(
          "You must pass in at least 2 type names to make a union");
  
      my @type_constraints = map {
          find_or_parse_type_constraint($_)
              || __PACKAGE__->_throw_error(
              "Could not locate type constraint ($_) for the union");
      } @type_constraint_names;
  
      my %options = (
        type_constraints => \@type_constraints
      );
      $options{name} = $name if defined $name;
  
      return Moose::Meta::TypeConstraint::Union->new(%options);
  }
  
  
  sub create_parameterized_type_constraint {
      my $type_constraint_name = shift;
      my ( $base_type, $type_parameter )
          = _parse_parameterized_type_constraint($type_constraint_name);
  
      ( defined $base_type && defined $type_parameter )
          || __PACKAGE__->_throw_error(
          "Could not parse type name ($type_constraint_name) correctly");
  
      if ( $REGISTRY->has_type_constraint($base_type) ) {
          my $base_type_tc = $REGISTRY->get_type_constraint($base_type);
          return _create_parameterized_type_constraint(
              $base_type_tc,
              $type_parameter
          );
      }
      else {
          __PACKAGE__->_throw_error(
              "Could not locate the base type ($base_type)");
      }
  }
  
  sub _create_parameterized_type_constraint {
      my ( $base_type_tc, $type_parameter ) = @_;
      if ( $base_type_tc->can('parameterize') ) {
          return $base_type_tc->parameterize($type_parameter);
      }
      else {
          return Moose::Meta::TypeConstraint::Parameterized->new(
              name   => $base_type_tc->name . '[' . $type_parameter . ']',
              parent => $base_type_tc,
              type_parameter =>
                  find_or_create_isa_type_constraint($type_parameter),
          );
      }
  }
  
  #should we also support optimized checks?
  sub create_class_type_constraint {
      my ( $class, $options ) = @_;
  
  # too early for this check
  #find_type_constraint("ClassName")->check($class)
  #    || __PACKAGE__->_throw_error("Can't create a class type constraint because '$class' is not a class name");
  
      my $pkg_defined_in = $options->{package_defined_in} || scalar( caller(1) );
  
      if (my $type = $REGISTRY->get_type_constraint($class)) {
          if (!($type->isa('Moose::Meta::TypeConstraint::Class') && $type->class eq $class)) {
              _confess(
                  "The type constraint '$class' has already been created in "
                . $type->_package_defined_in
                . " and cannot be created again in "
                . $pkg_defined_in )
          }
      }
  
      my %options = (
          class              => $class,
          name               => $class,
          package_defined_in => $pkg_defined_in,
          %{ $options || {} },
      );
  
      $options{name} ||= "__ANON__";
  
      my $tc = Moose::Meta::TypeConstraint::Class->new(%options);
      $REGISTRY->add_type_constraint($tc);
      return $tc;
  }
  
  sub create_role_type_constraint {
      my ( $role, $options ) = @_;
  
  # too early for this check
  #find_type_constraint("ClassName")->check($class)
  #    || __PACKAGE__->_throw_error("Can't create a class type constraint because '$class' is not a class name");
  
      my $pkg_defined_in = $options->{package_defined_in} || scalar( caller(1) );
  
      if (my $type = $REGISTRY->get_type_constraint($role)) {
          if (!($type->isa('Moose::Meta::TypeConstraint::Role') && $type->role eq $role)) {
              _confess(
                  "The type constraint '$role' has already been created in "
                . $type->_package_defined_in
                . " and cannot be created again in "
                . $pkg_defined_in )
          }
      }
  
      my %options = (
          role               => $role,
          name               => $role,
          package_defined_in => $pkg_defined_in,
          %{ $options || {} },
      );
  
      $options{name} ||= "__ANON__";
  
      my $tc = Moose::Meta::TypeConstraint::Role->new(%options);
      $REGISTRY->add_type_constraint($tc);
      return $tc;
  }
  
  sub find_or_create_type_constraint {
      my ( $type_constraint_name, $options_for_anon_type ) = @_;
  
      if ( my $constraint
          = find_or_parse_type_constraint($type_constraint_name) ) {
          return $constraint;
      }
      elsif ( defined $options_for_anon_type ) {
  
          # NOTE:
          # if there is no $options_for_anon_type
          # specified, then we assume they don't
          # want to create one, and return nothing.
  
          # otherwise assume that we should create
          # an ANON type with the $options_for_anon_type
          # options which can be passed in. It should
          # be noted that these don't get registered
          # so we need to return it.
          # - SL
          return Moose::Meta::TypeConstraint->new(
              name => '__ANON__',
              %{$options_for_anon_type}
          );
      }
  
      return;
  }
  
  sub find_or_create_isa_type_constraint {
      my ($type_constraint_name, $options) = @_;
      find_or_parse_type_constraint($type_constraint_name)
          || create_class_type_constraint($type_constraint_name, $options);
  }
  
  sub find_or_create_does_type_constraint {
      my ($type_constraint_name, $options) = @_;
      find_or_parse_type_constraint($type_constraint_name)
          || create_role_type_constraint($type_constraint_name, $options);
  }
  
  sub find_or_parse_type_constraint {
      my $type_constraint_name = normalize_type_constraint_name(shift);
      my $constraint;
  
      if ( $constraint = find_type_constraint($type_constraint_name) ) {
          return $constraint;
      }
      elsif ( _detect_type_constraint_union($type_constraint_name) ) {
          $constraint = create_type_constraint_union($type_constraint_name);
      }
      elsif ( _detect_parameterized_type_constraint($type_constraint_name) ) {
          $constraint
              = create_parameterized_type_constraint($type_constraint_name);
      }
      else {
          return;
      }
  
      $REGISTRY->add_type_constraint($constraint);
      return $constraint;
  }
  
  sub normalize_type_constraint_name {
      my $type_constraint_name = shift;
      $type_constraint_name =~ s/\s//g;
      return $type_constraint_name;
  }
  
  sub _confess {
      my $error = shift;
  
      local $Carp::CarpLevel = $Carp::CarpLevel + 1;
      Carp::confess($error);
  }
  
  ## --------------------------------------------------------
  ## exported functions ...
  ## --------------------------------------------------------
  
  sub find_type_constraint {
      my $type = shift;
  
      if ( blessed $type and $type->isa("Moose::Meta::TypeConstraint") ) {
          return $type;
      }
      else {
          return unless $REGISTRY->has_type_constraint($type);
          return $REGISTRY->get_type_constraint($type);
      }
  }
  
  sub register_type_constraint {
      my $constraint = shift;
      __PACKAGE__->_throw_error("can't register an unnamed type constraint")
          unless defined $constraint->name;
      $REGISTRY->add_type_constraint($constraint);
      return $constraint;
  }
  
  # type constructors
  
  sub type {
      my $name = shift;
  
      my %p = map { %{$_} } @_;
  
      return _create_type_constraint(
          $name, undef, $p{where}, $p{message},
          $p{optimize_as}, $p{inline_as},
      );
  }
  
  sub subtype {
      if ( @_ == 1 && !ref $_[0] ) {
          __PACKAGE__->_throw_error(
              'A subtype cannot consist solely of a name, it must have a parent'
          );
      }
  
      # The blessed check is mostly to accommodate MooseX::Types, which
      # uses an object which overloads stringification as a type name.
      my $name = ref $_[0] && !blessed $_[0] ? undef : shift;
  
      my %p = map { %{$_} } @_;
  
      # subtype Str => where { ... };
      if ( !exists $p{as} ) {
          $p{as} = $name;
          $name = undef;
      }
  
      return _create_type_constraint(
          $name, $p{as}, $p{where}, $p{message},
          $p{optimize_as}, $p{inline_as},
      );
  }
  
  sub class_type {
      create_class_type_constraint(@_);
  }
  
  sub role_type ($;$) {
      create_role_type_constraint(@_);
  }
  
  sub maybe_type {
      my ($type_parameter) = @_;
  
      register_type_constraint(
          $REGISTRY->get_type_constraint('Maybe')->parameterize($type_parameter)
      );
  }
  
  sub duck_type {
      my ( $type_name, @methods ) = @_;
      if ( ref $type_name eq 'ARRAY' && !@methods ) {
          @methods   = @$type_name;
          $type_name = undef;
      }
      if ( @methods == 1 && ref $methods[0] eq 'ARRAY' ) {
          @methods = @{ $methods[0] };
      }
  
      register_type_constraint(
          create_duck_type_constraint(
              $type_name,
              \@methods,
          )
      );
  }
  
  sub coerce {
      my ( $type_name, @coercion_map ) = @_;
      _install_type_coercions( $type_name, \@coercion_map );
  }
  
  # The trick of returning @_ lets us avoid having to specify a
  # prototype. Perl will parse this:
  #
  # subtype 'Foo'
  #     => as 'Str'
  #     => where { ... }
  #
  # as this:
  #
  # subtype( 'Foo', as( 'Str', where { ... } ) );
  #
  # If as() returns all its extra arguments, this just works, and
  # preserves backwards compatibility.
  sub as { { as => shift }, @_ }
  sub where (&)       { { where       => $_[0] } }
  sub message (&)     { { message     => $_[0] } }
  sub optimize_as (&) { { optimize_as => $_[0] } }
  sub inline_as (&)   { { inline_as   => $_[0] } }
  
  sub from    {@_}
  sub via (&) { $_[0] }
  
  sub enum {
      my ( $type_name, @values ) = @_;
  
      # NOTE:
      # if only an array-ref is passed then
      # you get an anon-enum
      # - SL
      if ( ref $type_name eq 'ARRAY' ) {
          @values == 0
              || __PACKAGE__->_throw_error("enum called with an array reference and additional arguments. Did you mean to parenthesize the enum call's parameters?");
  
          @values    = @$type_name;
          $type_name = undef;
      }
      if ( @values == 1 && ref $values[0] eq 'ARRAY' ) {
          @values = @{ $values[0] };
      }
  
      register_type_constraint(
          create_enum_type_constraint(
              $type_name,
              \@values,
          )
      );
  }
  
  sub union {
    my ( $type_name, @constraints ) = @_;
    if ( ref $type_name eq 'ARRAY' ) {
      @constraints == 0
        || __PACKAGE__->_throw_error("union called with an array reference and additional arguments.");
      @constraints = @$type_name;
      $type_name   = undef;
    }
    if ( @constraints == 1 && ref $constraints[0] eq 'ARRAY' ) {
      @constraints = @{ $constraints[0] };
    }
    if ( defined $type_name ) {
      return register_type_constraint(
        create_named_type_constraint_union( $type_name, @constraints )
      );
    }
    return create_type_constraint_union( @constraints );
  }
  
  sub create_enum_type_constraint {
      my ( $type_name, $values ) = @_;
  
      Moose::Meta::TypeConstraint::Enum->new(
          name => $type_name || '__ANON__',
          values => $values,
      );
  }
  
  sub create_duck_type_constraint {
      my ( $type_name, $methods ) = @_;
  
      Moose::Meta::TypeConstraint::DuckType->new(
          name => $type_name || '__ANON__',
          methods => $methods,
      );
  }
  
  sub match_on_type {
      my ($to_match, @cases) = @_;
      my $default;
      if (@cases % 2 != 0) {
          $default = pop @cases;
          (ref $default eq 'CODE')
              || __PACKAGE__->_throw_error("Default case must be a CODE ref, not $default");
      }
      while (@cases) {
          my ($type, $action) = splice @cases, 0, 2;
  
          unless (blessed $type && $type->isa('Moose::Meta::TypeConstraint')) {
              $type = find_or_parse_type_constraint($type)
                   || __PACKAGE__->_throw_error("Cannot find or parse the type '$type'")
          }
  
          (ref $action eq 'CODE')
              || __PACKAGE__->_throw_error("Match action must be a CODE ref, not $action");
  
          if ($type->check($to_match)) {
              local $_ = $to_match;
              return $action->($to_match);
          }
      }
      (defined $default)
          || __PACKAGE__->_throw_error("No cases matched for $to_match");
      {
          local $_ = $to_match;
          return $default->($to_match);
      }
  }
  
  
  ## --------------------------------------------------------
  ## desugaring functions ...
  ## --------------------------------------------------------
  
  sub _create_type_constraint ($$$;$$) {
      my $name      = shift;
      my $parent    = shift;
      my $check     = shift;
      my $message   = shift;
      my $optimized = shift;
      my $inlined   = shift;
  
      my $pkg_defined_in = scalar( caller(1) );
  
      if ( defined $name ) {
          my $type = $REGISTRY->get_type_constraint($name);
  
          ( $type->_package_defined_in eq $pkg_defined_in )
              || _confess(
                    "The type constraint '$name' has already been created in "
                  . $type->_package_defined_in
                  . " and cannot be created again in "
                  . $pkg_defined_in )
              if defined $type;
  
          $name =~ /^[\w:\.]+$/
              or die qq{$name contains invalid characters for a type name.}
              . qq{ Names can contain alphanumeric character, ":", and "."\n};
      }
  
      my %opts = (
          name               => $name,
          package_defined_in => $pkg_defined_in,
  
          ( $check     ? ( constraint => $check )     : () ),
          ( $message   ? ( message    => $message )   : () ),
          ( $optimized ? ( optimized  => $optimized ) : () ),
          ( $inlined   ? ( inlined    => $inlined )   : () ),
      );
  
      my $constraint;
      if (
          defined $parent
          and $parent
          = blessed $parent
          ? $parent
          : find_or_create_isa_type_constraint($parent)
          ) {
          $constraint = $parent->create_child_type(%opts);
      }
      else {
          $constraint = Moose::Meta::TypeConstraint->new(%opts);
      }
  
      $REGISTRY->add_type_constraint($constraint)
          if defined $name;
  
      return $constraint;
  }
  
  sub _install_type_coercions ($$) {
      my ( $type_name, $coercion_map ) = @_;
      my $type = find_type_constraint($type_name);
      ( defined $type )
          || __PACKAGE__->_throw_error(
          "Cannot find type '$type_name', perhaps you forgot to load it");
      if ( $type->has_coercion ) {
          $type->coercion->add_type_coercions(@$coercion_map);
      }
      else {
          my $type_coercion = Moose::Meta::TypeCoercion->new(
              type_coercion_map => $coercion_map,
              type_constraint   => $type
          );
          $type->coercion($type_coercion);
      }
  }
  
  ## --------------------------------------------------------
  ## type notation parsing ...
  ## --------------------------------------------------------
  
  {
  
      # All I have to say is mugwump++ cause I know
      # do not even have enough regexp-fu to be able
      # to have written this (I can only barely
      # understand it as it is)
      # - SL
  
      use re "eval";
  
      my $valid_chars = qr{[\w:\.]};
      my $type_atom   = qr{ (?>$valid_chars+) }x;
      my $ws          = qr{ (?>\s*) }x;
      my $op_union    = qr{ $ws \| $ws }x;
  
      my ($type, $type_capture_parts, $type_with_parameter, $union, $any);
      if (Class::MOP::IS_RUNNING_ON_5_10) {
          my $type_pattern
              = q{  (?&type_atom)  (?: \[ (?&ws)  (?&any)  (?&ws) \] )? };
          my $type_capture_parts_pattern
              = q{ ((?&type_atom)) (?: \[ (?&ws) ((?&any)) (?&ws) \] )? };
          my $type_with_parameter_pattern
              = q{  (?&type_atom)      \[ (?&ws)  (?&any)  (?&ws) \]    };
          my $union_pattern
              = q{ (?&type) (?> (?: (?&op_union) (?&type) )+ ) };
          my $any_pattern
              = q{ (?&type) | (?&union) };
  
          my $defines = qr{(?(DEFINE)
              (?<valid_chars>         $valid_chars)
              (?<type_atom>           $type_atom)
              (?<ws>                  $ws)
              (?<op_union>            $op_union)
              (?<type>                $type_pattern)
              (?<type_capture_parts>  $type_capture_parts_pattern)
              (?<type_with_parameter> $type_with_parameter_pattern)
              (?<union>               $union_pattern)
              (?<any>                 $any_pattern)
          )}x;
  
          $type                = qr{ $type_pattern                $defines }x;
          $type_capture_parts  = qr{ $type_capture_parts_pattern  $defines }x;
          $type_with_parameter = qr{ $type_with_parameter_pattern $defines }x;
          $union               = qr{ $union_pattern               $defines }x;
          $any                 = qr{ $any_pattern                 $defines }x;
      }
      else {
          $type
              = qr{  $type_atom  (?: \[ $ws  (??{$any})  $ws \] )? }x;
          $type_capture_parts
              = qr{ ($type_atom) (?: \[ $ws ((??{$any})) $ws \] )? }x;
          $type_with_parameter
              = qr{  $type_atom      \[ $ws  (??{$any})  $ws \]    }x;
          $union
              = qr{ $type (?> (?: $op_union $type )+ ) }x;
          $any
              = qr{ $type | $union }x;
      }
  
  
      sub _parse_parameterized_type_constraint {
          { no warnings 'void'; $any; }  # force capture of interpolated lexical
          $_[0] =~ m{ $type_capture_parts }x;
          return ( $1, $2 );
      }
  
      sub _detect_parameterized_type_constraint {
          { no warnings 'void'; $any; }  # force capture of interpolated lexical
          $_[0] =~ m{ ^ $type_with_parameter $ }x;
      }
  
      sub _parse_type_constraint_union {
          { no warnings 'void'; $any; }  # force capture of interpolated lexical
          my $given = shift;
          my @rv;
          while ( $given =~ m{ \G (?: $op_union )? ($type) }gcx ) {
              push @rv => $1;
          }
          ( pos($given) eq length($given) )
              || __PACKAGE__->_throw_error( "'$given' didn't parse (parse-pos="
                  . pos($given)
                  . " and str-length="
                  . length($given)
                  . ")" );
          @rv;
      }
  
      sub _detect_type_constraint_union {
          { no warnings 'void'; $any; }  # force capture of interpolated lexical
          $_[0] =~ m{^ $type $op_union $type ( $op_union .* )? $}x;
      }
  }
  
  ## --------------------------------------------------------
  # define some basic built-in types
  ## --------------------------------------------------------
  
  # By making these classes immutable before creating all the types in
  # Moose::Util::TypeConstraints::Builtin , we avoid repeatedly calling the slow
  # MOP-based accessors.
  $_->make_immutable(
      inline_constructor => 1,
      constructor_name   => "_new",
  
      # these are Class::MOP accessors, so they need inlining
      inline_accessors => 1
      ) for grep { $_->is_mutable }
      map { Class::MOP::class_of($_) }
      qw(
      Moose::Meta::TypeConstraint
      Moose::Meta::TypeConstraint::Union
      Moose::Meta::TypeConstraint::Parameterized
      Moose::Meta::TypeConstraint::Parameterizable
      Moose::Meta::TypeConstraint::Class
      Moose::Meta::TypeConstraint::Role
      Moose::Meta::TypeConstraint::Enum
      Moose::Meta::TypeConstraint::DuckType
      Moose::Meta::TypeConstraint::Registry
  );
  
  require Moose::Util::TypeConstraints::Builtins;
  Moose::Util::TypeConstraints::Builtins::define_builtins($REGISTRY);
  
  my @PARAMETERIZABLE_TYPES
      = map { $REGISTRY->get_type_constraint($_) } qw[ScalarRef ArrayRef HashRef Maybe];
  
  sub get_all_parameterizable_types {@PARAMETERIZABLE_TYPES}
  
  sub add_parameterizable_type {
      my $type = shift;
      ( blessed $type
              && $type->isa('Moose::Meta::TypeConstraint::Parameterizable') )
          || __PACKAGE__->_throw_error(
          "Type must be a Moose::Meta::TypeConstraint::Parameterizable not $type"
          );
      push @PARAMETERIZABLE_TYPES => $type;
  }
  
  ## --------------------------------------------------------
  # end of built-in types ...
  ## --------------------------------------------------------
  
  {
      my @BUILTINS = list_all_type_constraints();
      sub list_all_builtin_type_constraints {@BUILTINS}
  }
  
  sub _throw_error {
      shift;
      require Moose;
      unshift @_, 'Moose';
      goto &Moose::throw_error;
  }
  
  1;
  
  # ABSTRACT: Type constraint system for Moose
  
  
  
  =pod
  
  =head1 NAME
  
  Moose::Util::TypeConstraints - Type constraint system for Moose
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 SYNOPSIS
  
    use Moose::Util::TypeConstraints;
  
    subtype 'Natural',
        as 'Int',
        where { $_ > 0 };
  
    subtype 'NaturalLessThanTen',
        as 'Natural',
        where { $_ < 10 },
        message { "This number ($_) is not less than ten!" };
  
    coerce 'Num',
        from 'Str',
        via { 0+$_ };
  
    class_type 'DateTimeClass', { class => 'DateTime' };
  
    role_type 'Barks', { role => 'Some::Library::Role::Barks' };
  
    enum 'RGBColors', [qw(red green blue)];
  
    union 'StringOrArray', [qw( String Array )];
  
    no Moose::Util::TypeConstraints;
  
  =head1 DESCRIPTION
  
  This module provides Moose with the ability to create custom type
  constraints to be used in attribute definition.
  
  =head2 Important Caveat
  
  This is B<NOT> a type system for Perl 5. These are type constraints,
  and they are not used by Moose unless you tell it to. No type
  inference is performed, expressions are not typed, etc. etc. etc.
  
  A type constraint is at heart a small "check if a value is valid"
  function. A constraint can be associated with an attribute. This
  simplifies parameter validation, and makes your code clearer to read,
  because you can refer to constraints by name.
  
  =head2 Slightly Less Important Caveat
  
  It is B<always> a good idea to quote your type names.
  
  This prevents Perl from trying to execute the call as an indirect
  object call. This can be an issue when you have a subtype with the
  same name as a valid class.
  
  For instance:
  
    subtype DateTime => as Object => where { $_->isa('DateTime') };
  
  will I<just work>, while this:
  
    use DateTime;
    subtype DateTime => as Object => where { $_->isa('DateTime') };
  
  will fail silently and cause many headaches. The simple way to solve
  this, as well as future proof your subtypes from classes which have
  yet to have been created, is to quote the type name:
  
    use DateTime;
    subtype 'DateTime', as 'Object', where { $_->isa('DateTime') };
  
  =head2 Default Type Constraints
  
  This module also provides a simple hierarchy for Perl 5 types, here is
  that hierarchy represented visually.
  
    Any
    Item
        Bool
        Maybe[`a]
        Undef
        Defined
            Value
                Str
                    Num
                        Int
                    ClassName
                    RoleName
            Ref
                ScalarRef[`a]
                ArrayRef[`a]
                HashRef[`a]
                CodeRef
                RegexpRef
                GlobRef
                FileHandle
                Object
  
  B<NOTE:> Any type followed by a type parameter C<[`a]> can be
  parameterized, this means you can say:
  
    ArrayRef[Int]    # an array of integers
    HashRef[CodeRef] # a hash of str to CODE ref mappings
    ScalarRef[Int]   # a reference to an integer
    Maybe[Str]       # value may be a string, may be undefined
  
  If Moose finds a name in brackets that it does not recognize as an
  existing type, it assumes that this is a class name, for example
  C<ArrayRef[DateTime]>.
  
  B<NOTE:> Unless you parameterize a type, then it is invalid to include
  the square brackets. I.e. C<ArrayRef[]> will be treated as a new type
  name, I<not> as a parameterization of C<ArrayRef>.
  
  B<NOTE:> The C<Undef> type constraint for the most part works
  correctly now, but edge cases may still exist, please use it
  sparingly.
  
  B<NOTE:> The C<ClassName> type constraint does a complex package
  existence check. This means that your class B<must> be loaded for this
  type constraint to pass.
  
  B<NOTE:> The C<RoleName> constraint checks a string is a I<package
  name> which is a role, like C<'MyApp::Role::Comparable'>.
  
  =head2 Type Constraint Naming
  
  Type name declared via this module can only contain alphanumeric
  characters, colons (:), and periods (.).
  
  Since the types created by this module are global, it is suggested
  that you namespace your types just as you would namespace your
  modules. So instead of creating a I<Color> type for your
  B<My::Graphics> module, you would call the type
  I<My::Graphics::Types::Color> instead.
  
  =head2 Use with Other Constraint Modules
  
  This module can play nicely with other constraint modules with some
  slight tweaking. The C<where> clause in types is expected to be a
  C<CODE> reference which checks its first argument and returns a
  boolean. Since most constraint modules work in a similar way, it
  should be simple to adapt them to work with Moose.
  
  For instance, this is how you could use it with
  L<Declare::Constraints::Simple> to declare a completely new type.
  
    type 'HashOfArrayOfObjects',
        where {
            IsHashRef(
                -keys   => HasLength,
                -values => IsArrayRef(IsObject)
            )->(@_);
        };
  
  For more examples see the F<t/examples/example_w_DCS.t> test
  file.
  
  Here is an example of using L<Test::Deep> and its non-test
  related C<eq_deeply> function.
  
    type 'ArrayOfHashOfBarsAndRandomNumbers',
        where {
            eq_deeply($_,
                array_each(subhashof({
                    bar           => isa('Bar'),
                    random_number => ignore()
                })))
          };
  
  For a complete example see the
  F<t/examples/example_w_TestDeep.t> test file.
  
  =head2 Error messages
  
  Type constraints can also specify custom error messages, for when they fail to
  validate. This is provided as just another coderef, which receives the invalid
  value in C<$_>, as in:
  
    subtype 'PositiveInt',
         as 'Int',
         where { $_ > 0 },
         message { "$_ is not a positive integer!" };
  
  If no message is specified, a default message will be used, which indicates
  which type constraint was being used and what value failed. If
  L<Devel::PartialDump> (version 0.14 or higher) is installed, it will be used to
  display the invalid value, otherwise it will just be printed as is.
  
  =head1 FUNCTIONS
  
  =head2 Type Constraint Constructors
  
  The following functions are used to create type constraints.  They
  will also register the type constraints your create in a global
  registry that is used to look types up by name.
  
  See the L</SYNOPSIS> for an example of how to use these.
  
  =over 4
  
  =item B<< subtype 'Name', as 'Parent', where { } ... >>
  
  This creates a named subtype.
  
  If you provide a parent that Moose does not recognize, it will
  automatically create a new class type constraint for this name.
  
  When creating a named type, the C<subtype> function should either be
  called with the sugar helpers (C<where>, C<message>, etc), or with a
  name and a hashref of parameters:
  
   subtype( 'Foo', { where => ..., message => ... } );
  
  The valid hashref keys are C<as> (the parent), C<where>, C<message>,
  and C<optimize_as>.
  
  =item B<< subtype as 'Parent', where { } ... >>
  
  This creates an unnamed subtype and will return the type
  constraint meta-object, which will be an instance of
  L<Moose::Meta::TypeConstraint>.
  
  When creating an anonymous type, the C<subtype> function should either
  be called with the sugar helpers (C<where>, C<message>, etc), or with
  just a hashref of parameters:
  
   subtype( { where => ..., message => ... } );
  
  =item B<class_type ($class, ?$options)>
  
  Creates a new subtype of C<Object> with the name C<$class> and the
  metaclass L<Moose::Meta::TypeConstraint::Class>.
  
    # Create a type called 'Box' which tests for objects which ->isa('Box')
    class_type 'Box';
  
  By default, the name of the type and the name of the class are the same, but
  you can specify both separately.
  
    # Create a type called 'Box' which tests for objects which ->isa('ObjectLibrary::Box');
    class_type 'Box', { class => 'ObjectLibrary::Box' };
  
  =item B<role_type ($role, ?$options)>
  
  Creates a C<Role> type constraint with the name C<$role> and the
  metaclass L<Moose::Meta::TypeConstraint::Role>.
  
    # Create a type called 'Walks' which tests for objects which ->does('Walks')
    role_type 'Walks';
  
  By default, the name of the type and the name of the role are the same, but
  you can specify both separately.
  
    # Create a type called 'Walks' which tests for objects which ->does('MooseX::Role::Walks');
    role_type 'Walks', { role => 'MooseX::Role::Walks' };
  
  =item B<maybe_type ($type)>
  
  Creates a type constraint for either C<undef> or something of the
  given type.
  
  =item B<duck_type ($name, \@methods)>
  
  This will create a subtype of Object and test to make sure the value
  C<can()> do the methods in C<\@methods>.
  
  This is intended as an easy way to accept non-Moose objects that
  provide a certain interface. If you're using Moose classes, we
  recommend that you use a C<requires>-only Role instead.
  
  =item B<duck_type (\@methods)>
  
  If passed an ARRAY reference as the only parameter instead of the
  C<$name>, C<\@methods> pair, this will create an unnamed duck type.
  This can be used in an attribute definition like so:
  
    has 'cache' => (
        is  => 'ro',
        isa => duck_type( [qw( get_set )] ),
    );
  
  =item B<enum ($name, \@values)>
  
  This will create a basic subtype for a given set of strings.
  The resulting constraint will be a subtype of C<Str> and
  will match any of the items in C<\@values>. It is case sensitive.
  See the L</SYNOPSIS> for a simple example.
  
  B<NOTE:> This is not a true proper enum type, it is simply
  a convenient constraint builder.
  
  =item B<enum (\@values)>
  
  If passed an ARRAY reference as the only parameter instead of the
  C<$name>, C<\@values> pair, this will create an unnamed enum. This
  can then be used in an attribute definition like so:
  
    has 'sort_order' => (
        is  => 'ro',
        isa => enum([qw[ ascending descending ]]),
    );
  
  =item B<union ($name, \@constraints)>
  
  This will create a basic subtype where any of the provided constraints
  may match in order to satisfy this constraint.
  
  =item B<union (\@constraints)>
  
  If passed an ARRAY reference as the only parameter instead of the
  C<$name>, C<\@constraints> pair, this will create an unnamed union.
  This can then be used in an attribute definition like so:
  
    has 'items' => (
        is => 'ro',
        isa => union([qw[ Str ArrayRef ]]),
    );
  
  This is similar to the existing string union:
  
    isa => 'Str|ArrayRef'
  
  except that it supports anonymous elements as child constraints:
  
    has 'color' => (
      isa => 'ro',
      isa => union([ 'Int',  enum([qw[ red green blue ]]) ]),
    );
  
  =item B<as 'Parent'>
  
  This is just sugar for the type constraint construction syntax.
  
  It takes a single argument, which is the name of a parent type.
  
  =item B<where { ... }>
  
  This is just sugar for the type constraint construction syntax.
  
  It takes a subroutine reference as an argument. When the type
  constraint is tested, the reference is run with the value to be tested
  in C<$_>. This reference should return true or false to indicate
  whether or not the constraint check passed.
  
  =item B<message { ... }>
  
  This is just sugar for the type constraint construction syntax.
  
  It takes a subroutine reference as an argument. When the type
  constraint fails, then the code block is run with the value provided
  in C<$_>. This reference should return a string, which will be used in
  the text of the exception thrown.
  
  =item B<inline_as { ... }>
  
  This can be used to define a "hand optimized" inlinable version of your type
  constraint.
  
  You provide a subroutine which will be called I<as a method> on a
  L<Moose::Meta::TypeConstraint> object. It will receive a single parameter, the
  name of the variable to check, typically something like C<"$_"> or C<"$_[0]">.
  
  The subroutine should return a code string suitable for inlining. You can
  assume that the check will be wrapped in parentheses when it is inlined.
  
  The inlined code should include any checks that your type's parent types
  do. If your parent type constraint defines its own inlining, you can simply use
  that to avoid repeating code. For example, here is the inlining code for the
  C<Value> type, which is a subtype of C<Defined>:
  
      sub {
          $_[0]->parent()->_inline_check($_[1])
          . ' && !ref(' . $_[1] . ')'
      }
  
  =item B<optimize_as { ... }>
  
  B<This feature is deprecated, use C<inline_as> instead.>
  
  This can be used to define a "hand optimized" version of your
  type constraint which can be used to avoid traversing a subtype
  constraint hierarchy.
  
  B<NOTE:> You should only use this if you know what you are doing.
  All the built in types use this, so your subtypes (assuming they
  are shallow) will not likely need to use this.
  
  =item B<< type 'Name', where { } ... >>
  
  This creates a base type, which has no parent.
  
  The C<type> function should either be called with the sugar helpers
  (C<where>, C<message>, etc), or with a name and a hashref of
  parameters:
  
    type( 'Foo', { where => ..., message => ... } );
  
  The valid hashref keys are C<where>, C<message>, and C<inlined_as>.
  
  =back
  
  =head2 Type Constraint Utilities
  
  =over 4
  
  =item B<< match_on_type $value => ( $type => \&action, ... ?\&default ) >>
  
  This is a utility function for doing simple type based dispatching similar to
  match/case in OCaml and case/of in Haskell. It is not as featureful as those
  languages, nor does not it support any kind of automatic destructuring
  bind. Here is a simple Perl pretty printer dispatching over the core Moose
  types.
  
    sub ppprint {
        my $x = shift;
        match_on_type $x => (
            HashRef => sub {
                my $hash = shift;
                '{ '
                    . (
                    join ", " => map { $_ . ' => ' . ppprint( $hash->{$_} ) }
                        sort keys %$hash
                    ) . ' }';
            },
            ArrayRef => sub {
                my $array = shift;
                '[ ' . ( join ", " => map { ppprint($_) } @$array ) . ' ]';
            },
            CodeRef   => sub {'sub { ... }'},
            RegexpRef => sub { 'qr/' . $_ . '/' },
            GlobRef   => sub { '*' . B::svref_2object($_)->NAME },
            Object    => sub { $_->can('to_string') ? $_->to_string : $_ },
            ScalarRef => sub { '\\' . ppprint( ${$_} ) },
            Num       => sub {$_},
            Str       => sub { '"' . $_ . '"' },
            Undef     => sub {'undef'},
            => sub { die "I don't know what $_ is" }
        );
    }
  
  Or a simple JSON serializer:
  
    sub to_json {
        my $x = shift;
        match_on_type $x => (
            HashRef => sub {
                my $hash = shift;
                '{ '
                    . (
                    join ", " =>
                        map { '"' . $_ . '" : ' . to_json( $hash->{$_} ) }
                        sort keys %$hash
                    ) . ' }';
            },
            ArrayRef => sub {
                my $array = shift;
                '[ ' . ( join ", " => map { to_json($_) } @$array ) . ' ]';
            },
            Num   => sub {$_},
            Str   => sub { '"' . $_ . '"' },
            Undef => sub {'null'},
            => sub { die "$_ is not acceptable json type" }
        );
    }
  
  The matcher is done by mapping a C<$type> to an C<\&action>. The C<$type> can
  be either a string type or a L<Moose::Meta::TypeConstraint> object, and
  C<\&action> is a subroutine reference. This function will dispatch on the
  first match for C<$value>. It is possible to have a catch-all by providing an
  additional subroutine reference as the final argument to C<match_on_type>.
  
  =back
  
  =head2 Type Coercion Constructors
  
  You can define coercions for type constraints, which allow you to
  automatically transform values to something valid for the type
  constraint. If you ask your accessor to coerce, then Moose will run
  the type-coercion code first, followed by the type constraint
  check. This feature should be used carefully as it is very powerful
  and could easily take off a limb if you are not careful.
  
  See the L</SYNOPSIS> for an example of how to use these.
  
  =over 4
  
  =item B<< coerce 'Name', from 'OtherName', via { ... }  >>
  
  This defines a coercion from one type to another. The C<Name> argument
  is the type you are coercing I<to>.
  
  To define multiple coercions, supply more sets of from/via pairs:
  
    coerce 'Name',
      from 'OtherName', via { ... },
      from 'ThirdName', via { ... };
  
  =item B<from 'OtherName'>
  
  This is just sugar for the type coercion construction syntax.
  
  It takes a single type name (or type object), which is the type being
  coerced I<from>.
  
  =item B<via { ... }>
  
  This is just sugar for the type coercion construction syntax.
  
  It takes a subroutine reference. This reference will be called with
  the value to be coerced in C<$_>. It is expected to return a new value
  of the proper type for the coercion.
  
  =back
  
  =head2 Creating and Finding Type Constraints
  
  These are additional functions for creating and finding type
  constraints. Most of these functions are not available for
  importing. The ones that are importable as specified.
  
  =over 4
  
  =item B<find_type_constraint($type_name)>
  
  This function can be used to locate the L<Moose::Meta::TypeConstraint>
  object for a named type.
  
  This function is importable.
  
  =item B<register_type_constraint($type_object)>
  
  This function will register a L<Moose::Meta::TypeConstraint> with the
  global type registry.
  
  This function is importable.
  
  =item B<normalize_type_constraint_name($type_constraint_name)>
  
  This method takes a type constraint name and returns the normalized
  form. This removes any whitespace in the string.
  
  =item B<create_type_constraint_union($pipe_separated_types | @type_constraint_names)>
  
  =item B<create_named_type_constraint_union($name, $pipe_separated_types | @type_constraint_names)>
  
  This can take a union type specification like C<'Int|ArrayRef[Int]'>,
  or a list of names. It returns a new
  L<Moose::Meta::TypeConstraint::Union> object.
  
  =item B<create_parameterized_type_constraint($type_name)>
  
  Given a C<$type_name> in the form of C<'BaseType[ContainerType]'>,
  this will create a new L<Moose::Meta::TypeConstraint::Parameterized>
  object. The C<BaseType> must exist already exist as a parameterizable
  type.
  
  =item B<create_class_type_constraint($class, $options)>
  
  Given a class name this function will create a new
  L<Moose::Meta::TypeConstraint::Class> object for that class name.
  
  The C<$options> is a hash reference that will be passed to the
  L<Moose::Meta::TypeConstraint::Class> constructor (as a hash).
  
  =item B<create_role_type_constraint($role, $options)>
  
  Given a role name this function will create a new
  L<Moose::Meta::TypeConstraint::Role> object for that role name.
  
  The C<$options> is a hash reference that will be passed to the
  L<Moose::Meta::TypeConstraint::Role> constructor (as a hash).
  
  =item B<create_enum_type_constraint($name, $values)>
  
  Given a enum name this function will create a new
  L<Moose::Meta::TypeConstraint::Enum> object for that enum name.
  
  =item B<create_duck_type_constraint($name, $methods)>
  
  Given a duck type name this function will create a new
  L<Moose::Meta::TypeConstraint::DuckType> object for that enum name.
  
  =item B<find_or_parse_type_constraint($type_name)>
  
  Given a type name, this first attempts to find a matching constraint
  in the global registry.
  
  If the type name is a union or parameterized type, it will create a
  new object of the appropriate, but if given a "regular" type that does
  not yet exist, it simply returns false.
  
  When given a union or parameterized type, the member or base type must
  already exist.
  
  If it creates a new union or parameterized type, it will add it to the
  global registry.
  
  =item B<find_or_create_isa_type_constraint($type_name)>
  
  =item B<find_or_create_does_type_constraint($type_name)>
  
  These functions will first call C<find_or_parse_type_constraint>. If
  that function does not return a type, a new type object will
  be created.
  
  The C<isa> variant will use C<create_class_type_constraint> and the
  C<does> variant will use C<create_role_type_constraint>.
  
  =item B<get_type_constraint_registry>
  
  Returns the L<Moose::Meta::TypeConstraint::Registry> object which
  keeps track of all type constraints.
  
  =item B<list_all_type_constraints>
  
  This will return a list of type constraint names in the global
  registry. You can then fetch the actual type object using
  C<find_type_constraint($type_name)>.
  
  =item B<list_all_builtin_type_constraints>
  
  This will return a list of builtin type constraints, meaning those
  which are defined in this module. See the L<Default Type Constraints>
  section for a complete list.
  
  =item B<export_type_constraints_as_functions>
  
  This will export all the current type constraints as functions into
  the caller's namespace (C<Int()>, C<Str()>, etc). Right now, this is
  mostly used for testing, but it might prove useful to others.
  
  =item B<get_all_parameterizable_types>
  
  This returns all the parameterizable types that have been registered,
  as a list of type objects.
  
  =item B<add_parameterizable_type($type)>
  
  Adds C<$type> to the list of parameterizable types
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_MOOSE_UTIL_TYPECONSTRAINTS

$fatpacked{"i686-linux/Moose/Util/TypeConstraints/Builtins.pm"} = <<'I686-LINUX_MOOSE_UTIL_TYPECONSTRAINTS_BUILTINS';
  package Moose::Util::TypeConstraints::Builtins;
  BEGIN {
    $Moose::Util::TypeConstraints::Builtins::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Moose::Util::TypeConstraints::Builtins::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Class::Load qw( is_class_loaded );
  use List::MoreUtils ();
  use Scalar::Util qw( blessed looks_like_number reftype );
  
  sub type { goto &Moose::Util::TypeConstraints::type }
  sub subtype { goto &Moose::Util::TypeConstraints::subtype }
  sub as { goto &Moose::Util::TypeConstraints::as }
  sub where (&) { goto &Moose::Util::TypeConstraints::where }
  sub optimize_as (&) { goto &Moose::Util::TypeConstraints::optimize_as }
  sub inline_as (&) { goto &Moose::Util::TypeConstraints::inline_as }
  
  sub define_builtins {
      my $registry = shift;
  
      type 'Any'    # meta-type including all
          => where {1}
          => inline_as { '1' };
  
      subtype 'Item'  # base type
          => as 'Any'
          => inline_as { '1' };
  
      subtype 'Undef'
          => as 'Item'
          => where { !defined($_) }
          => inline_as {
              '!defined(' . $_[1] . ')'
          };
  
      subtype 'Defined'
          => as 'Item'
          => where { defined($_) }
          => inline_as {
              'defined(' . $_[1] . ')'
          };
  
      subtype 'Bool'
          => as 'Item'
          => where { !defined($_) || $_ eq "" || "$_" eq '1' || "$_" eq '0' }
          => inline_as {
              '('
                  . '!defined(' . $_[1] . ') '
                  . '|| ' . $_[1] . ' eq "" '
                  . '|| (' . $_[1] . '."") eq "1" '
                  . '|| (' . $_[1] . '."") eq "0"'
              . ')'
          };
  
      subtype 'Value'
          => as 'Defined'
          => where { !ref($_) }
          => inline_as {
              $_[0]->parent()->_inline_check($_[1])
              . ' && !ref(' . $_[1] . ')'
          };
  
      subtype 'Ref'
          => as 'Defined'
          => where { ref($_) }
              # no need to call parent - ref also checks for definedness
          => inline_as { 'ref(' . $_[1] . ')' };
  
      subtype 'Str'
          => as 'Value'
          => where { ref(\$_) eq 'SCALAR' || ref(\(my $val = $_)) eq 'SCALAR' }
          => inline_as {
              $_[0]->parent()->_inline_check($_[1])
              . ' && ('
                  . 'ref(\\' . $_[1] . ') eq "SCALAR"'
                  . ' || ref(\\(my $val = ' . $_[1] . ')) eq "SCALAR"'
              . ')'
          };
  
      my $value_type = Moose::Util::TypeConstraints::find_type_constraint('Value');
      subtype 'Num'
          => as 'Str'
          => where { Scalar::Util::looks_like_number($_) }
          => inline_as {
              # the long Str tests are redundant here
              $value_type->_inline_check($_[1])
              . ' && Scalar::Util::looks_like_number(' . $_[1] . ')'
          };
  
      subtype 'Int'
          => as 'Num'
          => where { (my $val = $_) =~ /\A-?[0-9]+\z/ }
          => inline_as {
              $value_type->_inline_check($_[1])
              . ' && (my $val = ' . $_[1] . ') =~ /\A-?[0-9]+\z/'
          };
  
      subtype 'CodeRef'
          => as 'Ref'
          => where { ref($_) eq 'CODE' }
          => inline_as { 'ref(' . $_[1] . ') eq "CODE"' };
  
      subtype 'RegexpRef'
          => as 'Ref'
          => where( \&_RegexpRef )
          => inline_as {
              'Moose::Util::TypeConstraints::Builtins::_RegexpRef(' . $_[1] . ')'
          };
  
      subtype 'GlobRef'
          => as 'Ref'
          => where { ref($_) eq 'GLOB' }
          => inline_as { 'ref(' . $_[1] . ') eq "GLOB"' };
  
      # NOTE: scalar filehandles are GLOB refs, but a GLOB ref is not always a
      # filehandle
      subtype 'FileHandle'
          => as 'Ref'
          => where {
              (ref($_) eq "GLOB" && Scalar::Util::openhandle($_))
           || (blessed($_) && $_->isa("IO::Handle"));
          }
          => inline_as {
              '(ref(' . $_[1] . ') eq "GLOB" '
              . '&& Scalar::Util::openhandle(' . $_[1] . ')) '
              . '|| (Scalar::Util::blessed(' . $_[1] . ') '
              . '&& ' . $_[1] . '->isa("IO::Handle"))'
          };
  
      subtype 'Object'
          => as 'Ref'
          => where { blessed($_) }
          => inline_as { 'Scalar::Util::blessed(' . $_[1] . ')' };
  
      subtype 'ClassName'
          => as 'Str'
          => where { is_class_loaded($_) }
              # the long Str tests are redundant here
          => inline_as { 'Class::Load::is_class_loaded(' . $_[1] . ')' };
  
      subtype 'RoleName'
          => as 'ClassName'
          => where {
              (Class::MOP::class_of($_) || return)->isa('Moose::Meta::Role');
          }
          => inline_as {
              $_[0]->parent()->_inline_check($_[1])
              . ' && do {'
                  . 'my $meta = Class::MOP::class_of(' . $_[1] . ');'
                  . '$meta && $meta->isa("Moose::Meta::Role");'
              . '}'
          };
  
      $registry->add_type_constraint(
          Moose::Meta::TypeConstraint::Parameterizable->new(
              name               => 'ScalarRef',
              package_defined_in => __PACKAGE__,
              parent =>
                  Moose::Util::TypeConstraints::find_type_constraint('Ref'),
              constraint => sub { ref($_) eq 'SCALAR' || ref($_) eq 'REF' },
              constraint_generator => sub {
                  my $type_parameter = shift;
                  my $check = $type_parameter->_compiled_type_constraint;
                  return sub {
                      return $check->( ${$_} );
                  };
              },
              inlined => sub {
                  'ref(' . $_[1] . ') eq "SCALAR" '
                    . '|| ref(' . $_[1] . ') eq "REF"'
              },
              inline_generator => sub {
                  my $self           = shift;
                  my $type_parameter = shift;
                  my $val            = shift;
                  '(ref(' . $val . ') eq "SCALAR" || ref(' . $val . ') eq "REF") '
                    . '&& ' . $type_parameter->_inline_check('${(' . $val . ')}')
              },
          )
      );
  
      $registry->add_type_constraint(
          Moose::Meta::TypeConstraint::Parameterizable->new(
              name               => 'ArrayRef',
              package_defined_in => __PACKAGE__,
              parent =>
                  Moose::Util::TypeConstraints::find_type_constraint('Ref'),
              constraint => sub { ref($_) eq 'ARRAY' },
              constraint_generator => sub {
                  my $type_parameter = shift;
                  my $check = $type_parameter->_compiled_type_constraint;
                  return sub {
                      foreach my $x (@$_) {
                          ( $check->($x) ) || return;
                      }
                      1;
                      }
              },
              inlined          => sub { 'ref(' . $_[1] . ') eq "ARRAY"' },
              inline_generator => sub {
                  my $self           = shift;
                  my $type_parameter = shift;
                  my $val            = shift;
  
                  'do {'
                      . 'my $check = ' . $val . ';'
                      . 'ref($check) eq "ARRAY" '
                          . '&& &List::MoreUtils::all('
                              . 'sub { ' . $type_parameter->_inline_check('$_') . ' }, '
                              . '@{$check}'
                          . ')'
                  . '}';
              },
          )
      );
  
      $registry->add_type_constraint(
          Moose::Meta::TypeConstraint::Parameterizable->new(
              name               => 'HashRef',
              package_defined_in => __PACKAGE__,
              parent =>
                  Moose::Util::TypeConstraints::find_type_constraint('Ref'),
              constraint => sub { ref($_) eq 'HASH' },
              constraint_generator => sub {
                  my $type_parameter = shift;
                  my $check = $type_parameter->_compiled_type_constraint;
                  return sub {
                      foreach my $x ( values %$_ ) {
                          ( $check->($x) ) || return;
                      }
                      1;
                      }
              },
              inlined          => sub { 'ref(' . $_[1] . ') eq "HASH"' },
              inline_generator => sub {
                  my $self           = shift;
                  my $type_parameter = shift;
                  my $val            = shift;
  
                  'do {'
                      . 'my $check = ' . $val . ';'
                      . 'ref($check) eq "HASH" '
                          . '&& &List::MoreUtils::all('
                              . 'sub { ' . $type_parameter->_inline_check('$_') . ' }, '
                              . 'values %{$check}'
                          . ')'
                  . '}';
              },
          )
      );
  
      $registry->add_type_constraint(
          Moose::Meta::TypeConstraint::Parameterizable->new(
              name               => 'Maybe',
              package_defined_in => __PACKAGE__,
              parent =>
                  Moose::Util::TypeConstraints::find_type_constraint('Item'),
              constraint           => sub {1},
              constraint_generator => sub {
                  my $type_parameter = shift;
                  my $check = $type_parameter->_compiled_type_constraint;
                  return sub {
                      return 1 if not( defined($_) ) || $check->($_);
                      return;
                      }
              },
              inlined          => sub {'1'},
              inline_generator => sub {
                  my $self           = shift;
                  my $type_parameter = shift;
                  my $val            = shift;
                  '!defined(' . $val . ') '
                    . '|| (' . $type_parameter->_inline_check($val) . ')'
              },
          )
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =for pod_coverage_needs_some_pod
  
  =cut
  
I686-LINUX_MOOSE_UTIL_TYPECONSTRAINTS_BUILTINS

$fatpacked{"i686-linux/Package/Stash/XS.pm"} = <<'I686-LINUX_PACKAGE_STASH_XS';
  package Package::Stash::XS;
  BEGIN {
    $Package::Stash::XS::VERSION = '0.25';
  }
  use strict;
  use warnings;
  # ABSTRACT: faster and more correct implementation of the Package::Stash API
  
  use XSLoader;
  XSLoader::load(
      __PACKAGE__,
      # we need to be careful not to touch $VERSION at compile time, otherwise
      # DynaLoader will assume it's set and check against it, which will cause
      # fail when being run in the checkout without dzil having set the actual
      # $VERSION
      exists $Package::Stash::XS::{VERSION}
          ? ${ $Package::Stash::XS::{VERSION} } : (),
  );
  
  
  1;
  
  __END__
  =pod
  
  =head1 NAME
  
  Package::Stash::XS - faster and more correct implementation of the Package::Stash API
  
  =head1 VERSION
  
  version 0.25
  
  =head1 SYNOPSIS
  
    use Package::Stash;
  
  =head1 DESCRIPTION
  
  This is a backend for L<Package::Stash>, which provides the functionality in a
  way that's less buggy and much faster. It will be used by default if it's
  installed, and should be preferred in all environments with a compiler.
  
  =head1 BUGS
  
  No known bugs (but see the BUGS section in L<Package::Stash>).
  
  Please report any bugs through RT: email
  C<bug-package-stash-xs at rt.cpan.org>, or browse to
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Package-Stash-XS>.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<Class::MOP::Package>
  
  This module is a factoring out of code that used to live here
  
  =back
  
  =head1 SUPPORT
  
  You can find this documentation for this module with the perldoc command.
  
      perldoc Package::Stash::XS
  
  You can also look for information at:
  
  =over 4
  
  =item * AnnoCPAN: Annotated CPAN documentation
  
  L<http://annocpan.org/dist/Package-Stash-XS>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/d/Package-Stash-XS>
  
  =item * RT: CPAN's request tracker
  
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Package-Stash-XS>
  
  =item * Search CPAN
  
  L<http://search.cpan.org/dist/Package-Stash-XS>
  
  =back
  
  =head1 AUTHOR
  
  Jesse Luehrs <doy at tozt dot net>
  
  Based on code from L<Class::MOP::Package>, by Stevan Little and the Moose
  Cabal.
  
  =for Pod::Coverage add_symbol
  get_all_symbols
  get_or_add_symbol
  get_symbol
  has_symbol
  list_all_symbols
  name
  namespace
  new
  remove_glob
  remove_symbol
  
  =head1 AUTHOR
  
  Jesse Luehrs <doy at tozt dot net>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Jesse Luehrs.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
I686-LINUX_PACKAGE_STASH_XS

$fatpacked{"i686-linux/Params/Classify.pm"} = <<'I686-LINUX_PARAMS_CLASSIFY';
  =head1 NAME
  
  Params::Classify - argument type classification
  
  =head1 SYNOPSIS
  
  	use Params::Classify qw(
  		scalar_class
  		is_undef check_undef
  		is_string check_string
  		is_number check_number
  		is_glob check_glob
  		is_regexp check_regexp
  		is_ref check_ref ref_type
  		is_blessed check_blessed blessed_class
  		is_strictly_blessed check_strictly_blessed
  		is_able check_able
  	);
  
  	$c = scalar_class($arg);
  
  	if(is_undef($arg)) {
  	check_undef($arg);
  
  	if(is_string($arg)) {
  	check_string($arg);
  	if(is_number($arg)) {
  	check_number($arg);
  
  	if(is_glob($arg)) {
  	check_glob($arg);
  	if(is_regexp($arg)) {
  	check_regexp($arg);
  
  	if(is_ref($arg)) {
  	check_ref($arg);
  	$t = ref_type($arg);
  	if(is_ref($arg, "HASH")) {
  	check_ref($arg, "HASH");
  
  	if(is_blessed($arg)) {
  	check_blessed($arg);
  	if(is_blessed($arg, "IO::Handle")) {
  	check_blessed($arg, "IO::Handle");
  	$c = blessed_class($arg);
  	if(is_strictly_blessed($arg, "IO::Pipe::End")) {
  	check_strictly_blessed($arg, "IO::Pipe::End");
  	if(is_able($arg, ["print", "flush"])) {
  	check_able($arg, ["print", "flush"]);
  
  =head1 DESCRIPTION
  
  This module provides various type-testing functions.  These are intended
  for functions that, unlike most Perl code, care what type of data they
  are operating on.  For example, some functions wish to behave differently
  depending on the type of their arguments (like overloaded functions
  in C++).
  
  There are two flavours of function in this module.  Functions of the first
  flavour only provide type classification, to allow code to discriminate
  between argument types.  Functions of the second flavour package up the
  most common type of type discrimination: checking that an argument is
  of an expected type.  The functions come in matched pairs, of the two
  flavours, and so the type enforcement functions handle only the simplest
  requirements for arguments of the types handled by the classification
  functions.  Enforcement of more complex types may, of course, be built
  using the classification functions, or it may be more convenient to use
  a module designed for the more complex job, such as L<Params::Validate>.
  
  This module is implemented in XS, with a pure Perl backup version for
  systems that can't handle XS.
  
  =cut
  
  package Params::Classify;
  
  { use 5.006001; }
  use warnings;
  use strict;
  
  our $VERSION = "0.013";
  
  use parent "Exporter";
  our @EXPORT_OK = qw(
  	scalar_class
  	is_undef check_undef
  	is_string check_string
  	is_number check_number
  	is_glob check_glob
  	is_regexp check_regexp
  	is_ref check_ref ref_type
  	is_blessed check_blessed blessed_class
  	is_strictly_blessed check_strictly_blessed
  	is_able check_able
  );
  
  eval { local $SIG{__DIE__};
  	require XSLoader;
  	XSLoader::load(__PACKAGE__, $VERSION);
  };
  
  if($@ eq "") {
  	close(DATA);
  } else {
  	(my $filename = __FILE__) =~ tr# -~##cd;
  	local $/ = undef;
  	my $pp_code = "#line 128 \"$filename\"\n".<DATA>;
  	close(DATA);
  	{
  		local $SIG{__DIE__};
  		eval $pp_code;
  	}
  	die $@ if $@ ne "";
  }
  
  sub is_string($);
  sub is_number($) {
  	return 0 unless &is_string;
  	my $warned;
  	local $SIG{__WARN__} = sub { $warned = 1; };
  	my $arg = $_[0];
  	{ no warnings "void"; 0 + $arg; }
  	return !$warned;
  }
  
  sub check_number($) {
  	die "argument is not a number\n" unless &is_number;
  }
  
  1;
  
  __DATA__
  
  use Scalar::Util 1.01 qw(blessed reftype);
  
  =head1 TYPE CLASSIFICATION
  
  This module divides up scalar values into the following classes:
  
  =over
  
  =item *
  
  undef
  
  =item *
  
  string (defined ordinary scalar)
  
  =item *
  
  typeglob (yes, typeglobs fit into scalar variables)
  
  =item *
  
  regexp (first-class regular expression objects in Perl 5.11 onwards)
  
  =item *
  
  reference to unblessed object (further classified by physical data type
  of the referenced object)
  
  =item *
  
  reference to blessed object (further classified by class blessed into)
  
  =back
  
  These classes are mutually exclusive and should be exhaustive.  This
  classification has been chosen as the most useful when one wishes to
  discriminate between types of scalar.  Other classifications are possible.
  (For example, the two reference classes are distinguished by a feature of
  the referenced object; Perl does not internally treat this as a feature
  of the reference.)
  
  =head1 FUNCTIONS
  
  Each of these functions takes one scalar argument (I<ARG>) to be tested,
  possibly with other arguments specifying details of the test.  Any scalar
  value is acceptable for the argument to be tested.  Each C<is_> function
  returns a simple truth value result, which is true iff I<ARG> is of the
  type being checked for.  Each C<check_> function will return normally
  if the argument is of the type being checked for, or will C<die> if it
  is not.
  
  =head2 Classification
  
  =over
  
  =item scalar_class(ARG)
  
  Determines which of the five classes described above I<ARG> falls into.
  Returns "B<UNDEF>", "B<STRING>", "B<GLOB>", "B<REGEXP>", "B<REF>", or
  "B<BLESSED>" accordingly.
  
  =cut
  
  sub scalar_class($) {
  	my $type = reftype(\$_[0]);
  	if($type eq "SCALAR") {
  		$type = defined($_[0]) ? "STRING" : "UNDEF";
  	} elsif($type eq "REF") {
  		$type = "BLESSED" if defined(blessed($_[0]));
  	}
  	$type;
  }
  
  =back
  
  =head2 The Undefined Value
  
  =over
  
  =item is_undef(ARG)
  
  =item check_undef(ARG)
  
  Check whether I<ARG> is C<undef>.  C<is_undef(ARG)> is precisely
  equivalent to C<!defined(ARG)>, and is included for completeness.
  
  =cut
  
  sub is_undef($) { !defined($_[0]) }
  
  sub check_undef($) {
  	die "argument is not undefined\n" unless &is_undef;
  }
  
  =back
  
  =head2 Strings
  
  =over
  
  =item is_string(ARG)
  
  =item check_string(ARG)
  
  Check whether I<ARG> is defined and is an ordinary scalar value (not a
  reference, typeglob, or regexp).  This is what one usually thinks of as a
  string in Perl.  In fact, any scalar (including C<undef> and references)
  can be coerced to a string, but if you're trying to classify a scalar
  then you don't want to do that.
  
  =cut
  
  sub is_string($) { defined($_[0]) && reftype(\$_[0]) eq "SCALAR" }
  
  sub check_string($) {
  	die "argument is not a string\n" unless &is_string;
  }
  
  =item is_number(ARG)
  
  =item check_number(ARG)
  
  Check whether I<ARG> is defined and an ordinary scalar (i.e.,
  satisfies L</is_string> above) and is an acceptable number to Perl.
  This is what one usually thinks of as a number.
  
  Note that simple (L</is_string>-satisfying) scalars may have independent
  numeric and string values, despite the usual pretence that they have
  only one value.  Such a scalar is deemed to be a number if I<either> it
  already has a numeric value (e.g., was generated by a numeric literal
  or an arithmetic computation) I<or> its string value has acceptable
  syntax for a number (so it can be converted).  Where a scalar has
  separate numeric and string values (see L<Scalar::Util/dualvar>), it is
  possible for it to have an acceptable numeric value while its string
  value does I<not> have acceptable numeric syntax.  Be careful to use
  such a value only in a numeric context, if you are using it as a number.
  L<Scalar::Number/scalar_num_part> extracts the numeric part of a
  scalar as an ordinary number.  (C<0+ARG> suffices for that unless you
  need to preserve floating point signed zeroes.)
  
  A number may be either a native integer or a native floating point
  value, and there are several subtypes of floating point value.
  For classification, and other handling of numbers in scalars, see
  L<Scalar::Number>.  For details of the two numeric data types, see
  L<Data::Integer> and L<Data::Float>.
  
  This function differs from C<looks_like_number> (see
  L<Scalar::Util/looks_like_number>; also L<perlapi/looks_like_number>
  for a lower-level description) in excluding C<undef>, typeglobs,
  and references.  Why C<looks_like_number> returns true for C<undef>
  or typeglobs is anybody's guess.  References, if treated as numbers,
  evaluate to the address in memory that they reference; this is useful
  for comparing references for equality, but it is not otherwise useful
  to treat references as numbers.  Blessed references may have overloaded
  numeric operators, but if so then they don't necessarily behave like
  ordinary numbers.  C<looks_like_number> is also confused by dualvars:
  it looks at the string portion of the scalar.
  
  =back
  
  =head2 Typeglobs
  
  =over
  
  =item is_glob(ARG)
  
  =item check_glob(ARG)
  
  Check whether I<ARG> is a typeglob.
  
  =cut
  
  sub is_glob($) { reftype(\$_[0]) eq "GLOB" }
  
  sub check_glob($) {
  	die "argument is not a typeglob\n" unless &is_glob;
  }
  
  =back
  
  =head2 Regexps
  
  =over
  
  =item is_regexp(ARG)
  
  =item check_regexp(ARG)
  
  Check whether I<ARG> is a regexp object.
  
  =cut
  
  sub is_regexp($) { reftype(\$_[0]) eq "REGEXP" }
  
  sub check_regexp($) {
  	die "argument is not a regexp\n" unless &is_regexp;
  }
  
  =back
  
  =head2 References to Unblessed Objects
  
  =over
  
  =item is_ref(ARG)
  
  =item check_ref(ARG)
  
  Check whether I<ARG> is a reference to an unblessed object.  If it
  is, then the referenced data type can be determined using C<ref_type>
  (see below), which will return a string such as "HASH" or "SCALAR".
  
  =item ref_type(ARG)
  
  Returns C<undef> if I<ARG> is not a reference to an unblessed object.
  Otherwise, determines what type of object is referenced.  Returns
  "B<SCALAR>", "B<ARRAY>", "B<HASH>", "B<CODE>", "B<FORMAT>", or "B<IO>"
  accordingly.
  
  Note that, unlike C<ref>, this does not distinguish between different
  types of referenced scalar.  A reference to a string and a reference to
  a reference will both return "B<SCALAR>".  Consequently, what C<ref_type>
  returns for a particular reference will not change due to changes in
  the value of the referent, except for the referent being blessed.
  
  =item is_ref(ARG, TYPE)
  
  =item check_ref(ARG, TYPE)
  
  Check whether I<ARG> is a reference to an unblessed object of type
  I<TYPE>, as determined by L</ref_type>.  I<TYPE> must be a string.
  Possible I<TYPE>s are "B<SCALAR>", "B<ARRAY>", "B<HASH>", "B<CODE>",
  "B<FORMAT>", and "B<IO>".
  
  =cut
  
  {
  	my %xlate_reftype = (
  		REF    => "SCALAR",
  		SCALAR => "SCALAR",
  		LVALUE => "SCALAR",
  		GLOB   => "SCALAR",
  		REGEXP => "SCALAR",
  		ARRAY  => "ARRAY",
  		HASH   => "HASH",
  		CODE   => "CODE",
  		FORMAT => "FORMAT",
  		IO     => "IO",
  	);
  
  	my %reftype_ok = map { ($_ => undef) } qw(
  		SCALAR ARRAY HASH CODE FORMAT IO
  	);
  
  	sub ref_type($) {
  		my $reftype = &reftype;
  		return undef unless
  			defined($reftype) && !defined(blessed($_[0]));
  		my $xlated_reftype = $xlate_reftype{$reftype};
  		die "unknown reftype `$reftype', please update Params::Classify"
  			unless defined $xlated_reftype;
  		$xlated_reftype;
  	}
  
  	sub is_ref($;$) {
  		if(@_ == 2) {
  			die "reference type argument is not a string\n"
  				unless is_string($_[1]);
  			die "invalid reference type\n"
  				unless exists $reftype_ok{$_[1]};
  		}
  		my $reftype = reftype($_[0]);
  		return undef unless
  			defined($reftype) && !defined(blessed($_[0]));
  		return 1 if @_ != 2;
  		my $xlated_reftype = $xlate_reftype{$reftype};
  		die "unknown reftype `$reftype', please update Params::Classify"
  			unless defined $xlated_reftype;
  		return $xlated_reftype eq $_[1];
  	}
  }
  
  sub check_ref($;$) {
  	unless(&is_ref) {
  		die "argument is not a reference to plain ".
  			(@_ == 2 ? lc($_[1]) : "object")."\n";
  	}
  }
  
  =back
  
  =head2 References to Blessed Objects
  
  =over
  
  =item is_blessed(ARG)
  
  =item check_blessed(ARG)
  
  Check whether I<ARG> is a reference to a blessed object.  If it is,
  then the class into which the object was blessed can be determined using
  L</blessed_class>.
  
  =item is_blessed(ARG, CLASS)
  
  =item check_blessed(ARG, CLASS)
  
  Check whether I<ARG> is a reference to a blessed object that claims to
  be an instance of I<CLASS> (via its C<isa> method; see L<perlobj/isa>).
  I<CLASS> must be a string, naming a Perl class.
  
  =cut
  
  sub is_blessed($;$) {
  	die "class argument is not a string\n"
  		if @_ == 2 && !is_string($_[1]);
  	return defined(blessed($_[0])) && (@_ != 2 || $_[0]->isa($_[1]));
  }
  
  sub check_blessed($;$) {
  	unless(&is_blessed) {
  		die "argument is not a reference to blessed ".
  			(@_ == 2 ? $_[1] : "object")."\n";
  	}
  }
  
  =item blessed_class(ARG)
  
  Returns C<undef> if I<ARG> is not a reference to a blessed object.
  Otherwise, returns the class into which the object is blessed.
  
  C<ref> (see L<perlfunc/ref>) gives the same result on references
  to blessed objects, but different results on other types of value.
  C<blessed_class> is actually identical to L<Scalar::Util/blessed>.
  
  =cut
  
  *blessed_class = \&blessed;
  
  =item is_strictly_blessed(ARG)
  
  =item check_strictly_blessed(ARG)
  
  Check whether I<ARG> is a reference to a blessed object, identically
  to L</is_blessed>.  This exists only for symmetry; the useful form of
  C<is_strictly_blessed> appears below.
  
  =item is_strictly_blessed(ARG, CLASS)
  
  =item check_strictly_blessed(ARG, CLASS)
  
  Check whether I<ARG> is a reference to an object blessed into I<CLASS>
  exactly.  I<CLASS> must be a string, naming a Perl class.  Because this
  excludes subclasses, this is rarely what one wants, but there are some
  specialised occasions where it is useful.
  
  =cut
  
  sub is_strictly_blessed($;$) {
  	return &is_blessed unless @_ == 2;
  	die "class argument is not a string\n" unless is_string($_[1]);
  	my $blessed = blessed($_[0]);
  	return defined($blessed) && $blessed eq $_[1];
  }
  
  sub check_strictly_blessed($;$) {
  	return &check_blessed unless @_ == 2;
  	unless(&is_strictly_blessed) {
  		die "argument is not a reference to strictly blessed $_[1]\n";
  	}
  }
  
  =item is_able(ARG)
  
  =item check_able(ARG)
  
  Check whether I<ARG> is a reference to a blessed object, identically
  to L</is_blessed>.  This exists only for symmetry; the useful form of
  C<is_able> appears below.
  
  =item is_able(ARG, METHODS)
  
  =item check_able(ARG, METHODS)
  
  Check whether I<ARG> is a reference to a blessed object that claims to
  implement the methods specified by I<METHODS> (via its C<can> method;
  see L<perlobj/can>).  I<METHODS> must be either a single method name or
  a reference to an array of method names.  Each method name is a string.
  This interface check is often more appropriate than a direct ancestry
  check (such as L</is_blessed> performs).
  
  =cut
  
  sub _check_methods_arg($) {
  	return if &is_string;
  	die "methods argument is not a string or array\n"
  		unless is_ref($_[0], "ARRAY");
  	foreach(@{$_[0]}) {
  		die "method name is not a string\n" unless is_string($_);
  	}
  }
  
  sub is_able($;$) {
  	return &is_blessed unless @_ == 2;
  	_check_methods_arg($_[1]);
  	return 0 unless defined blessed $_[0];
  	foreach my $method (ref($_[1]) eq "" ? $_[1] : @{$_[1]}) {
  		return 0 unless $_[0]->can($method);
  	}
  	return 1;
  }
  
  sub check_able($;$) {
  	return &check_blessed unless @_ == 2;
  	_check_methods_arg($_[1]);
  	unless(defined blessed $_[0]) {
  		my $desc = ref($_[1]) eq "" ?
  				"method \"$_[1]\""
  			: @{$_[1]} == 0 ?
  				"at all"
  			:
  				"method \"".$_[1]->[0]."\"";
  		die "argument is not able to perform $desc\n";
  	}
  	foreach my $method (ref($_[1]) eq "" ? $_[1] : @{$_[1]}) {
  		die "argument is not able to perform method \"$method\"\n"
  			unless $_[0]->can($method);
  	}
  }
  
  =back
  
  =head1 BUGS
  
  Probably ought to handle something like L<Params::Validate>'s scalar
  type specification system, which makes much the same distinctions.
  
  =head1 SEE ALSO
  
  L<Data::Float>,
  L<Data::Integer>,
  L<Params::Validate>,
  L<Scalar::Number>,
  L<Scalar::Util>
  
  =head1 AUTHOR
  
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2004, 2006, 2007, 2009, 2010
  Andrew Main (Zefram) <zefram@fysh.org>
  
  Copyright (C) 2009, 2010 PhotoBox Ltd
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
  1;
I686-LINUX_PARAMS_CLASSIFY

$fatpacked{"i686-linux/Params/Util.pm"} = <<'I686-LINUX_PARAMS_UTIL';
  package Params::Util;
  
  =pod
  
  =head1 NAME
  
  Params::Util - Simple, compact and correct param-checking functions
  
  =head1 SYNOPSIS
  
    # Import some functions
    use Params::Util qw{_SCALAR _HASH _INSTANCE};
    
    # If you are lazy, or need a lot of them...
    use Params::Util ':ALL';
    
    sub foo {
        my $object  = _INSTANCE(shift, 'Foo') or return undef;
        my $image   = _SCALAR(shift)          or return undef;
        my $options = _HASH(shift)            or return undef;
        # etc...
    }
  
  =head1 DESCRIPTION
  
  C<Params::Util> provides a basic set of importable functions that makes
  checking parameters a hell of a lot easier
  
  While they can be (and are) used in other contexts, the main point
  behind this module is that the functions B<both> Do What You Mean,
  and Do The Right Thing, so they are most useful when you are getting
  params passed into your code from someone and/or somewhere else
  and you can't really trust the quality.
  
  Thus, C<Params::Util> is of most use at the edges of your API, where
  params and data are coming in from outside your code.
  
  The functions provided by C<Params::Util> check in the most strictly
  correct manner known, are documented as thoroughly as possible so their
  exact behaviour is clear, and heavily tested so make sure they are not
  fooled by weird data and Really Bad Things.
  
  To use, simply load the module providing the functions you want to use
  as arguments (as shown in the SYNOPSIS).
  
  To aid in maintainability, C<Params::Util> will B<never> export by
  default.
  
  You must explicitly name the functions you want to export, or use the
  C<:ALL> param to just have it export everything (although this is not
  recommended if you have any _FOO functions yourself with which future
  additions to C<Params::Util> may clash)
  
  =head1 FUNCTIONS
  
  =cut
  
  use 5.00503;
  use strict;
  require overload;
  require Exporter;
  require Scalar::Util;
  require DynaLoader;
  
  use vars qw{$VERSION @ISA @EXPORT_OK %EXPORT_TAGS};
  
  $VERSION   = '1.04';
  @ISA       = qw{
  	Exporter
  	DynaLoader
  };
  @EXPORT_OK = qw{
  	_STRING     _IDENTIFIER
  	_CLASS      _CLASSISA   _SUBCLASS  _DRIVER
  	_NUMBER     _POSINT     _NONNEGINT
  	_SCALAR     _SCALAR0
  	_ARRAY      _ARRAY0     _ARRAYLIKE
  	_HASH       _HASH0      _HASHLIKE
  	_CODE       _CODELIKE
  	_INVOCANT   _REGEX      _INSTANCE
  	_SET        _SET0
  	_HANDLE
  };
  %EXPORT_TAGS = ( ALL => \@EXPORT_OK );
  
  eval {
  	local $ENV{PERL_DL_NONLAZY} = 0 if $ENV{PERL_DL_NONLAZY};
  	bootstrap Params::Util $VERSION;
  	1;
  } unless $ENV{PERL_PARAMS_UTIL_PP};
  
  
  
  
  
  #####################################################################
  # Param Checking Functions
  
  =pod
  
  =head2 _STRING $string
  
  The C<_STRING> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a normal non-false string of non-zero length.
  
  Note that this will NOT do anything magic to deal with the special
  C<'0'> false negative case, but will return it.
  
    # '0' not considered valid data
    my $name = _STRING(shift) or die "Bad name";
    
    # '0' is considered valid data
    my $string = _STRING($_[0]) ? shift : die "Bad string";
  
  Please also note that this function expects a normal string. It does
  not support overloading or other magic techniques to get a string.
  
  Returns the string as a conveince if it is a valid string, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_STRING;
  sub _STRING ($) {
  	(defined $_[0] and ! ref $_[0] and length($_[0])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _IDENTIFIER $string
  
  The C<_IDENTIFIER> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a valid Perl identifier.
  
  Returns the string as a convenience if it is a valid identifier, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_IDENTIFIER;
  sub _IDENTIFIER ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*\z/s) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CLASS $string
  
  The C<_CLASS> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a valid Perl class.
  
  This function only checks that the format is valid, not that the
  class is actually loaded. It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASS;
  sub _CLASS ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CLASSISA $string, $class
  
  The C<_CLASSISA> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a particularly class, or a subclass of it.
  
  This function checks that the format is valid and calls the -E<gt>isa
  method on the class name. It does not check that the class is actually
  loaded.
  
  It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASSISA;
  sub _CLASSISA ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SUBCLASS $string, $class
  
  The C<_SUBCLASS> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a subclass of a specified class.
  
  This function checks that the format is valid and calls the -E<gt>isa
  method on the class name. It does not check that the class is actually
  loaded.
  
  It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SUBCLASS;
  sub _SUBCLASS ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0] ne $_[1] and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _NUMBER $scalar
  
  The C<_NUMBER> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a number. That is, it is defined and perl thinks it's a number.
  
  This function is basically a Params::Util-style wrapper around the
  L<Scalar::Util> C<looks_like_number> function.
  
  Returns the value as a convience, or C<undef> if the value is not a
  number.
  
  =cut
  
  eval <<'END_PERL' unless defined &_NUMBER;
  sub _NUMBER ($) {
  	( defined $_[0] and ! ref $_[0] and Scalar::Util::looks_like_number($_[0]) )
  	? $_[0]
  	: undef;
  }
  END_PERL
  
  =pod
  
  =head2 _POSINT $integer
  
  The C<_POSINT> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a positive integer (of any length).
  
  Returns the value as a convience, or C<undef> if the value is not a
  positive integer.
  
  The name itself is derived from the XML schema constraint of the same
  name.
  
  =cut
  
  eval <<'END_PERL' unless defined &_POSINT;
  sub _POSINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[1-9]\d*$/) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _NONNEGINT $integer
  
  The C<_NONNEGINT> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a non-negative integer (of any length). That is, a positive integer,
  or zero.
  
  Returns the value as a convience, or C<undef> if the value is not a
  non-negative integer.
  
  As with other tests that may return false values, care should be taken
  to test via "defined" in boolean validy contexts.
  
    unless ( defined _NONNEGINT($value) ) {
       die "Invalid value";
    }
  
  The name itself is derived from the XML schema constraint of the same
  name.
  
  =cut
  
  eval <<'END_PERL' unless defined &_NONNEGINT;
  sub _NONNEGINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^(?:0|[1-9]\d*)$/) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SCALAR \$scalar
  
  The C<_SCALAR> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<SCALAR> reference, with content of non-zero length.
  
  For a version that allows zero length C<SCALAR> references, see
  the C<_SCALAR0> function.
  
  Returns the C<SCALAR> reference itself as a convenience, or C<undef>
  if the value provided is not a C<SCALAR> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SCALAR;
  sub _SCALAR ($) {
  	(ref $_[0] eq 'SCALAR' and defined ${$_[0]} and ${$_[0]} ne '') ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SCALAR0 \$scalar
  
  The C<_SCALAR0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<SCALAR0> reference, allowing content of zero-length.
  
  For a simpler "give me some content" version that requires non-zero
  length, C<_SCALAR> function.
  
  Returns the C<SCALAR> reference itself as a convenience, or C<undef>
  if the value provided is not a C<SCALAR> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SCALAR0;
  sub _SCALAR0 ($) {
  	ref $_[0] eq 'SCALAR' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAY $value
  
  The C<_ARRAY> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<ARRAY> reference containing B<at least> one element of any kind.
  
  For a more basic form that allows zero length ARRAY references, see
  the C<_ARRAY0> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef>
  if the value provided is not an C<ARRAY> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAY;
  sub _ARRAY ($) {
  	(ref $_[0] eq 'ARRAY' and @{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAY0 $value
  
  The C<_ARRAY0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<ARRAY> reference, allowing C<ARRAY> references that contain no
  elements.
  
  For a more basic "An array of something" form that also requires at
  least one element, see the C<_ARRAY> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef>
  if the value provided is not an C<ARRAY> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAY0;
  sub _ARRAY0 ($) {
  	ref $_[0] eq 'ARRAY' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAYLIKE $value
  
  The C<_ARRAYLIKE> function tests whether a given scalar value can respond to
  array dereferencing.  If it can, the value is returned.  If it cannot,
  C<_ARRAYLIKE> returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAYLIKE;
  sub _ARRAYLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'ARRAY')
  		or
  		overload::Method($_[0], '@{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASH $value
  
  The C<_HASH> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<HASH> reference with at least one entry.
  
  For a version of this function that allows the C<HASH> to be empty,
  see the C<_HASH0> function.
  
  Returns the C<HASH> reference itself as a convenience, or C<undef>
  if the value provided is not an C<HASH> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASH;
  sub _HASH ($) {
  	(ref $_[0] eq 'HASH' and scalar %{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASH0 $value
  
  The C<_HASH0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<HASH> reference, regardless of the C<HASH> content.
  
  For a simpler "A hash of something" version that requires at least one
  element, see the C<_HASH> function.
  
  Returns the C<HASH> reference itself as a convenience, or C<undef>
  if the value provided is not an C<HASH> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASH0;
  sub _HASH0 ($) {
  	ref $_[0] eq 'HASH' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASHLIKE $value
  
  The C<_HASHLIKE> function tests whether a given scalar value can respond to
  hash dereferencing.  If it can, the value is returned.  If it cannot,
  C<_HASHLIKE> returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASHLIKE;
  sub _HASHLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'HASH')
  		or
  		overload::Method($_[0], '%{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CODE $value
  
  The C<_CODE> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<CODE> reference.
  
  Returns the C<CODE> reference itself as a convenience, or C<undef>
  if the value provided is not an C<CODE> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CODE;
  sub _CODE ($) {
  	ref $_[0] eq 'CODE' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CODELIKE $value
  
  The C<_CODELIKE> is the more generic version of C<_CODE>. Unlike C<_CODE>,
  which checks for an explicit C<CODE> reference, the C<_CODELIKE> function
  also includes things that act like them, such as blessed objects that
  overload C<'&{}'>.
  
  Please note that in the case of objects overloaded with '&{}', you will
  almost always end up also testing it in 'bool' context at some stage.
  
  For example:
  
    sub foo {
        my $code1 = _CODELIKE(shift) or die "No code param provided";
        my $code2 = _CODELIKE(shift);
        if ( $code2 ) {
             print "Got optional second code param";
        }
    }
  
  As such, you will most likely always want to make sure your class has
  at least the following to allow it to evaluate to true in boolean
  context.
  
    # Always evaluate to true in boolean context
    use overload 'bool' => sub () { 1 };
  
  Returns the callable value as a convenience, or C<undef> if the
  value provided is not callable.
  
  Note - This function was formerly known as _CALLABLE but has been renamed
  for greater symmetry with the other _XXXXLIKE functions.
  
  The use of _CALLABLE has been deprecated. It will continue to work, but
  with a warning, until end-2006, then will be removed.
  
  I apologise for any inconvenience caused.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CODELIKE;
  sub _CODELIKE($) {
  	(
  		(Scalar::Util::reftype($_[0])||'') eq 'CODE'
  		or
  		Scalar::Util::blessed($_[0]) and overload::Method($_[0],'&{}')
  	)
  	? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _INVOCANT $value
  
  This routine tests whether the given value is a valid method invocant.
  This can be either an instance of an object, or a class name.
  
  If so, the value itself is returned.  Otherwise, C<_INVOCANT>
  returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INVOCANT;
  sub _INVOCANT($) {
  	(defined $_[0] and
  		(defined Scalar::Util::blessed($_[0])
  		or      
  		# We used to check for stash definedness, but any class-like name is a
  		# valid invocant for UNIVERSAL methods, so we stopped. -- rjbs, 2006-07-02
  		Params::Util::_CLASS($_[0]))
  	) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _INSTANCE $object, $class
  
  The C<_INSTANCE> function is intended to be imported into your package,
  and provides a convenient way to test for an object of a particular class
  in a strictly correct manner.
  
  Returns the object itself as a convenience, or C<undef> if the value
  provided is not an object of that type.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INSTANCE;
  sub _INSTANCE ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _REGEX $value
  
  The C<_REGEX> function is intended to be imported into your package,
  and provides a convenient way to test for a regular expression.
  
  Returns the value itself as a convenience, or C<undef> if the value
  provided is not a regular expression.
  
  =cut
  
  eval <<'END_PERL' unless defined &_REGEX;
  sub _REGEX ($) {
  	(defined $_[0] and 'Regexp' eq ref($_[0])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SET \@array, $class
  
  The C<_SET> function is intended to be imported into your package,
  and provides a convenient way to test for set of at least one object of
  a particular class in a strictly correct manner.
  
  The set is provided as a reference to an C<ARRAY> of objects of the
  class provided.
  
  For an alternative function that allows zero-length sets, see the
  C<_SET0> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef> if
  the value provided is not a set of that class.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SET;
  sub _SET ($$) {
  	my $set = shift;
  	_ARRAY($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  
  =pod
  
  =head2 _SET0 \@array, $class
  
  The C<_SET0> function is intended to be imported into your package,
  and provides a convenient way to test for a set of objects of a
  particular class in a strictly correct manner, allowing for zero objects.
  
  The set is provided as a reference to an C<ARRAY> of objects of the
  class provided.
  
  For an alternative function that requires at least one object, see the
  C<_SET> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef> if
  the value provided is not a set of that class.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SET0;
  sub _SET0 ($$) {
  	my $set = shift;
  	_ARRAY0($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  
  =pod
  
  =head2 _HANDLE
  
  The C<_HANDLE> function is intended to be imported into your package,
  and provides a convenient way to test whether or not a single scalar
  value is a file handle.
  
  Unfortunately, in Perl the definition of a file handle can be a little
  bit fuzzy, so this function is likely to be somewhat imperfect (at first
  anyway).
  
  That said, it is implement as well or better than the other file handle
  detectors in existance (and we stole from the best of them).
  
  =cut
  
  # We're doing this longhand for now. Once everything is perfect,
  # we'll compress this into something that compiles more efficiently.
  # Further, testing file handles is not something that is generally
  # done millions of times, so doing it slowly is not a big speed hit.
  eval <<'END_PERL' unless defined &_HANDLE;
  sub _HANDLE {
  	my $it = shift;
  
  	# It has to be defined, of course
  	unless ( defined $it ) {
  		return undef;
  	}
  
  	# Normal globs are considered to be file handles
  	if ( ref $it eq 'GLOB' ) {
  		return $it;
  	}
  
  	# Check for a normal tied filehandle
  	# Side Note: 5.5.4's tied() and can() doesn't like getting undef
  	if ( tied($it) and tied($it)->can('TIEHANDLE') ) {
  		return $it;
  	}
  
  	# There are no other non-object handles that we support
  	unless ( Scalar::Util::blessed($it) ) {
  		return undef;
  	}
  
  	# Check for a common base classes for conventional IO::Handle object
  	if ( $it->isa('IO::Handle') ) {
  		return $it;
  	}
  
  
  	# Check for tied file handles using Tie::Handle
  	if ( $it->isa('Tie::Handle') ) {
  		return $it;
  	}
  
  	# IO::Scalar is not a proper seekable, but it is valid is a
  	# regular file handle
  	if ( $it->isa('IO::Scalar') ) {
  		return $it;
  	}
  
  	# Yet another special case for IO::String, which refuses (for now
  	# anyway) to become a subclass of IO::Handle.
  	if ( $it->isa('IO::String') ) {
  		return $it;
  	}
  
  	# This is not any sort of object we know about
  	return undef;
  }
  END_PERL
  
  =pod
  
  =head2 _DRIVER $string
  
    sub foo {
      my $class = _DRIVER(shift, 'My::Driver::Base') or die "Bad driver";
      ...
    }
  
  The C<_DRIVER> function is intended to be imported into your
  package, and provides a convenient way to load and validate
  a driver class.
  
  The most common pattern when taking a driver class as a parameter
  is to check that the name is a class (i.e. check against _CLASS)
  and then to load the class (if it exists) and then ensure that
  the class returns true for the isa method on some base driver name.
  
  Return the value as a convenience, or C<undef> if the value is not
  a class name, the module does not exist, the module does not load,
  or the class fails the isa test.
  
  =cut
  
  eval <<'END_PERL' unless defined &_DRIVER;
  sub _DRIVER ($$) {
  	(defined _CLASS($_[0]) and eval "require $_[0];" and ! $@ and $_[0]->isa($_[1]) and $_[0] ne $_[1]) ? $_[0] : undef;
  }
  END_PERL
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Add _CAN to help resolve the UNIVERSAL::can debacle
  
  - Would be even nicer if someone would demonstrate how the hell to
  build a Module::Install dist of the ::Util dual Perl/XS type. :/
  
  - Implement an assertion-like version of this module, that dies on
  error.
  
  - Implement a Test:: version of this module, for use in testing
  
  =head1 SUPPORT
  
  Bugs should be reported via the CPAN bug tracker at
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Params-Util>
  
  For other issues, contact the author.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<Params::Validate>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
I686-LINUX_PARAMS_UTIL

$fatpacked{"i686-linux/Sub/Name.pm"} = <<'I686-LINUX_SUB_NAME';
  package Sub::Name;
  
  =head1 NAME
  
  Sub::Name - (re)name a sub
  
  =head1 SYNOPSIS
  
      use Sub::Name;
  
      subname $name, $subref;
  
      $subref = subname foo => sub { ... };
  
  =head1 DESCRIPTION
  
  This module has only one function, which is also exported by default:
  
  =head2 subname NAME, CODEREF
  
  Assigns a new name to referenced sub.  If package specification is omitted in 
  the name, then the current package is used.  The return value is the sub.
  
  The name is only used for informative routines (caller, Carp, etc).  You won't 
  be able to actually invoke the sub by the given name.  To allow that, you need 
  to do glob-assignment yourself.
  
  Note that for anonymous closures (subs that reference lexicals declared outside 
  the sub itself) you can name each instance of the closure differently, which 
  can be very useful for debugging.
  
  =head1 AUTHOR
  
  Matthijs van Duin <xmath@cpan.org>
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  This program is free software; you can redistribute it and/or modify 
  it under the same terms as Perl itself.
  
  =cut
  
  use 5.006;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.05';
  
  use base 'Exporter';
  use base 'DynaLoader';
  
  our @EXPORT = qw(subname);
  our @EXPORT_OK = @EXPORT;
  
  bootstrap Sub::Name $VERSION;
  
  1;
I686-LINUX_SUB_NAME

$fatpacked{"i686-linux/Test/Moose.pm"} = <<'I686-LINUX_TEST_MOOSE';
  package Test::Moose;
  BEGIN {
    $Test::Moose::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $Test::Moose::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Sub::Exporter;
  use Test::Builder;
  
  use List::MoreUtils 'all';
  use Moose::Util 'does_role', 'find_meta';
  
  my @exports = qw[
      meta_ok
      does_ok
      has_attribute_ok
      with_immutable
  ];
  
  Sub::Exporter::setup_exporter({
      exports => \@exports,
      groups  => { default => \@exports }
  });
  
  ## the test builder instance ...
  
  my $Test = Test::Builder->new;
  
  ## exported functions
  
  sub meta_ok ($;$) {
      my ($class_or_obj, $message) = @_;
  
      $message ||= "The object has a meta";
  
      if (find_meta($class_or_obj)) {
          return $Test->ok(1, $message)
      }
      else {
          return $Test->ok(0, $message);
      }
  }
  
  sub does_ok ($$;$) {
      my ($class_or_obj, $does, $message) = @_;
  
      $message ||= "The object does $does";
  
      if (does_role($class_or_obj, $does)) {
          return $Test->ok(1, $message)
      }
      else {
          return $Test->ok(0, $message);
      }
  }
  
  sub has_attribute_ok ($$;$) {
      my ($class_or_obj, $attr_name, $message) = @_;
  
      $message ||= "The object does has an attribute named $attr_name";
  
      my $meta = find_meta($class_or_obj);
  
      if ($meta->find_attribute_by_name($attr_name)) {
          return $Test->ok(1, $message)
      }
      else {
          return $Test->ok(0, $message);
      }
  }
  
  sub with_immutable (&@) {
      my $block = shift;
      my $before = $Test->current_test;
      $block->();
      Class::MOP::class_of($_)->make_immutable for @_;
      $block->();
      my $num_tests = $Test->current_test - $before;
      return all { $_ } ($Test->summary)[-$num_tests..-1];
  }
  
  1;
  
  # ABSTRACT: Test functions for Moose specific features
  
  
  
  =pod
  
  =head1 NAME
  
  Test::Moose - Test functions for Moose specific features
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 SYNOPSIS
  
    use Test::More plan => 1;
    use Test::Moose;
  
    meta_ok($class_or_obj, "... Foo has a ->meta");
    does_ok($class_or_obj, $role, "... Foo does the Baz role");
    has_attribute_ok($class_or_obj, $attr_name, "... Foo has the 'bar' attribute");
  
  =head1 DESCRIPTION
  
  This module provides some useful test functions for Moose based classes. It
  is an experimental first release, so comments and suggestions are very welcome.
  
  =head1 EXPORTED FUNCTIONS
  
  =over 4
  
  =item B<meta_ok ($class_or_object)>
  
  Tests if a class or object has a metaclass.
  
  =item B<does_ok ($class_or_object, $role, ?$message)>
  
  Tests if a class or object does a certain role, similar to what C<isa_ok>
  does for the C<isa> method.
  
  =item B<has_attribute_ok($class_or_object, $attr_name, ?$message)>
  
  Tests if a class or object has a certain attribute, similar to what C<can_ok>
  does for the methods.
  
  =item B<with_immutable { CODE } @class_names>
  
  Runs B<CODE> (which should contain normal tests) twice, and make each
  class in C<@class_names> immutable in between the two runs.
  
  =back
  
  =head1 TODO
  
  =over 4
  
  =item Convert the Moose test suite to use this module.
  
  =item Here is a list of possible functions to write
  
  =over 4
  
  =item immutability predicates
  
  =item anon-class predicates
  
  =item discovering original method from modified method
  
  =item attribute metaclass predicates (attribute_isa?)
  
  =back
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<Test::More>
  
  =back
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
  
I686-LINUX_TEST_MOOSE

$fatpacked{"i686-linux/metaclass.pm"} = <<'I686-LINUX_METACLASS';
  
  package metaclass;
  BEGIN {
    $metaclass::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $metaclass::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Carp         'confess';
  use Class::Load  'load_class';
  use Scalar::Util 'blessed';
  use Try::Tiny;
  
  use Class::MOP;
  
  sub import {
      my ( $class, @args ) = @_;
  
      unshift @args, "metaclass" if @args % 2 == 1;
      my %options = @args;
  
      my $meta_name = exists $options{meta_name} ? $options{meta_name} : 'meta';
      my $metaclass = delete $options{metaclass};
  
      unless ( defined $metaclass ) {
          $metaclass = "Class::MOP::Class";
      } else {
          load_class($metaclass);
      }
  
      ($metaclass->isa('Class::MOP::Class'))
          || confess "The metaclass ($metaclass) must be derived from Class::MOP::Class";
  
      # make sure the custom metaclasses get loaded
      foreach my $key (grep { /_(?:meta)?class$/ } keys %options) {
          unless ( ref( my $class = $options{$key} ) ) {
              load_class($class)
          }
      }
  
      my $package = caller();
  
      # create a meta object so we can install &meta
      my $meta = $metaclass->initialize($package => %options);
      $meta->_add_meta_method($meta_name)
          if defined $meta_name;
  }
  
  1;
  
  # ABSTRACT: a pragma for installing and using Class::MOP metaclasses
  
  
  
  =pod
  
  =head1 NAME
  
  metaclass - a pragma for installing and using Class::MOP metaclasses
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 SYNOPSIS
  
    package MyClass;
  
    # use Class::MOP::Class
    use metaclass;
  
    # ... or use a custom metaclass
    use metaclass 'MyMetaClass';
  
    # ... or use a custom metaclass
    # and custom attribute and method
    # metaclasses
    use metaclass 'MyMetaClass' => (
        'attribute_metaclass' => 'MyAttributeMetaClass',
        'method_metaclass'    => 'MyMethodMetaClass',
    );
  
    # ... or just specify custom attribute
    # and method classes, and Class::MOP::Class
    # is the assumed metaclass
    use metaclass (
        'attribute_metaclass' => 'MyAttributeMetaClass',
        'method_metaclass'    => 'MyMethodMetaClass',
    );
  
    # if we'd rather not install a 'meta' method, we can do this
    use metaclass meta_name => undef;
    # or if we'd like it to have a different name,
    use metaclass meta_name => 'my_meta';
  
  =head1 DESCRIPTION
  
  This is a pragma to make it easier to use a specific metaclass
  and a set of custom attribute and method metaclasses. It also
  installs a C<meta> method to your class as well, unless C<undef>
  is passed to the C<meta_name> option.
  
  Note that if you are using Moose, you most likely do B<not> want
  to be using this - look into L<Moose::Util::MetaRole> instead.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_METACLASS

$fatpacked{"i686-linux/oose.pm"} = <<'I686-LINUX_OOSE';
  package oose;
  BEGIN {
    $oose::AUTHORITY = 'cpan:STEVAN';
  }
  {
    $oose::VERSION = '2.0401';
  }
  
  use strict;
  use warnings;
  
  use Class::Load qw(load_class);
  
  BEGIN {
      my $package;
      sub import {
          $package = $_[1] || 'Class';
          if ($package =~ /^\+/) {
              $package =~ s/^\+//;
              load_class($package);
          }
      }
      use Filter::Simple sub { s/^/package $package;\nuse Moose;use Moose::Util::TypeConstraints;\n/; }
  }
  
  1;
  
  # ABSTRACT: syntactic sugar to make Moose one-liners easier
  
  
  
  =pod
  
  =head1 NAME
  
  oose - syntactic sugar to make Moose one-liners easier
  
  =head1 VERSION
  
  version 2.0401
  
  =head1 SYNOPSIS
  
    # create a Moose class on the fly ...
    perl -Moose=Foo -e 'has bar => ( is=>q[ro], default => q[baz] ); print Foo->new->bar' # prints baz
  
    # loads an existing class (Moose or non-Moose)
    # and re-"opens" the package definition to make
    # debugging/introspection easier
    perl -Moose=+My::Class -e 'print join ", " => __PACKAGE__->meta->get_method_list'
  
    # also loads Moose::Util::TypeConstraints to allow subtypes etc
    perl -Moose=Person -e'subtype q[ValidAge] => as q[Int] => where { $_ > 0 && $_ < 78 }; has => age ( isa => q[ValidAge], is => q[ro]); Person->new(age => 90)'
  
  =head1 DESCRIPTION
  
  oose.pm is a simple source filter that adds
  C<package $name; use Moose; use Moose::Util::TypeConstraints;>
  to the beginning of your script and was entirely created because typing
  C<perl -e'package Foo; use Moose; ...'> was annoying me.
  
  =head1 INTERFACE
  
  oose provides exactly one method and it's automatically called by perl:
  
  =over 4
  
  =item B<import($package)>
  
  Pass a package name to import to be used by the source filter. The
  package defaults to C<Class> if none is given.
  
  =back
  
  =head1 DEPENDENCIES
  
  You will need L<Filter::Simple> and eventually L<Moose>
  
  =head1 INCOMPATIBILITIES
  
  None reported. But it is a source filter and might have issues there.
  
  =head1 BUGS
  
  See L<Moose/BUGS> for details on reporting bugs.
  
  =head1 AUTHOR
  
  Moose is maintained by the Moose Cabal, along with the help of many contributors. See L<Moose/CABAL> and L<Moose/CONTRIBUTORS> for details.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by Infinity Interactive, Inc..
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  
  __END__
  
I686-LINUX_OOSE

s/^  //mg for values %fatpacked;

unshift @INC, sub {
  if (my $fat = $fatpacked{$_[1]}) {
    open my $fh, '<', \$fat
      or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
    return $fh;
  }
  return
};

} # END OF FATPACK CODE

use strict;
use warnings;

use MahewinWmfsStatus;

my $wmfs_status = MahewinWmfsStatus->new;
$wmfs_status->run;
